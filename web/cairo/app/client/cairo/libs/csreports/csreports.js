var CSReports;
(function (CSReports) {
    var CSChartServer;
    (function (CSChartServer) {
        class PieChartFont {
        }
        CSChartServer.PieChartFont = PieChartFont;
        class PieChartTitleOptions {
        }
        CSChartServer.PieChartTitleOptions = PieChartTitleOptions;
        class PieChartOptions {
        }
        CSChartServer.PieChartOptions = PieChartOptions;
        class PieChart {
            constructor(options) {
                this.options = options;
                this.canvas = options.canvas;
                this.ctx = this.canvas.getContext("2d");
                this.colors = options.colors;
                this.titleOptions = options.titleOptions;
                this.totalValue = this.options.data.map(s => s.getPrimaryValue()).reduce((a, b) => a + b, 0);
                this.radius = Math.min(this.canvas.width / 2, this.canvas.height / 2) - options.padding;
            }
            drawSlices() {
                var colorIndex = 0;
                var startAngle = -Math.PI / 2;
                for (let i = 0; i < this.options.data.length; i++) {
                    var val = this.options.data[i].getPrimaryValue();
                    var sliceAngle = (2 * Math.PI * val) / this.totalValue;
                    this.drawPieSlice(this.ctx, this.canvas.width / 2, this.canvas.height / 2, this.radius, startAngle, startAngle + sliceAngle, this.colors[colorIndex % this.colors.length]);
                    startAngle += sliceAngle;
                    colorIndex++;
                }
                if (this.options.doughnutHoleSize) {
                    this.drawPieSlice(this.ctx, this.canvas.width / 2, this.canvas.height / 2, this.options.doughnutHoleSize * this.radius, 0, 2 * Math.PI, "#FFF", "#FFF");
                    this.drawArc(this.ctx, this.canvas.width / 2, this.canvas.height / 2, this.options.doughnutHoleSize * this.radius, 0, 2 * Math.PI, "#000");
                }
            }
            drawLabels() {
                var colorIndex = 0;
                var startAngle = -Math.PI / 2;
                for (let i = 0; i < this.options.data.length; i++) {
                    var val = this.options.data[i].getPrimaryValue();
                    var sliceAngle = (2 * Math.PI * val) / this.totalValue;
                    var labelX = this.canvas.width / 2 +
                        (this.radius / 2) * Math.cos(startAngle + sliceAngle / 2);
                    var labelY = this.canvas.height / 2 +
                        (this.radius / 2) * Math.sin(startAngle + sliceAngle / 2);
                    if (this.options.doughnutHoleSize) {
                        var offset = (this.radius * this.options.doughnutHoleSize) / 2;
                        labelX =
                            this.canvas.width / 2 +
                                (offset + this.radius / 2) * Math.cos(startAngle + sliceAngle / 2);
                        labelY =
                            this.canvas.height / 2 +
                                (offset + this.radius / 2) * Math.sin(startAngle + sliceAngle / 2);
                    }
                    var labelText = Math.round((100 * val) / this.totalValue);
                    this.ctx.fillStyle = "black";
                    this.ctx.font = "20px Mono";
                    this.ctx.fillText(labelText + "%", labelX - 20, labelY);
                    startAngle += sliceAngle;
                }
            }
            drawTitle() {
                this.ctx.save();
                this.ctx.textBaseline = "bottom";
                this.ctx.textAlign = this.titleOptions.align;
                this.ctx.fillStyle = this.titleOptions.fill;
                this.ctx.font = `${this.titleOptions.font.weight} ${this.titleOptions.font.size} ${this.titleOptions.font.family}`;
                let xPos = this.canvas.width / 2;
                if (this.titleOptions.align == "left") {
                    xPos = 10;
                }
                if (this.titleOptions.align == "right") {
                    xPos = this.canvas.width - 10;
                }
                this.ctx.fillText(this.options.seriesName, xPos, this.canvas.height);
                this.ctx.restore();
            }
            drawLegend() {
            }
            draw() {
                this.drawSlices();
                this.drawLabels();
                this.drawTitle();
                this.drawLegend();
            }
            drawLine(ctx, startX, startY, endX, endY, color) {
                ctx.save();
                ctx.strokeStyle = color;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.restore();
            }
            drawArc(ctx, centerX, centerY, radius, startAngle, endAngle, color) {
                ctx.save();
                ctx.strokeStyle = color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.stroke();
                ctx.restore();
            }
            drawPieSlice(ctx, centerX, centerY, radius, startAngle, endAngle, fillColor, strokeColor) {
                ctx.save();
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        }
        CSChartServer.PieChart = PieChart;
    })(CSChartServer = CSReports.CSChartServer || (CSReports.CSChartServer = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSOAPI;
    (function (CSOAPI) {
        class NotImplementedException extends Error {
        }
        CSOAPI.NotImplementedException = NotImplementedException;
    })(CSOAPI = CSReports.CSOAPI || (CSReports.CSOAPI = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSChartServer;
    (function (CSChartServer) {
        class cWebChart {
            constructor() {
                this.items = new CSChartServer.cWebChartItems();
            }
            getItems() {
                return this.items;
            }
            newChartType(chartType, chartTitle) {
                this.chartType = chartType;
                this.chartTitle = chartTitle;
            }
            setPrimaryColor(color) {
                this.primaryColor = color;
            }
            setGridLines(chartLineStyle) {
                this.chartLineStyle = chartLineStyle;
            }
            setOutlineBars(chartBarOutline) {
                this.chartBarOutline = chartBarOutline;
            }
            setShowValues(chartShowValues) {
                this.chartShowValues = chartShowValues;
            }
            setShowLegend(showLegend) {
                this.showLegend = showLegend;
            }
            setThickness(pieThickness) {
                this.pieThickness = pieThickness;
            }
            setDiameter(value) {
                this.pieDiameter = value;
            }
            setPrimaryLabel(value) {
                this.primaryLabel = value;
            }
            setAlternateColor(color) {
                this.alternateColor = color;
            }
            setAlternateLabel(value) {
                this.alternateLabel = value;
            }
            renderWebChartImage(width, height) {
                const canvas = new OffscreenCanvas(width, height);
                const pieChart = new CSChartServer.PieChart({
                    canvas: canvas,
                    seriesName: this.chartTitle,
                    padding: 40,
                    data: this.items.getValues(),
                    colors: ["#80DEEA", "#FFE082", "#FFAB91", "#CE93D8"],
                    titleOptions: {
                        align: "center",
                        fill: "black",
                        font: {
                            weight: "bold",
                            size: "24px",
                            family: "Mono"
                        }
                    },
                    doughnutHoleSize: 0.3
                });
                pieChart.draw();
                const ctx = canvas.getContext('2d');
                this.image = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
            }
            getImage() {
                return this.image;
            }
            setCopyRight(copyright) {
                this.copyRight = copyright;
            }
            dispose() {
            }
        }
        CSChartServer.cWebChart = cWebChart;
    })(CSChartServer = CSReports.CSChartServer || (CSReports.CSChartServer = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSChartServer;
    (function (CSChartServer) {
        class cWebChartItem {
            constructor() {
                this.primaryValue = 0;
                this.primaryLabel = "";
                this.pieLabel = "";
                this.alternateValue = 0;
                this.alternateLabel = "";
                this.explode = false;
            }
            setPrimaryValue(value) {
                this.primaryValue = value;
            }
            setPrimaryLabel(label) {
                this.primaryLabel = label;
            }
            setPieLabel(value) {
                this.pieLabel = value;
            }
            setAlternateValue(value) {
                this.alternateValue = value;
            }
            setAlternateLabel(value) {
                this.alternateLabel = value;
            }
            setExplode(value) {
                this.explode = value;
            }
            getPrimaryValue() {
                return this.primaryValue;
            }
            getPrimaryLabel() {
                return this.primaryLabel;
            }
        }
        CSChartServer.cWebChartItem = cWebChartItem;
    })(CSChartServer = CSReports.CSChartServer || (CSReports.CSChartServer = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSOAPI;
    (function (CSOAPI) {
        class Exception {
            constructor(message) {
                this.message = message;
            }
            getMessage() {
                return this.message;
            }
        }
        CSOAPI.Exception = Exception;
    })(CSOAPI = CSReports.CSOAPI || (CSReports.CSOAPI = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSOAPI;
    (function (CSOAPI) {
        class ArgumentException extends CSOAPI.Exception {
        }
        CSOAPI.ArgumentException = ArgumentException;
        class ArgumentNullException extends CSOAPI.Exception {
        }
        CSOAPI.ArgumentNullException = ArgumentNullException;
        class InvalidOperationException extends CSOAPI.Exception {
        }
        CSOAPI.InvalidOperationException = InvalidOperationException;
        class KeyAlreadyExistsInCollection extends CSOAPI.Exception {
        }
        CSOAPI.KeyAlreadyExistsInCollection = KeyAlreadyExistsInCollection;
    })(CSOAPI = CSReports.CSOAPI || (CSReports.CSOAPI = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSOAPI;
    (function (CSOAPI) {
        var KeyAlreadyExistsInCollection = CSOAPI.KeyAlreadyExistsInCollection;
        class Map {
            constructor(map = null, readOnly = false, construct = null) {
                this.keys = [];
                this.values = [];
                this.isReadOnly = false;
                this.length = 0;
                this.keyIndex = 1;
                if (map !== null) {
                    for (let i_ = 0; i_ < map.getKeys().length; i_++) {
                        const de = map.item(map.getKeys[i_]);
                        this.add(de, map.getKeys[i_]);
                    }
                }
                this.isReadOnly = readOnly;
                this.construct = construct;
            }
            getKeys() {
                return this.keys;
            }
            getValues() {
                return this.values;
            }
            add(value, key) {
                return this.baseAdd(value, key);
            }
            baseAdd(value, key) {
                if (this.keys.indexOf(key) > -1) {
                    throw new KeyAlreadyExistsInCollection("The key " + key + " is already present in this Map.");
                }
                if (value === null && this.construct) {
                    value = new this.construct();
                    if (value.setKey !== undefined)
                        value.setKey(key);
                }
                if (key === undefined || key === null || key === "") {
                    key = "___k" + this.keyIndex++;
                }
                this.keys.push(key);
                this.values.push(value);
                this.length++;
                return value;
            }
            put(value, key) {
                const index = this.keys.indexOf(key);
                if (index > -1) {
                    this.values[index] = value;
                }
                else {
                    this.keys.push(key);
                    this.values.push(value);
                }
                return value;
            }
            baseRemove(indexOrKey) {
                if (typeof indexOrKey === "string")
                    this.removeByKey(indexOrKey);
                else
                    this.removeByIndex(indexOrKey);
            }
            remove(indexOrKey) {
                this.baseRemove(indexOrKey);
            }
            removeByObject(obj) {
                for (let i = 0; i < this.length; i++) {
                    if (obj === this.values[i]) {
                        this.removeByIndex(i);
                        break;
                    }
                }
            }
            removeByKey(key) {
                this.removeByIndex(this.keys.indexOf(key));
            }
            removeByIndex(index) {
                if (index > -1) {
                    this.keys.splice(index, 1);
                    this.values.splice(index, 1);
                    this.length -= 1;
                }
            }
            baseClear() {
                this.length = 0;
                this.keys = [];
                this.values = [];
            }
            clear() {
                this.baseClear();
            }
            size() {
                return this.count();
            }
            count() {
                return this.length;
            }
            baseItem(indexOrKey) {
                try {
                    if (typeof indexOrKey === "string")
                        return this.itemByKey(indexOrKey);
                    else
                        return this.itemByIndex(indexOrKey);
                }
                catch (ignore) {
                    return null;
                }
            }
            item(indexOrKey) {
                return this.baseItem(indexOrKey);
            }
            update(index, value) {
                if (index > -1 && index < this.length) {
                    this.values[index] = value;
                }
            }
            containsKey(key) {
                return this.keys.indexOf(key) > -1;
            }
            itemByKey(key) {
                return this.itemByIndex(this.keys.indexOf(key));
            }
            indexByKey(key) {
                return this.keys.indexOf(key);
            }
            keyByIndex(index) {
                return this.keys[index];
            }
            itemByIndex(index) {
                if (index > -1)
                    return this.values[index];
                else
                    return null;
            }
            forEach(f) {
                for (let i = 0; i < this.length; i++) {
                    f(this.keys[i], this.values[i]);
                }
            }
            anyMatch(f) {
                for (let i = 0; i < this.length; i++) {
                    if (f(this.keys[i], this.values[i]))
                        return true;
                }
                return false;
            }
            find(f) {
                for (let i = 0; i < this.length; i++) {
                    if (f(this.keys[i], this.values[i]))
                        return this.values[i];
                }
                return null;
            }
            filter(f) {
                const map = new Map();
                for (let i = 0; i < this.length; i++) {
                    if (f(this.values[i]))
                        map.add(this.values[i], this.keys[i]);
                }
                return map;
            }
            forEachValue(f) {
                this.values.forEach(f);
            }
            map(f) {
                return this.values.map(f);
            }
            getChunk(start, size) {
                const map = new Map();
                map.keys = this.keys.slice(start, start + size);
                map.values = this.values.slice(start, start + size);
                map.length = map.keys.length;
                return map;
            }
            concat(map) {
                this.keys = this.keys.concat(map.keys);
                this.values = this.values.concat(map.values);
                this.length = this.values.length;
                this.keyIndex = this.length;
            }
            copy(from) {
                this.keys = from.keys;
                this.values = from.values;
                this.length = from.values.length;
                this.keyIndex = this.length;
            }
        }
        CSOAPI.Map = Map;
    })(CSOAPI = CSReports.CSOAPI || (CSReports.CSOAPI = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSChartServer;
    (function (CSChartServer) {
        var Map = CSReports.CSOAPI.Map;
        class cWebChartItems extends Map {
            constructor() {
                super(null, false, CSChartServer.cWebChartItem);
            }
        }
        CSChartServer.cWebChartItems = cWebChartItems;
    })(CSChartServer = CSReports.CSChartServer || (CSReports.CSChartServer = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        class Constants {
        }
        Constants.SQL_DATE_STRING = "yyyyMMdd HH:mm:ss";
        Constants.NO_ID = 0;
        Constants.NO_DATE = new Date("1900-01-01T00:00:00Z");
        CSDatabase.Constants = Constants;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        class DataTable {
            constructor() {
                this.columns = [];
                this.rows = [];
            }
            load(dr) {
                for (let i = 0; i < dr.fieldCount(); i++) {
                    this.columns.push(new DataColumn(dr.getName(i), dr.getColumnType(i)));
                }
                while (dr.read()) {
                    const row = [];
                    dr.getValues(row);
                    this.rows.push(row);
                }
            }
            getFieldCount() {
                return this.columns.length;
            }
            getColumnName(i) {
                return this.columns[i].getName();
            }
            getFieldType(i) {
                switch (this.columns[i].getDataType()) {
                    case DataType.dbDate:
                        return CSDatabase.csDataType.CS_TD_DATE;
                    case DataType.dbImage:
                        return CSDatabase.csDataType.CS_TD_LONGVARBINARY;
                    case DataType.dbNumber:
                        return CSDatabase.csDataType.CS_TD_NUMERIC;
                    case DataType.dbText:
                        return CSDatabase.csDataType.CS_TD_VARCHAR;
                }
            }
            getRows() {
                return this.rows;
            }
        }
        CSDatabase.DataTable = DataTable;
        let DataType;
        (function (DataType) {
            DataType[DataType["dbImage"] = 1] = "dbImage";
            DataType[DataType["dbNumber"] = 2] = "dbNumber";
            DataType[DataType["dbText"] = 3] = "dbText";
            DataType[DataType["dbDate"] = 4] = "dbDate";
        })(DataType = CSDatabase.DataType || (CSDatabase.DataType = {}));
        class DataColumn {
            constructor(name, dataType) {
                this.name = name;
                this.dataType = dataType;
            }
            getName() {
                return this.name;
            }
            getDataType() {
                return this.dataType;
            }
        }
        CSDatabase.DataColumn = DataColumn;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSOAPI;
    (function (CSOAPI) {
        class Utils {
            static parseInt(value) {
                return parseInt(value.toString());
            }
            static isNumber(value) {
                try {
                    return !isNaN(parseFloat(value.toString()));
                }
                catch (ignore) {
                    return false;
                }
            }
            static val(value) {
                if (value === null || value === undefined)
                    return 0;
                else {
                    try {
                        value = parseFloat(value);
                        return isNaN(value) ? 0 : value;
                    }
                    catch (ignore) {
                        return 0;
                    }
                }
            }
            static valEx(value) {
                if (value === null || value === undefined)
                    return 0;
                else if (value === true)
                    return -1;
                else if (value === false)
                    return 0;
                else {
                    try {
                        value = parseFloat(value);
                        return isNaN(value) ? 0 : value;
                    }
                    catch (ignore) {
                        return 0;
                    }
                }
            }
            static valInt(value) {
                return parseInt(this.val(value));
            }
            static divideByZero(x1, x2) {
                if (x2 !== 0) {
                    return x1 / x2;
                }
                else {
                    return 0;
                }
            }
            static setSepDecimal() {
                const decimalSeparator = 1.1;
                Utils._sepDecimal = decimalSeparator.toLocaleString().substring(1, 2);
            }
            static getSepDecimal() {
                return (1.1).toLocaleString().substring(1, 2);
            }
            static removeLastColon(list) {
                list = list.trim();
                if (list.substring(list.length - 1) === ",") {
                    return list.substring(0, list.length - 1);
                }
                else {
                    return list;
                }
            }
            static setInfoString(source, key, value) {
                key = "#" + key;
                let i = source.toLowerCase().indexOf(key.toLowerCase(), 0);
                if (source.toLowerCase().indexOf(key.toLowerCase(), i + 1) !== -1) {
                    throw (new CSOAPI.Exception("cUtil.getInfoString: the key can't apears more than one."));
                }
                if (i === -1) {
                    return source + key + "=" + value + ";";
                }
                else {
                    const c_errorstr = "cUtil.getInfoString: source invalid, the character {0} is not present.";
                    let j = source.toLowerCase().indexOf(";".toLowerCase(), i);
                    if (j === -1) {
                        throw (new CSOAPI.Exception(this.format(c_errorstr, ";")));
                    }
                    debugger;
                    let k = source.substring(i, j - i).toLowerCase().indexOf("=".toLowerCase(), 0);
                    if (k === -1) {
                        throw (new CSOAPI.Exception(this.format(c_errorstr, "=")));
                    }
                    k = k + i;
                    debugger;
                    return source.substring(0, k) + value + source.substring(j);
                }
            }
            static format(text, ...args) {
                return text.replace(/{(\d+)}/g, (match, num) => {
                    return typeof args[num] !== 'undefined' ? args[num] : match;
                });
            }
            static isNullOrEmpty(value) {
                return value === null || value === undefined || value.toString().trim().length === 0;
            }
            static getInfoString(source, key, defaultValue) {
                if (this.isNullOrEmpty(source)) {
                    return defaultValue;
                }
                key = "#" + key;
                let i = source.toLowerCase().indexOf(key.toLowerCase(), 0);
                if (source.toLowerCase().indexOf(key.toLowerCase(), i + 1) !== -1) {
                    throw (new CSOAPI.Exception("cUtil.getInfoString: the key can't apears more than one."));
                }
                if (i === -1) {
                    return defaultValue;
                }
                else {
                    const c_errorstr = "cUtil.getInfoString: source invalid, the character {0} is not present.";
                    let j = source.toLowerCase().indexOf(";".toLowerCase(), i);
                    if (j === -1) {
                        throw (new CSOAPI.Exception(this.format(c_errorstr, ";")));
                    }
                    let k = source.substring(i, j).toLowerCase().indexOf("=".toLowerCase(), 0);
                    if (k === -1) {
                        throw (new CSOAPI.Exception(this.format(c_errorstr, "=")));
                    }
                    k = k + i;
                    return source.substring(k + 1, j);
                }
            }
            static getToken(token, source) {
                let i = 0;
                let s = "";
                debugger;
                if (token.substring(token.length - 1, 1) !== "=")
                    token += "=";
                let l = source.length;
                i = source.indexOf(token);
                if (i === -1)
                    return "";
                i += token.length - 1;
                while (true) {
                    i++;
                    if (i > l)
                        break;
                    debugger;
                    let c = source.substring(i, 1);
                    if (c !== ";")
                        s += c;
                    else
                        break;
                }
                return s;
            }
            static tp(twips) {
                const nTwipsPerInch = 1440;
                let dpi = Utils.getDPI();
                return Math.round((twips / nTwipsPerInch) * dpi);
            }
            static pt(pixels) {
                const nTwipsPerInch = 1440;
                let dpi = Utils.getDPI();
                return Math.round((pixels / dpi) * nTwipsPerInch);
            }
            static getDPI() {
                if (Utils._dpi < 0) {
                    Utils._dpi = 96;
                }
                return Utils._dpi;
            }
            static isVisible(el) {
                return !this.isHidden(el);
            }
            static isHidden(el) {
                try {
                    return (window.getComputedStyle(el).display === 'none');
                }
                catch (ex) {
                    console.log(ex);
                    return false;
                }
            }
            static listAdd(list, value, id = 0) {
                this.listAdd_(list, value, id);
            }
            static listID(list) {
                return this.listID_(list);
            }
            static listItemData(list, index) {
                return this.listItemData_(list, index);
            }
            static listSetListIndex(list, idx) {
                this.listSetListIndex_(list, idx);
            }
            static listSetListIndexForId(list, id) {
                this.listSetListIndexForId_(list, id);
            }
            static listSetListIndexForText(list, text) {
                this.listSetListIndexForText_(list, text);
            }
            static listChangeTextForSelected(list, value) {
                this.listChangeTextForSelected_(list, value);
            }
            static listChangeText(list, idx, value) {
                this.listChangeText_(list, idx, value);
            }
            static listGetIndexFromItemData(list, valueItemData) {
                return this.listGetIndexFromItemData_(list, valueItemData);
            }
            static listAdd_(list, value, id) {
                list.addItem(value, id);
            }
            static listID_(list) {
                return list.getOptions()[list.getSelectedIndex()].value;
            }
            static listItemData_(list, index) {
            }
            static listSetListIndex_(list, idx) {
            }
            static listSetListIndexForId_(list, id) {
            }
            static listSetListIndexForText_(list, text) {
            }
            static listChangeTextForSelected_(list, value) {
            }
            static listChangeText_(list, idx, value) {
            }
            static listGetIndexFromItemData_(list, valueItemData) {
            }
            static getInput(input, description, title, inputType = 'text') {
                if (this.formInput === null)
                    this.formInput = new CSOAPI.FormInput();
                this.formInput.setDetails(description);
                this.formInput.setTitle(title);
                this.formInput.setInput(input);
                this.formInput.setInputType(inputType);
                return this.formInput.showDialog();
            }
            static getValidPath(path) {
                return "";
            }
            static inputEl(id) {
                return this.el(id);
            }
            static imageEl(id) {
                return this.el(id);
            }
            static labelEl(id) {
                return this.el(id);
            }
            static divEl(id) {
                return this.el(id);
            }
            static selectEl(id) {
                return this.el(id);
            }
            static el(id) {
                const el = document.getElementById(id);
                if (el === null || el === undefined)
                    console.log(id + ' was not found');
                return el;
            }
            static inputElc(className, node) {
                return this.elc(className, node);
            }
            static imageElc(className, node) {
                return this.elc(className, node);
            }
            static labelElc(className, node) {
                return this.elc(className, node);
            }
            static divElc(className, node) {
                return this.elc(className, node);
            }
            static selectElc(className, node) {
                return this.elc(className, node);
            }
            static elc(className, node) {
                const elements = node.querySelectorAll('.' + className);
                if (elements === null || elements === undefined) {
                    console.log(className + ' in node ' + node.toString() + ' was not found');
                    return null;
                }
                else {
                    return elements[0];
                }
            }
            static newArrayOfInts(size) {
                return Array.apply(null, { length: size }).map(() => 0);
            }
            static newArrayOfObjects(size, f) {
                return Array.apply(null, { length: size }).map(() => f.call(null));
            }
        }
        Utils.formInput = null;
        Utils._dpi = -1;
        Utils._sepDecimal = "";
        CSOAPI.Utils = Utils;
        class Maths {
            static round(num, decimals) {
                const offset = 10 * decimals;
                return Math.round((num + Number.EPSILON) * offset) / offset;
            }
        }
        Maths.trunc = Math.trunc;
        CSOAPI.Maths = Maths;
    })(CSOAPI = CSReports.CSOAPI || (CSReports.CSOAPI = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelClient;
    (function (CSKernelClient) {
        class Callable {
            static call(t, f) {
                return ((...args) => f.apply(t, [...args]));
            }
            static _(result = null) {
                return new Promise((resolve) => {
                    return resolve(result);
                });
            }
        }
        CSKernelClient.Callable = Callable;
    })(CSKernelClient = CSReports.CSKernelClient || (CSReports.CSKernelClient = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelClient;
    (function (CSKernelClient) {
        class cWindow {
            static mngError(ex, infoAdd = "") {
                return CSKernelClient.cError.mngError(ex, infoAdd);
            }
            static msgWarning(msg, title = "") {
                return CSKernelClient.cError.mngWarning(msg, title);
            }
            static getLastErrorDescription() {
                return this.lastErrorDescription;
            }
            static getLastErrorInfoAdd() {
                return this.lastErrorInfoAdd;
            }
            static setSilent(rhs) {
                this.silent = rhs;
            }
            static ask(question, defaultButton) {
                return Promise.resolve(true);
            }
            static askYesNoCancel(question, title, defaultButton) {
                return Promise.resolve(csAskEditResult.CSASKRSLTCANCEL);
            }
            static msgInfo(msg, title = "Info") {
                return CSKernelClient.cError.mngInfo(msg, title);
            }
            static clickElem(elem) {
                let eventMouse = document.createEvent("MouseEvents");
                eventMouse.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                eventMouse.raisedByCode = true;
                elem.dispatchEvent(eventMouse);
            }
        }
        cWindow.lastErrorDescription = "";
        cWindow.lastErrorInfoAdd = "";
        cWindow.silent = false;
        CSKernelClient.cWindow = cWindow;
        let MessageBoxDefaultButton;
        (function (MessageBoxDefaultButton) {
            MessageBoxDefaultButton[MessageBoxDefaultButton["Button2"] = 0] = "Button2";
            MessageBoxDefaultButton[MessageBoxDefaultButton["Button3"] = 1] = "Button3";
        })(MessageBoxDefaultButton = CSKernelClient.MessageBoxDefaultButton || (CSKernelClient.MessageBoxDefaultButton = {}));
        let csAskEditResult;
        (function (csAskEditResult) {
            csAskEditResult[csAskEditResult["CSASKRSLTYES"] = 1] = "CSASKRSLTYES";
            csAskEditResult[csAskEditResult["CSASKRSLTNO"] = 2] = "CSASKRSLTNO";
            csAskEditResult[csAskEditResult["CSASKRSLTCANCEL"] = 3] = "CSASKRSLTCANCEL";
        })(csAskEditResult = CSKernelClient.csAskEditResult || (CSKernelClient.csAskEditResult = {}));
    })(CSKernelClient = CSReports.CSKernelClient || (CSReports.CSKernelClient = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var cError = CSReports.CSKernelClient.cWindow;
        class Dialog {
            constructor(el = null, applyAndCloseButtonId, cancelButtonId) {
                this.maximize = false;
                this.selected = null;
                this.x_pos = 0;
                this.y_pos = 0;
                this.x_elem = 0;
                this.y_elem = 0;
                this.defaults = {
                    title: '',
                    width: 300,
                    height: 150,
                    top: null,
                    left: null,
                    specialClass: '',
                    fixed: true,
                    overlay: false
                };
                try {
                    this.dialog = document.createElement('div');
                    this.dialog.className = 'csreports-dialog-box';
                    this.dialogTitle = document.createElement('h3');
                    this.dialogTitle.className = 'csreports-dialog-title';
                    this.dialog.appendChild(this.dialogTitle);
                    this.dialogMinmax = document.createElement('a');
                    this.dialogMinmax.className = 'csreports-dialog-minmax';
                    this.dialogMinmax.title = 'Minimize';
                    this.dialogMinmax.innerHTML = '&ndash;';
                    this.dialogMinmax.href = 'javascript:;';
                    this.dialog.appendChild(this.dialogMinmax);
                    this.dialogClose = document.createElement('a');
                    this.dialogClose.className = 'csreports-dialog-close';
                    this.dialogClose.title = 'Close';
                    this.dialogClose.innerHTML = '&times;';
                    this.dialogClose.href = 'javascript:;';
                    this.dialog.appendChild(this.dialogClose);
                    this.dialogContent = document.createElement('div');
                    this.dialogContent.className = 'csreports-dialog-content';
                    this.dialogContent.appendChild(el);
                    this.dialog.appendChild(this.dialogContent);
                    const footer = Array.from(el.children)
                        .filter(child => child.className === 'csreports-dlg-footer')[0];
                    this.dialogAction = document.createElement('div');
                    this.dialogAction.className = 'csreports-dialog-action';
                    this.dialogAction.appendChild(footer);
                    this.dialog.appendChild(this.dialogAction);
                    this.dialogOverlay = document.createElement('div');
                    this.dialogOverlay.className = 'csreports-dialog-box-overlay';
                    document.body.appendChild(this.dialog);
                    document.body.appendChild(this.dialogOverlay);
                    this.dialogTitle.onmousedown = P.call(this, this.initDrag);
                    this.dialogClose.onclick = P.call(this, () => this.close(false));
                    if (applyAndCloseButtonId) {
                        let applyButton = U.el(applyAndCloseButtonId);
                        applyButton.onclick = P.call(this, () => this.onApplyClick());
                    }
                    if (cancelButtonId) {
                        const cancelButton = U.el(cancelButtonId);
                        cancelButton.onclick = P.call(this, () => this.close(false));
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            onApplyClick() {
                if (this.onApply) {
                    if (!this.onApply.call(null)) {
                        return;
                    }
                }
                this.close(true);
            }
            initDrag() {
                this.selected = this.dialog;
                this.x_elem = this.x_pos - this.selected.offsetLeft;
                this.y_elem = this.y_pos - this.selected.offsetTop;
                return false;
            }
            close(result) {
                this.dialog.style.visibility = 'hidden';
                this.dialog.style.opacity = '0';
                this.dialogOverlay.style.display = 'none';
                this.maximize = false;
                document.onmousemove = this.oldOnmousemove;
                document.onmouseup = this.oldOnmouseup;
                this.resolve(result);
            }
            show(settings) {
                return new Promise(P.call(this, (resolve) => {
                    this.settings = Object.assign(Object.assign({}, this.defaults), settings);
                    this.dialog.className = 'csreports-dialog-box ' + (this.settings.fixed ? 'fixed-csreports-dialog-box ' : '') + this.settings.specialClass;
                    this.dialog.style.visibility = 'visible';
                    this.dialog.style.opacity = '1';
                    this.dialog.style.width = this.settings.width + 'px';
                    this.dialog.style.height = this.settings.height + 'px';
                    let top = '50%';
                    let left = '50%';
                    if (document.onmousemove) {
                        top = '60%';
                        left = '60%';
                    }
                    this.dialog.style.top = (!this.settings.top) ? top : '0px';
                    this.dialog.style.left = (!this.settings.left) ? left : '0px';
                    this.dialog.style.marginTop = (!this.settings.top) ? '-' + this.settings.height / 2 + 'px' : this.settings.top + 'px';
                    this.dialog.style.marginLeft = (!this.settings.left) ? '-' + this.settings.width / 2 + 'px' : this.settings.left + 'px';
                    this.dialog.style.zIndex = (Dialog.zindex++).toString();
                    this.dialogTitle.textContent = this.settings.title;
                    this.dialogOverlay.style.display = (this.settings.overlay) ? 'block' : 'none';
                    this.dialogMinmax.innerHTML = '&ndash;';
                    this.dialogMinmax.title = 'Minimize';
                    this.dialogMinmax.onclick = P.call(this, this.dialogMinMax);
                    const body = U.elc('csreports-dlg-body', this.dialogContent);
                    body.style.height = (this.settings.height - 148) + 'px';
                    body.style.overflow = 'auto';
                    this.oldOnmousemove = document.onmousemove;
                    this.oldOnmouseup = document.onmouseup;
                    document.onmousemove = P.call(this, this.moveElement);
                    document.onmouseup = P.call(this, this.destroy);
                    this.maximize = true;
                    this.resolve = resolve;
                }));
            }
            moveElement(event) {
                this.x_pos = document.all ? window.event.clientX : event.pageX;
                this.y_pos = document.all ? window.event.clientY : event.pageY;
                if (this.selected !== null) {
                    this.selected.style.left = !this.settings.left !== null
                        ? ((this.x_pos - this.x_elem) + this.selected.offsetWidth / 2) + 'px'
                        : ((this.x_pos - this.x_elem) - this.settings.left) + 'px';
                    this.selected.style.top = !this.settings.top !== null
                        ? ((this.y_pos - this.y_elem) + this.selected.offsetHeight / 2) + 'px'
                        : ((this.y_pos - this.y_elem) - this.settings.top) + 'px';
                }
            }
            destroy() {
                this.selected = null;
            }
            dialogMinMax() {
                if (this.maximize) {
                    this.dialog.className += ' minimize';
                    this.dialogMinmax.innerHTML = '+';
                    this.dialogMinmax.title = this.dialogTitle.innerHTML.replace(/<.*?>/g, '');
                    this.maximize = false;
                }
                else {
                    this.dialog.className = this.dialog.className.replace(/(^| )minimize($| )/g, '');
                    this.dialogMinmax.innerHTML = '&ndash;';
                    this.dialogMinmax.title = 'Minimize';
                    this.maximize = true;
                }
            }
        }
        Dialog.zindex = 9999;
        CSForms.Dialog = Dialog;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class Form {
            setDialog(dialog) {
                this._dialog = dialog;
            }
            show(owner = null) {
            }
            showDialog() {
            }
            close(result = false) {
                this._dialog.close(result);
            }
            getVisible() {
                return false;
            }
            hide() {
            }
            bringToFront() {
            }
            isDisposed() {
                return false;
            }
        }
        CSForms.Form = Form;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelClient;
    (function (CSKernelClient) {
        var U = CSReports.CSOAPI.Utils;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        class fErrors extends Form {
            constructor(rootPath = '') {
                super();
                this.el = U.el('csreports-error-dlg');
                this.img = U.imageEl('csreports-error-dlg-icon');
                this.title = U.labelEl('csreports-error-dlg-title');
                this.infoAdd = U.labelEl('csreports-error-dlg-info-add');
                this.description = U.labelEl('csreports-error-dlg-description');
                this.dialog = new Dialog(this.el, 'csreports-error-dlg-okay');
                this.rootPath = rootPath;
                super.setDialog(this.dialog);
            }
            setErrorIcon() {
                this.img.src = this.rootPath + "images/dialogs/error.png";
            }
            setDetails(details) {
                this.description.textContent = details;
            }
            showDialog() {
                return this.showModal();
            }
            showModal() {
                return this.dialog.show({ title: this.title.textContent, height: 500, width: 800, overlay: true });
            }
            setWarnIcon() {
                this.img.src = "images/dialogs/warn.png";
            }
            setInfoIcon() {
                this.img.src = "images/dialogs/info.png";
            }
            setTitle(title) {
                this.title.textContent = title;
            }
            setInfoAdd(infoAdd) {
                this.infoAdd.textContent = infoAdd;
            }
        }
        class cError {
            constructor() {
                this.lastErrorDescription = "";
                this.lastErrorInfoAdd = "";
            }
            static mngError(ex, infoAdd = "") {
                console.log(ex);
                if (this.f === null)
                    this.f = new fErrors(this.rootPath);
                this.f.setErrorIcon();
                this.f.setDetails(ex.getMessage ? ex.getMessage() : ex.message || ex.toString());
                this.f.setInfoAdd(infoAdd);
                return this.f.showDialog().then(() => false);
            }
            static mngWarning(msg, title = "") {
                if (this.f === null)
                    this.f = new fErrors(this.rootPath);
                this.f.setWarnIcon();
                this.f.setTitle(title);
                this.f.setDetails(msg);
                return this.f.showDialog();
            }
            static mngInfo(msg, title = "") {
                if (this.f === null)
                    this.f = new fErrors(this.rootPath);
                this.f.setInfoIcon();
                this.f.setTitle(title);
                this.f.setDetails(msg);
                return this.f.showDialog();
            }
            getLastErrorDescription() {
                return this.lastErrorDescription;
            }
            getLastErrorInfoAdd() {
                return this.lastErrorInfoAdd;
            }
            static setSilent(rhs) {
                this.silent = rhs;
            }
        }
        cError.silent = false;
        cError.f = null;
        cError.rootPath = '';
        CSKernelClient.cError = cError;
    })(CSKernelClient = CSReports.CSKernelClient || (CSReports.CSKernelClient = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var U = CSReports.CSOAPI.Utils;
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        var Exception = CSReports.CSOAPI.Exception;
        var cError = CSReports.CSKernelClient.cError;
        let DatabaseEngine;
        (function (DatabaseEngine) {
            DatabaseEngine[DatabaseEngine["SQL_SERVER"] = 1] = "SQL_SERVER";
            DatabaseEngine[DatabaseEngine["POSTGRESQL"] = 2] = "POSTGRESQL";
            DatabaseEngine[DatabaseEngine["ORACLE"] = 3] = "ORACLE";
            DatabaseEngine[DatabaseEngine["CS_REPORT_WEB"] = 4] = "CS_REPORT_WEB";
        })(DatabaseEngine = CSDatabase.DatabaseEngine || (CSDatabase.DatabaseEngine = {}));
        class Database {
            constructor(databaseEngine) {
                this.ocn = null;
                this.databaseEngine = DatabaseEngine.CS_REPORT_WEB;
            }
            setSilent(silent) {
                this.silent = silent;
            }
            setCommandTimeout(commandTimeout) {
                this.commandTimeout = commandTimeout;
            }
            setConnectionTimeout(connectionTimeout) {
                this.connectionTimeout = connectionTimeout;
            }
            initDb(strConnect) {
                this.strConnect = strConnect;
                this.closeDb();
                if (this.ocn == null) {
                    this.ocn = this.createConnection();
                }
                this.ocn.setConnectionString(this.strConnect);
                this.ocn.open();
                return true;
            }
            createConnection() {
                switch (this.databaseEngine) {
                    case DatabaseEngine.CS_REPORT_WEB:
                        return new CSDatabase.JSONServerConnection();
                    case DatabaseEngine.SQL_SERVER:
                    case DatabaseEngine.POSTGRESQL:
                    case DatabaseEngine.ORACLE:
                    default:
                        throw new NotImplementedException();
                }
            }
            setOpenRsExDescript(userDescription) {
                this.userDescription = userDescription;
            }
            loadDataTable(sqlstmt, dtr, drr, showWindowCancel = true, raiseProgressEvent = false, showModal = false) {
                let cmd = this.createCommand(sqlstmt);
                const ors = cmd.executeReader();
                if (ors) {
                    drr.set(ors);
                    dtr.set(new CSDatabase.DataTable());
                    dtr.get().load(ors);
                    return true;
                }
                else {
                    drr.set(null);
                    dtr.set(null);
                    return false;
                }
            }
            createCommand(sqlstmt) {
                let ocmd = null;
                switch (this.databaseEngine) {
                    case DatabaseEngine.CS_REPORT_WEB:
                        ocmd = new CSDatabase.JSONCommand(sqlstmt, this.ocn);
                        break;
                    case DatabaseEngine.SQL_SERVER:
                    case DatabaseEngine.POSTGRESQL:
                    case DatabaseEngine.ORACLE:
                        throw new NotImplementedException();
                }
                if (ocmd == null)
                    throw new Exception("The database engine is not supported " + this.databaseEngine.toString());
                ocmd.commandTimeout = this.commandTimeout;
                ocmd.commandType = CSDatabase.CommandType.Text;
                return ocmd;
            }
            closeDb() {
                try {
                    if (this.ocn !== null) {
                        this.ocn.close();
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            static sqlString(val) {
                return "'" + val.replace(/'/g, "''") + "'";
            }
            static sqlDate(val) {
                const date = new Date(val);
                return "'" + new Intl.DateTimeFormat('ja-JP', Database.SQL_DATE_FORMAT).format(date) + "'";
            }
            static sqlNumber(number) {
                if (!U.isNumber(number)) {
                    return "0";
                }
                else {
                    let s = U.val(number).toString();
                    s = s.replaceAll(",", ".");
                    if (s.substring(s.length - 1, s.length) === ".") {
                        s = s.substring(0, s.length - 1);
                    }
                    return s;
                }
            }
            openSchema(procedureParameters, restrictions) {
                return undefined;
            }
            openRs(sqlstmt, rs) {
                return false;
            }
        }
        Database.SQL_DATE_FORMAT = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' };
        CSDatabase.Database = Database;
        class DatabaseEngineStringConnections {
            constructor() {
                this.CS_REPORT_WEB = "CSREPORT_WEB";
            }
        }
        CSDatabase.DatabaseEngineStringConnections = DatabaseEngineStringConnections;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var Exception = CSReports.CSOAPI.Exception;
        var cWindow = CSReports.CSKernelClient.cWindow;
        class DatabaseGlobals {
            constructor() {
                this.silent = false;
            }
            static isNumberField(fieldType) {
                switch (fieldType) {
                    case csAdoDataType.adDecimal:
                    case csAdoDataType.adDouble:
                    case csAdoDataType.adInteger:
                    case csAdoDataType.adCurrency:
                    case csAdoDataType.adBigInt:
                    case csAdoDataType.adNumeric:
                    case csAdoDataType.adSingle:
                    case csAdoDataType.adSmallInt:
                    case csAdoDataType.adTinyInt:
                    case csAdoDataType.adUnsignedBigInt:
                    case csAdoDataType.adUnsignedInt:
                    case csAdoDataType.adUnsignedSmallInt:
                    case csAdoDataType.adUnsignedTinyInt:
                    case csAdoDataType.adVarNumeric:
                        return true;
                }
                return false;
            }
            static getDataTypeFromString(dataType) {
                switch (dataType) {
                    case "datetime":
                    case "datetime2":
                    case "date":
                    case "timestamp with time zone":
                        return csDataType.CS_TD_DBDATE;
                    case "tinyint":
                        return csDataType.CS_TD_TINYINT;
                    case "smallint":
                        return csDataType.CS_TD_SMALLINT;
                    case "int":
                    case "int4":
                    case "integer":
                        return csDataType.CS_TD_INTEGER;
                    case "bigint":
                        return csDataType.CS_TD_BIGINT;
                    case "char":
                    case "varchar":
                    case "character varying":
                    case "text":
                    case "nchar":
                    case "nvarchar":
                    case "ntext":
                        return csDataType.CS_TD_VARCHAR;
                    case "smallmoney":
                    case "money":
                    case "decimal":
                    case "numeric":
                        return csDataType.CS_TD_DECIMAL;
                    case "real":
                    case "float":
                        return csDataType.CS_TD_DOUBLE;
                    case "bytea":
                        return csDataType.CS_TD_BINARY;
                    default:
                        cWindow.msgWarning("The data type [" + dataType + "] is not matched in CSDatabase.DatabaseGlobals.getDataTypeFromString");
                        return csDataType.CS_TD_VARCHAR;
                }
            }
            static getDataTypeFromAdo(adoDBType) {
                switch (adoDBType) {
                    case csAdoDataType.adBigInt:
                    case csAdoDataType.adUnsignedBigInt:
                        return csDataType.CS_TD_BIGINT;
                    case csAdoDataType.adBinary:
                    case csAdoDataType.adVarBinary:
                    case csAdoDataType.adLongVarBinary:
                        return csDataType.CS_TD_BINARY;
                    case csAdoDataType.adBSTR:
                    case csAdoDataType.adChapter:
                    case csAdoDataType.adVarChar:
                    case csAdoDataType.adLongVarChar:
                    case csAdoDataType.adChar:
                        return csDataType.CS_TD_VARCHAR;
                    case csAdoDataType.adCurrency:
                        return csDataType.CS_TD_CURRENCY;
                    case csAdoDataType.adDate:
                    case csAdoDataType.adDBDate:
                    case csAdoDataType.adDBTime:
                    case csAdoDataType.adDBTimeStamp:
                    case csAdoDataType.adDBFileTime:
                        return csDataType.CS_TD_DATE;
                    case csAdoDataType.adDecimal:
                    case csAdoDataType.adDouble:
                    case csAdoDataType.adNumeric:
                    case csAdoDataType.adVarNumeric:
                        return csDataType.CS_TD_DOUBLE;
                    case csAdoDataType.adInteger:
                    case csAdoDataType.adUnsignedInt:
                        return csDataType.CS_TD_INTEGER;
                    case csAdoDataType.adSingle:
                        return csDataType.CS_TD_SINGLE;
                    case csAdoDataType.adSmallInt:
                    case csAdoDataType.adUnsignedSmallInt:
                        return csDataType.CS_TD_SMALLINT;
                    case csAdoDataType.adTinyInt:
                    case csAdoDataType.adUnsignedTinyInt:
                    case csAdoDataType.adBoolean:
                        return csDataType.CS_TD_TINYINT;
                    case csAdoDataType.adVarWChar:
                    case csAdoDataType.adWChar:
                    case csAdoDataType.adLongVarWChar:
                        return csDataType.CS_TD_VARCHAR;
                    case csAdoDataType.adEmpty:
                    case csAdoDataType.adError:
                    case csAdoDataType.adFileTime:
                    case csAdoDataType.adGUID:
                    case csAdoDataType.adIDispatch:
                    case csAdoDataType.adIUnknown:
                    case csAdoDataType.adVariant:
                    case csAdoDataType.adPropVariant:
                    case csAdoDataType.adUserDefined:
                        break;
                }
                throw new Exception("This datatype is not supported [" + adoDBType.toString() + "]");
            }
            static getAdoTypeFromDataType(dataType) {
                switch (dataType) {
                    case csDataType.CS_TD_BIGINT:
                        return csAdoDataType.adBigInt;
                    case csDataType.CS_TD_BINARY:
                        return csAdoDataType.adBinary;
                    case csDataType.CS_TD_VARCHAR:
                        return csAdoDataType.adVarChar;
                    case csDataType.CS_TD_CURRENCY:
                        return csAdoDataType.adCurrency;
                    case csDataType.CS_TD_DATE:
                    case csDataType.CS_TD_DBDATE:
                        return csAdoDataType.adDate;
                    case csDataType.CS_TD_DOUBLE:
                    case csDataType.CS_TD_DECIMAL:
                        return csAdoDataType.adDouble;
                    case csDataType.CS_TD_INTEGER:
                        return csAdoDataType.adInteger;
                    case csDataType.CS_TD_SINGLE:
                        return csAdoDataType.adSingle;
                    case csDataType.CS_TD_SMALLINT:
                        return csAdoDataType.adSmallInt;
                    case csDataType.CS_TD_TINYINT:
                        return csAdoDataType.adTinyInt;
                }
                throw new Exception("This datatype is not supported [" + dataType.toString() + "]");
            }
        }
        CSDatabase.DatabaseGlobals = DatabaseGlobals;
        let csDataType;
        (function (csDataType) {
            csDataType[csDataType["CS_TD_CHAR"] = 0] = "CS_TD_CHAR";
            csDataType[csDataType["CS_TD_VARCHAR"] = 1] = "CS_TD_VARCHAR";
            csDataType[csDataType["CS_TD_LONGVARCHAR"] = 2] = "CS_TD_LONGVARCHAR";
            csDataType[csDataType["CS_TD_LONGVARWCHAR"] = 3] = "CS_TD_LONGVARWCHAR";
            csDataType[csDataType["CS_TD_WCHAR"] = 4] = "CS_TD_WCHAR";
            csDataType[csDataType["CS_TD_VARWCHAR"] = 5] = "CS_TD_VARWCHAR";
            csDataType[csDataType["CS_TD_DECIMAL"] = 6] = "CS_TD_DECIMAL";
            csDataType[csDataType["CS_TD_NUMERIC"] = 7] = "CS_TD_NUMERIC";
            csDataType[csDataType["CS_TD_DOUBLE"] = 8] = "CS_TD_DOUBLE";
            csDataType[csDataType["CS_TD_SINGLE"] = 9] = "CS_TD_SINGLE";
            csDataType[csDataType["CS_TD_CURRENCY"] = 10] = "CS_TD_CURRENCY";
            csDataType[csDataType["CS_TD_INTEGER"] = 11] = "CS_TD_INTEGER";
            csDataType[csDataType["CS_TD_BIGINT"] = 12] = "CS_TD_BIGINT";
            csDataType[csDataType["CS_TD_SMALLINT"] = 13] = "CS_TD_SMALLINT";
            csDataType[csDataType["CS_TD_TINYINT"] = 14] = "CS_TD_TINYINT";
            csDataType[csDataType["CS_TD_UNSIGNEDTINYINT"] = 15] = "CS_TD_UNSIGNEDTINYINT";
            csDataType[csDataType["CS_TD_DBTIME"] = 16] = "CS_TD_DBTIME";
            csDataType[csDataType["CS_TD_DBTIMESTAMP"] = 17] = "CS_TD_DBTIMESTAMP";
            csDataType[csDataType["CS_TD_DBDATE"] = 18] = "CS_TD_DBDATE";
            csDataType[csDataType["CS_TD_DATE"] = 19] = "CS_TD_DATE";
            csDataType[csDataType["CS_TD_BOOLEAN"] = 20] = "CS_TD_BOOLEAN";
            csDataType[csDataType["CS_TD_BINARY"] = 21] = "CS_TD_BINARY";
            csDataType[csDataType["CS_TD_LONGVARBINARY"] = 22] = "CS_TD_LONGVARBINARY";
        })(csDataType = CSDatabase.csDataType || (CSDatabase.csDataType = {}));
        let csCommandType;
        (function (csCommandType) {
            csCommandType[csCommandType["CS_CMD_FILE"] = 256] = "CS_CMD_FILE";
            csCommandType[csCommandType["CS_CMD_SP"] = 4] = "CS_CMD_SP";
            csCommandType[csCommandType["CS_CMD_TABLE"] = 2] = "CS_CMD_TABLE";
            csCommandType[csCommandType["CS_CMD_TABLEDIRECT"] = 512] = "CS_CMD_TABLEDIRECT";
            csCommandType[csCommandType["CS_CMD_TEXT"] = 1] = "CS_CMD_TEXT";
            csCommandType[csCommandType["CS_CMD_UNKNOWN"] = -1] = "CS_CMD_UNKNOWN";
        })(csCommandType = CSDatabase.csCommandType || (CSDatabase.csCommandType = {}));
        let csAdoDataType;
        (function (csAdoDataType) {
            csAdoDataType[csAdoDataType["adBigInt"] = 20] = "adBigInt";
            csAdoDataType[csAdoDataType["adBinary"] = 128] = "adBinary";
            csAdoDataType[csAdoDataType["adBoolean"] = 11] = "adBoolean";
            csAdoDataType[csAdoDataType["adBSTR"] = 8] = "adBSTR";
            csAdoDataType[csAdoDataType["adChapter"] = 136] = "adChapter";
            csAdoDataType[csAdoDataType["adChar"] = 129] = "adChar";
            csAdoDataType[csAdoDataType["adCurrency"] = 6] = "adCurrency";
            csAdoDataType[csAdoDataType["adDate"] = 7] = "adDate";
            csAdoDataType[csAdoDataType["adDBDate"] = 133] = "adDBDate";
            csAdoDataType[csAdoDataType["adDBFileTime"] = 137] = "adDBFileTime";
            csAdoDataType[csAdoDataType["adDBTime"] = 134] = "adDBTime";
            csAdoDataType[csAdoDataType["adDBTimeStamp"] = 135] = "adDBTimeStamp";
            csAdoDataType[csAdoDataType["adDecimal"] = 14] = "adDecimal";
            csAdoDataType[csAdoDataType["adDouble"] = 5] = "adDouble";
            csAdoDataType[csAdoDataType["adEmpty"] = 0] = "adEmpty";
            csAdoDataType[csAdoDataType["adError"] = 10] = "adError";
            csAdoDataType[csAdoDataType["adFileTime"] = 64] = "adFileTime";
            csAdoDataType[csAdoDataType["adGUID"] = 72] = "adGUID";
            csAdoDataType[csAdoDataType["adIDispatch"] = 9] = "adIDispatch";
            csAdoDataType[csAdoDataType["adInteger"] = 3] = "adInteger";
            csAdoDataType[csAdoDataType["adIUnknown"] = 13] = "adIUnknown";
            csAdoDataType[csAdoDataType["adLongVarBinary"] = 205] = "adLongVarBinary";
            csAdoDataType[csAdoDataType["adLongVarChar"] = 201] = "adLongVarChar";
            csAdoDataType[csAdoDataType["adLongVarWChar"] = 203] = "adLongVarWChar";
            csAdoDataType[csAdoDataType["adNumeric"] = 131] = "adNumeric";
            csAdoDataType[csAdoDataType["adPropVariant"] = 138] = "adPropVariant";
            csAdoDataType[csAdoDataType["adSingle"] = 4] = "adSingle";
            csAdoDataType[csAdoDataType["adSmallInt"] = 2] = "adSmallInt";
            csAdoDataType[csAdoDataType["adTinyInt"] = 16] = "adTinyInt";
            csAdoDataType[csAdoDataType["adUnsignedBigInt"] = 21] = "adUnsignedBigInt";
            csAdoDataType[csAdoDataType["adUnsignedInt"] = 19] = "adUnsignedInt";
            csAdoDataType[csAdoDataType["adUnsignedSmallInt"] = 18] = "adUnsignedSmallInt";
            csAdoDataType[csAdoDataType["adUnsignedTinyInt"] = 17] = "adUnsignedTinyInt";
            csAdoDataType[csAdoDataType["adUserDefined"] = 132] = "adUserDefined";
            csAdoDataType[csAdoDataType["adVarBinary"] = 204] = "adVarBinary";
            csAdoDataType[csAdoDataType["adVarChar"] = 200] = "adVarChar";
            csAdoDataType[csAdoDataType["adVariant"] = 12] = "adVariant";
            csAdoDataType[csAdoDataType["adVarNumeric"] = 139] = "adVarNumeric";
            csAdoDataType[csAdoDataType["adVarWChar"] = 202] = "adVarWChar";
            csAdoDataType[csAdoDataType["adWChar"] = 130] = "adWChar";
        })(csAdoDataType = CSDatabase.csAdoDataType || (CSDatabase.csAdoDataType = {}));
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var ArgumentException = CSReports.CSOAPI.ArgumentException;
        class JSONCommand {
            constructor(cmdText = "", connection = null) {
                this.cmdText = "";
                this.connection = null;
                this.cmdText = cmdText;
                this.connection = connection;
            }
            executeReader() {
                let cmdName = this.getCommandName();
                let data = CSDatabase.JSONServer.getDataSource(this.connection.connectionString() + "." + cmdName);
                return new CSDatabase.JSONDataReader(data);
            }
            executeDbDataReader() {
                return this.executeReader();
            }
            getCommandName() {
                let cmdText = this.cmdText;
                let startIndex = cmdText.indexOf("exec");
                if (startIndex < 0) {
                    throw new ArgumentException("The command text for this command object is invalid. Format must be 'exec [SP_NAME] param list");
                }
                startIndex += 5;
                cmdText = cmdText.substring(startIndex);
                let length = cmdText.indexOf(" ", 1);
                return cmdText.substring(0, length).replaceAll("[", "").replaceAll("]", "");
            }
        }
        CSDatabase.JSONCommand = JSONCommand;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var ArgumentException = CSReports.CSOAPI.ArgumentException;
        var ArgumentNullException = CSReports.CSOAPI.ArgumentNullException;
        var InvalidOperationException = CSReports.CSOAPI.InvalidOperationException;
        class JSONDataReader {
            constructor(dataSource) {
                this.dataSource = null;
                this.cols = [];
                this.rows = [];
                this.resultIndex = 0;
                this.rowIndex = -1;
                this.closed = false;
                this.start = new Date(1970, 1, 1, 0, 0, 0);
                this.dataSource = dataSource;
                this.cols = this.dataSource.getData()["columns"];
                this.rows = this.dataSource.getData()["rows"];
            }
            fieldCount() {
                return this.dataSource.getData()["columns"].length;
            }
            hasRows() {
                return this.dataSource.getData()["rows"].length > 0;
            }
            isClosed() {
                return this.closed;
            }
            close() {
                this.closed = true;
            }
            getName(i) {
                return this.cols[i]["name"].toString();
            }
            getType(typeName, columnName) {
                let type;
                switch (typeName.toLowerCase()) {
                    case "integer":
                    case "int2":
                    case "int4":
                    case "smallint":
                    case "biginteger":
                    case "serial":
                    case "bigserial":
                    case "decimal":
                    case "numeric":
                    case "float8":
                    case "float4":
                    case "real":
                        type = CSDatabase.DataType.dbNumber;
                        break;
                    case "timestamp":
                    case "timestamptz":
                    case "date":
                    case "time":
                        type = CSDatabase.DataType.dbDate;
                        break;
                    case "character":
                    case "char":
                    case "varchar":
                    case "text":
                    case "character varying":
                        type = CSDatabase.DataType.dbText;
                        break;
                    case "bytea":
                        type = CSDatabase.DataType.dbImage;
                        break;
                    default:
                        throw new ArgumentException("The data type for column " + columnName + " of data source " + this.dataSource.getName() + " is not supported");
                }
                return type;
            }
            getColumnType(i) {
                return this.getType(this.cols[i]["columnType"].toString(), this.getName(i));
            }
            getString(i) {
                return this.getValue(i).toString();
            }
            isByteA(i) {
                return this.cols[i]["columnType"].toString() === "bytea";
            }
            isTimestamptz(i) {
                return this.cols[i]["columnType"].toString() === "timestamptz";
            }
            getValue(i) {
                let value = this.rows[this.rowIndex]["values"][i];
                if (this.isTimestamptz(i)) {
                    if (value.toString().trim().length === 0) {
                        value = this.start;
                    }
                    else {
                        value = new Date(value).toString();
                    }
                }
                return value;
            }
            getValues(values) {
                if (values === null) {
                    throw new ArgumentNullException("values");
                }
                this.checkRow();
                let count = values.length === 0 ? this.fieldCount() : Math.min(this.fieldCount(), values.length);
                for (let i = 0; i < count; i++) {
                    values.push(this.getValue(i));
                }
                return count;
            }
            nextResult() {
                this.resultIndex += 1;
                return this.resultIndex < 1;
            }
            read() {
                this.rowIndex += 1;
                return this.rowIndex < this.rows.length;
            }
            isOnRow() {
                return -1 < this.rowIndex && this.rowIndex < this.rows.length;
            }
            checkRow() {
                if (!this.isOnRow()) {
                    throw new InvalidOperationException("No row is available");
                }
            }
        }
        CSDatabase.JSONDataReader = JSONDataReader;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        class JSONDataSource {
            constructor(name, data) {
                this.name = null;
                this.data = null;
                this.name = name;
                this.data = data;
            }
            getName() {
                return this.name;
            }
            getData() {
                return this.data;
            }
        }
        CSDatabase.JSONDataSource = JSONDataSource;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var Map = CSReports.CSOAPI.Map;
        class JSONDataSources extends Map {
        }
        CSDatabase.JSONDataSources = JSONDataSources;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        class JSONServer {
            static registerDataSource(dataSource, name) {
                this.dataSources.add(dataSource, name.toLowerCase());
            }
            static getDataSource(name) {
                return this.dataSources.item(name.toLowerCase());
            }
        }
        JSONServer.dataSources = new CSDatabase.JSONDataSources();
        CSDatabase.JSONServer = JSONServer;
        class JSONServerConnection {
            constructor(connectionString = "") {
                this._connectionString = connectionString;
            }
            connectionString() {
                return this._connectionString;
            }
            setConnectionString(strConnect) {
                this._connectionString = strConnect;
            }
            open() { }
            close() { }
        }
        CSDatabase.JSONServerConnection = JSONServerConnection;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        class OpenRsCommand {
        }
        CSDatabase.OpenRsCommand = OpenRsCommand;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        let CommandType;
        (function (CommandType) {
            CommandType[CommandType["Text"] = 1] = "Text";
            CommandType[CommandType["StoredProcedure"] = 4] = "StoredProcedure";
            CommandType[CommandType["TableDirect"] = 512] = "TableDirect";
        })(CommandType = CSDatabase.CommandType || (CSDatabase.CommandType = {}));
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        class Param {
        }
        CSDatabase.Param = Param;
        class Column {
        }
        class Row {
        }
        class DataSet {
        }
        class Query {
        }
        class ServerDataSource {
        }
        CSDatabase.ServerDataSource = ServerDataSource;
        class DataSource {
            constructor(name, params, url) {
                this.name = name;
                this.code = name;
                this.params = params;
                this.url = url;
            }
            getId() {
                return this.name + "." + this.getParamsInfo();
            }
            getParamsInfo() {
                return this.params.map(p => p.name + " " + p.type).join(", ");
            }
            getStringConnection() {
                return this.name;
            }
            static load(url, dataSource) {
                return new DataSource(dataSource.name, dataSource.params, url);
            }
            static fromArray(dataSources, url) {
                return dataSources.map(d => this.load(url, d));
            }
        }
        CSDatabase.DataSource = DataSource;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var cError = CSReports.CSKernelClient.cError;
        class Control {
            constructor(el = null) {
                this.cursor = CSForms.Cursor.Default;
                this.width = 0;
                this.height = 0;
                this.top = 0;
                this.left = 0;
                this.el = el;
            }
            getElement() {
                return this.el;
            }
            getCursor() {
                return this.cursor;
            }
            setCursor(value) {
                this.cursor = value;
            }
            getWidth() {
                return this.width;
            }
            setWidth(value) {
                this.width = value;
            }
            getHeight() {
                return this.height;
            }
            setHeight(value) {
                this.height = value;
            }
            getTop() {
                return this.top;
            }
            setTop(value) {
                this.top = value;
            }
            getLeft() {
                return this.left;
            }
            setLeft(value) {
                this.left = value;
            }
            focus() {
            }
            setEnabled(enabled) {
                if (this.el.disabled !== undefined) {
                    this.el.disabled = !enabled;
                }
            }
            dispose() {
                if (this.el) {
                    try {
                        this.el.parentNode.removeChild(this.el);
                    }
                    catch (ex) {
                        cError.mngError(ex);
                    }
                }
            }
            disable() {
                this.setEnabled(false);
            }
            setOnClick(f) {
                this.el.onclick = f;
            }
            setOnChange(f) {
                this.el.onchange = f;
            }
            setOnKeyDown(f) {
                this.el.onkeydown = f;
            }
            setLostFocus(f) {
                this.el.blur = f;
            }
            setChange(f) {
                this.el.onchange = f;
            }
            isVisible() {
                const style = window.getComputedStyle(this.el);
                return (style.display !== 'none');
            }
        }
        CSForms.Control = Control;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var P = CSReports.CSKernelClient.Callable;
        class ListState {
        }
        CSForms.ListState = ListState;
        class Items {
            constructor() {
                this._items = [];
            }
            add(text, imageIndex = 0) {
                const tr = document.createElement('tr');
                let item = new Item(tr, this.state);
                item.setText(text);
                item.setImageIndex(imageIndex);
                this._items.push(item);
                this.body.appendChild(tr);
                return item;
            }
            addItem(item) {
                this._items.push(item);
            }
            clear() {
                this._items = [];
            }
            getItems() {
                return this._items;
            }
            setBody(body) {
                this.body = body;
            }
        }
        class Item {
            constructor(tr, state) {
                this.state = state;
                this.subItems = new SubItems(this);
                this.subItems.state = state;
                this.tr = tr;
                const td = document.createElement('td');
                this.td = td;
                this.td.onclick = P.call(this, this.onclick);
                this.td.style.cursor = "pointer";
                this.tr.appendChild(td);
                this.subItems.setTr(tr);
            }
            onclick() {
                this.setItemSelected();
                if (this.state.onclick) {
                    this.state.onclick(this);
                }
            }
            setItemSelected() {
                var _a, _b;
                this.state.selectedItems.clear();
                this.state.selectedItems.addItem(this);
                this.tr.style.backgroundColor = "lightgreen";
                if ((_b = (_a = this.state.activeItem) === null || _a === void 0 ? void 0 : _a.subItems) === null || _b === void 0 ? void 0 : _b.getTr()) {
                    this.state.activeItem.subItems.getTr().style.backgroundColor = '';
                }
                this.state.activeItem = this;
            }
            setItemUnSelected() {
                this.state.selectedItems.clear();
                this.tr.style.backgroundColor = '';
                this.state.activeItem = null;
            }
            setText(text) {
                this.text = text;
                this.td.textContent = text;
            }
            getText() {
                return this.text;
            }
            setForeColor(color) {
                this.foreColor = color;
            }
            setImageIndex(imageIndex) {
                this.imageIndex = imageIndex;
            }
            setFocused(_) {
            }
            setSelected(value) {
                if (value)
                    this.setItemSelected();
                else
                    this.setItemUnSelected();
            }
            remove(body) {
                if (this.tr) {
                    body.removeChild(this.tr);
                }
            }
        }
        CSForms.Item = Item;
        class SubItems {
            constructor(item) {
                this._subItems = [];
                this._item = item;
            }
            item(index) {
                return this._subItems[index - 1];
            }
            add(text) {
                const td = document.createElement('td');
                td.textContent = text;
                td.onclick = P.call(this, this.onclick);
                td.style.cursor = "pointer";
                this.tr.appendChild(td);
                let subItem = new SubItem(td);
                subItem.setText(text);
                this._subItems.push(subItem);
                return subItem;
            }
            onclick() {
                this.state.activeItem = this._item;
                this.setItemSelected();
                if (this.state.onclick) {
                    this.state.onclick(this._item);
                }
            }
            setItemSelected() {
                var _a, _b;
                this.state.selectedItems.clear();
                this.state.selectedItems.addItem(this._item);
                this.tr.style.backgroundColor = "lightgreen";
                if ((_b = (_a = this.state.activeItem) === null || _a === void 0 ? void 0 : _a.subItems) === null || _b === void 0 ? void 0 : _b.getTr()) {
                    this.state.activeItem.subItems.getTr().style.backgroundColor = '';
                }
                this.state.activeItem = this._item;
            }
            getItems() {
                return this._subItems;
            }
            setTr(tr) {
                this.tr = tr;
            }
            getTr() {
                return this.tr;
            }
        }
        class SubItem {
            constructor(td) {
                this.td = td;
            }
            getText() {
                return this.text;
            }
            setText(text) {
                this.text = text;
                this.td.textContent = text;
            }
            setForeColor(color) {
                this.foreColor = color;
            }
        }
        class ListView extends CSForms.Control {
            constructor(name, el) {
                super(el);
                this._items = new Items();
                this._selectedItems = new Items();
                this.state = new ListState();
                this.name = name;
                this.div = el;
                this.table = document.createElement('table');
                this.table.className = "fl-table";
                this.div.appendChild(this.table);
                this.table.createTHead();
                this._items.state = this.state;
                this._items.setBody(this.table.createTBody());
                this.state.selectedItems = this._selectedItems;
            }
            clear() {
                this._items.clear();
                if (this.table.tBodies.length > 0) {
                    const body = this.table.tBodies[0];
                    while (body.firstChild) {
                        body.removeChild(body.firstChild);
                    }
                }
            }
            getItems() {
                return this._items.getItems();
            }
            selectedItems() {
                return this._selectedItems.getItems();
            }
            add(text, imageIndex) {
                return this._items.add(text, imageIndex);
            }
            remove(index) {
                this._items.getItems()[index].remove(this.table.tBodies[0]);
            }
            sort() {
            }
            getMaxSubitemsSize() {
                let maxCols = 0;
                for (let i = 0; i < this._items.getItems().length; i++) {
                    let size = this._items.getItems()[i].subItems.getItems().length;
                    if (size > maxCols)
                        maxCols = size;
                }
                return maxCols;
            }
            createHeaders(columns) {
                while (this.table.tHead.firstChild) {
                    this.table.tHead.removeChild(this.table.tHead.firstChild);
                }
                for (let i = 0; i < columns.length; i++) {
                    const thead = document.createElement('th');
                    thead.textContent = columns[i];
                    this.table.tHead.appendChild(thead);
                }
            }
            select() {
            }
        }
        CSForms.ListView = ListView;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var ListView = CSReports.CSForms.ListView;
        class FormDataSources extends Form {
            constructor() {
                super();
                this.dataSource = null;
                this.el = U.el('datasource-dlg');
                this.dialog = new Dialog(this.el, 'datasource-dlg-apply', 'datasource-dlg-cancel');
                this.lvDataSources = new ListView("lvColumns", U.el("datasource-lv-datasources"));
                this.lvDataSources.state.onclick = P.call(this, this.lvColumnsClick);
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                super.setDialog(this.dialog);
            }
            initDialog() {
            }
            cmdApplyClick() {
                return true;
            }
            clearColumns() {
                this.lvDataSources.clear();
            }
            setDataSource(dataSource) {
                this.dataSource = dataSource;
                for (let i = 0; i < this.lvDataSources.getItems().length; i++) {
                    const item = this.lvDataSources.getItems()[i];
                    if (item.tag.getId() === dataSource.getId()) {
                        item.setSelected(true);
                        item.setFocused(true);
                        this.lvDataSources.select();
                        break;
                    }
                }
            }
            getDataSource() {
                return this.dataSource;
            }
            lvColumnsClick() {
                if (this.lvDataSources.selectedItems().length > 0) {
                    let item = this.lvDataSources.selectedItems()[0];
                    this.dataSource = item.tag;
                }
            }
            showModal(dataSources) {
                this.lvDataSources.clear();
                for (let i = 0; i < dataSources.length; i++) {
                    const item = this.lvDataSources.add(dataSources[i].name);
                    item.subItems.add(dataSources[i].getParamsInfo());
                    item.tag = dataSources[i];
                }
                return this.dialog.show({ title: 'Data Sources', height: 600, width: 500, overlay: true })
                    .then(P.call(this, (result) => {
                    if (result)
                        return {
                            success: true,
                            dataSource: this.dataSource
                        };
                    else
                        return {
                            success: false,
                            dataSource: null
                        };
                }));
            }
        }
        CSDatabase.FormDataSources = FormDataSources;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class TextBox extends CSForms.Control {
            constructor(el = null) {
                super(el);
                this.elInput = el;
            }
            setText(text) {
                this.elInput.value = text;
            }
            getSelectionStart() {
                return this.elInput.selectionStart;
            }
            getText() {
                return this.elInput.value;
            }
        }
        CSForms.TextBox = TextBox;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var TextBox = CSReports.CSForms.TextBox;
        class FormSettings extends Form {
            constructor() {
                super();
                this.el = U.el('server-settings-dlg');
                this.dialog = new Dialog(this.el, 'server-settings-dlg-apply', 'server-settings-dlg-cancel');
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                super.setDialog(this.dialog);
                this.txURL = new TextBox(U.inputEl("server-url"));
                this.txApiKey = new TextBox(U.inputEl("server-api-key"));
            }
            initDialog() {
            }
            cmdApplyClick() {
                return true;
            }
            showModal() {
                return this.dialog.show({ title: 'Connection Settings', height: 600, width: 500, overlay: true })
                    .then(P.call(this, (result) => {
                    if (result)
                        return {
                            success: true,
                            url: this.txURL.getText(),
                            apiKey: this.txApiKey.getText(),
                        };
                    else
                        return {
                            success: false
                        };
                }));
            }
        }
        CSDatabase.FormSettings = FormSettings;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        class LocalServer {
            getServerUrl() {
                return "local";
            }
            listDataSources() {
                throw new Error("Method not implemented.");
            }
            execute(ds) {
                throw new Error("Method not implemented.");
            }
        }
        CSDatabase.LocalServer = LocalServer;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        class RemoteServer {
            constructor(serverUrl, apiKey) {
                this.serverUrl = serverUrl;
                this.apiKey = apiKey;
            }
            getServerUrl() {
                return this.serverUrl;
            }
            listDataSources() {
                return this.callApi(this.serverUrl + '/data-sources', (data) => data);
            }
            execute(ds) {
                return this.callApi(this.serverUrl + '/data-sources/' + ds.code + '?' + this.queryParam(ds.params), (data) => data);
            }
            queryParam(params) {
                let queryString = "";
                for (let i = 0; i < params.length; i++) {
                    queryString += encodeURIComponent(params[i].name) + '=' + encodeURIComponent(params[i].value) + '&';
                }
                return queryString;
            }
            callApi(url, f) {
                return this.getHeaders().then(P.call(this, (headers) => {
                    return fetch(url, { method: 'GET', headers: headers }).then((response) => {
                        if (response.ok) {
                            return response.json();
                        }
                        else {
                            debugger;
                            return Promise.reject(response);
                        }
                    })
                        .then(f)
                        .catch(ex => {
                        return CSReports.CSKernelClient.cError.mngError(ex, "url: " + url);
                    });
                }));
            }
            getHeaders() {
                if (this.secret && this.secret !== "") {
                    const headers = { 'api-key': this.apiKey, 'secret': this.secret, "Content-Type": "application/json" };
                    return P._(headers);
                }
                else {
                    return U.getInput("", "Input the password to connect to " + this.getServerUrl(), "API Secret", "password").then(P.call(this, (result) => {
                        if (result.success) {
                            this.secret = result.value;
                            return { 'api-key': this.apiKey, 'secret': this.secret };
                        }
                    }));
                }
            }
        }
        CSDatabase.RemoteServer = RemoteServer;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDatabase;
    (function (CSDatabase) {
        var P = CSReports.CSKernelClient.Callable;
        const K_SERVER_URL = "SERVER_URL";
        const K_API_KEY = "API_KEY";
        class ServerConnection {
            constructor() {
                this.server = null;
                this.formDataSources = new CSDatabase.FormDataSources();
                this.formSettings = new CSDatabase.FormSettings();
            }
            getServerUrl() {
                return localStorage.getItem(K_SERVER_URL) || "";
            }
            getApiKey() {
                return localStorage.getItem(K_API_KEY) || "";
            }
            selectDataSource() {
                return this.getServer().listDataSources().then(P.call(this, (dataSources) => {
                    return this.formDataSources.showModal(CSDatabase.DataSource.fromArray(dataSources, this.getServerUrl()));
                }));
            }
            getDataSourceInfo(dataSource) {
                return this.getServer().listDataSources().then(P.call(this, (dataSources) => {
                    return CSDatabase.DataSource.fromArray(dataSources, this.getServerUrl()).find(d => d.name === dataSource);
                }));
            }
            excute(dataSource, params) {
                const ds = new CSDatabase.DataSource(dataSource, params, this.getServerUrl());
                return this.getServer().execute(ds);
            }
            getServer() {
                const serverUrl = this.getServerUrl();
                if (this.server === null || this.server.getServerUrl() !== serverUrl) {
                    if (serverUrl === 'local') {
                        this.server = new CSDatabase.LocalServer();
                    }
                    else {
                        this.server = new CSDatabase.RemoteServer(serverUrl, this.getApiKey());
                    }
                }
                return this.server;
            }
            editSettings() {
                return this.formSettings.showModal().then(P.call(this, (result) => {
                    if (result.success) {
                        localStorage.setItem(K_SERVER_URL, result.url);
                        localStorage.setItem(K_API_KEY, result.apiKey);
                    }
                    ;
                }));
            }
        }
        CSDatabase.ServerConnection = ServerConnection;
    })(CSDatabase = CSReports.CSDatabase || (CSReports.CSDatabase = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDrawing;
    (function (CSDrawing) {
        var cError = CSReports.CSKernelClient.cError;
        var P = CSReports.CSKernelClient.Callable;
        var U = CSReports.CSOAPI.Utils;
        class Bitmap {
            constructor(width, height, name) {
                this.name = name;
                this.p = new Promise((resolve) => {
                    if (width > 0 && height > 0) {
                        const canvas = document.createElement("canvas");
                        const ctx = canvas.getContext("2d");
                        const imgData = ctx.createImageData(width, height);
                        createImageBitmap(imgData).then(b => {
                            this.imageBitmap = b;
                            this.imageBitmap.name = this.name;
                            resolve();
                        });
                    }
                    else {
                        this.imageBitmap = null;
                        resolve();
                    }
                });
            }
            static fromContext2d(ctx, name) {
                const bitmap = new Bitmap(0, 0, name);
                bitmap.p = new Promise((resolve) => {
                    createImageBitmap(ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)).then(b => {
                        bitmap.imageBitmap = b;
                        bitmap.imageBitmap.name = name;
                        resolve();
                    });
                });
                return bitmap;
            }
            static fromImage(image, name) {
                const bitmap = new Bitmap(0, 0, name);
                bitmap.p = new Promise((resolve) => {
                    createImageBitmap(image.imageBitmap).then(b => {
                        bitmap.imageBitmap = b;
                        bitmap.imageBitmap.name = name;
                        resolve();
                    });
                });
                return bitmap;
            }
            static loadImageFromArray(imageData) {
                const bitmap = new Bitmap(0, 0, '');
                bitmap.imageData = imageData;
                return bitmap;
            }
            static loadImageFromImageBitmap(imageBitmap) {
                const bitmap = new Bitmap(0, 0, '');
                bitmap.imageBitmap = imageBitmap;
                return bitmap;
            }
            loadImage() {
                const self = this;
                const img = new Image();
                return new Promise((resolve) => {
                    img.onload = () => {
                        const canvas = document.createElement("canvas");
                        const ctx = canvas.getContext("2d");
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        createImageBitmap(ctx.getImageData(0, 0, img.width, img.height))
                            .then(imageBitmap => {
                            self.imageBitmap = imageBitmap;
                            self.imageBitmap.name = name;
                            resolve(imageBitmap);
                        });
                    };
                    if (typeof self.imageData === 'object') {
                        if (self.imageData.image !== undefined) {
                            img.src = "data:image/jpeg;base64," + self.imageData.image;
                        }
                        else {
                            try {
                                var canvas2 = document.createElement('canvas');
                                var ctx2 = canvas2.getContext('2d');
                                canvas2.width = self.imageData.width;
                                canvas2.height = self.imageData.height;
                                ctx2.putImageData(self.imageData, 0, 0);
                                img.src = canvas2.toDataURL();
                            }
                            catch (ex) {
                                console.log(ex);
                            }
                        }
                    }
                    else {
                        img.src = "data:image/jpeg;base64," + self.imageData;
                    }
                });
            }
            getBitmap() {
                return this.p.then(() => this.imageBitmap);
            }
            whenLoaded() {
                return this.p;
            }
            getSize() {
                return { height: this.imageBitmap.height, width: this.imageBitmap.width };
            }
            getImageData() {
                return this.imageData;
            }
            setImageData(value) {
                this.imageData = value;
            }
            dispose() {
            }
        }
        CSDrawing.Bitmap = Bitmap;
        class ImageX {
            constructor(bitmap, key = null, width = 0, height = 0) {
                this._bitmap = null;
                this._imageBitmap = null;
                this._size = new SizeF(0, 0);
                this._bitmap = bitmap;
                this._key = key;
                if (width > 0 && height > 0) {
                    this._size = new SizeF(width, height);
                }
            }
            get bitmap() {
                return this._bitmap;
            }
            get imageBitmap() {
                return this._imageBitmap;
            }
            get key() {
                return this._key;
            }
            removeImageBitmap() {
                this._bitmap = null;
                this._imageBitmap = null;
            }
            getSize() {
                return this._size;
            }
            getBitmapSize(inTwips) {
                return {
                    bmpWidth: this._bitmap.getSize().width,
                    bmpHeight: this._bitmap.getSize().height
                };
            }
            loadImage() {
                return this._bitmap.loadImage()
                    .then(P.call(this, this.setImageBitmap));
            }
            setImageBitmap(imageBitmap) {
                this._imageBitmap = imageBitmap;
                if (this._imageBitmap !== null || this._imageBitmap !== undefined) {
                    this._size = new SizeF(this._imageBitmap.width, this._imageBitmap.height);
                }
            }
            dispose() {
            }
        }
        CSDrawing.ImageX = ImageX;
        class OffscreenGraphic {
            constructor(canvas, name) {
                this.name = name;
                this.canvas = canvas;
                this.context = canvas.getContext("2d");
                this.canvas.name = name;
            }
            static createOffscreenGraphic(name, width = 1, height = 1) {
                const canvas = new OffscreenCanvas(width, height);
                canvas.name = name;
                return new OffscreenGraphic(canvas, name);
            }
            measureString(text, font, width = -1, format) {
                let size;
                this.context.save();
                this.context.font = font.toStringFont();
                if (format && format.formatFlags === StringFormatFlags.Wrap) {
                    size = this.measureWrappedString(text, width);
                }
                else {
                    const m = this.context.measureText(text);
                    size = new SizeF(Math.floor(m.width), Math.floor(m.fontBoundingBoxAscent + m.fontBoundingBoxDescent));
                }
                this.context.restore();
                return size;
            }
            measureWrappedString(text, maxWidth) {
                let words = text.split(' ');
                let line = '';
                let width = 0;
                let wrapped = false;
                const lineHeight = this.lineHeight();
                let y = lineHeight;
                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    let metrics = this.context.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        line = words[n] + ' ';
                        y += lineHeight;
                        wrapped = true;
                    }
                    else {
                        line = testLine;
                        width = testWidth;
                    }
                }
                if (wrapped)
                    width = maxWidth;
                return new SizeF(Math.floor(width), Math.floor(y));
            }
            lineHeight() {
                const m = this.context.measureText("ABCDEFGHYJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@\"\\/#$%^*()_+=?><");
                return Math.floor(m.fontBoundingBoxAscent + m.fontBoundingBoxDescent);
            }
        }
        CSDrawing.OffscreenGraphic = OffscreenGraphic;
        class Graphic {
            constructor(canvas, name) {
                this.name = name;
                this.canvas = canvas;
                this.context = canvas.getContext("2d");
                this.canvas.name = name;
            }
            getBoundingClientRect() {
                return this.canvas.getBoundingClientRect();
            }
            setFillStyle(style) {
                this.context.fillStyle = style;
            }
            ;
            fillRect(x, y, width, height) {
                this.context.fillRect(x, y, width, height);
            }
            dispose() {
            }
            drawImage(bitmap, x, y) {
                this.context.clearRect(x, y, bitmap.width, bitmap.height);
                this.context.drawImage(bitmap, x, y);
            }
            drawImage2(bitmap, x, y, width, height) {
                this.context.clearRect(x, y, width, height);
                this.context.drawImage(bitmap, x, y, width, height);
            }
            getContext() {
                return this.context;
            }
            static fromImage(bitmap) {
                const canvas = document.createElement('canvas');
                canvas.name = name;
                const ctx = canvas.getContext('2d');
                return bitmap.getBitmap().then(bmp => {
                    ctx.canvas.width = bmp.width;
                    ctx.canvas.height = bmp.height;
                    ctx.drawImage(bmp, 0, 0);
                    return new Graphic(canvas, bitmap.name);
                });
            }
            static createGraphic(name, width, height) {
                const canvas = document.createElement('canvas');
                canvas.name = name;
                const ctx = canvas.getContext('2d');
                if (width)
                    ctx.canvas.width = width;
                if (height)
                    ctx.canvas.height = height;
                return new Graphic(canvas, name);
            }
            fillPath(brush, path) {
                this.context.fill(path);
            }
            drawPath(pen, path) {
                try {
                }
                catch (ex) {
                    cError.mngError(ex);
                    throw ex;
                }
            }
            fillRectangle(brush, rect) {
                this.context.save();
                this.context.fillStyle = brush.toString();
                this.context.fillRect(rect.getLeft(), rect.getTop(), rect.getWidth(), rect.getHeight());
                this.context.restore();
            }
            drawRectangle(pen, rect) {
                this.drawRectangle4(pen, rect.getLeft(), rect.getTop(), rect.getWidth(), rect.getHeight());
            }
            drawRectangle4(pen, x, y, w, h) {
                this.context.save();
                if (pen.dashStyle === DashStyle.Dot)
                    this.context.setLineDash([3, 2]);
                this.context.lineWidth = pen.width();
                this.context.strokeStyle = pen.color();
                this.context.strokeRect(x, y, w, h);
                this.context.restore();
            }
            drawString(text, font, brush, rect, format) {
                this.context.save();
                this.context.fillStyle = brush.foreground.color;
                this.context.font = font.toStringFont();
                if (format && format.formatFlags === StringFormatFlags.Wrap) {
                    this.drawWrappedString(text, rect.getLeft(), rect.getBottom(), rect.getWidth());
                }
                else {
                    this.drawStringIntoRect(text, rect);
                }
                this.context.restore();
            }
            drawStringIntoRect(text, rect) {
                this.context.beginPath();
                this.context.fillText(text, rect.getLeft(), rect.getTop() + rect.getHeight());
                this.context.closePath();
            }
            drawWrappedString(text, x, y, maxWidth) {
                let words = text.split(' ');
                let line = '';
                const lineHeight = this.lineHeight();
                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    let metrics = this.context.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        this.context.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    }
                    else {
                        line = testLine;
                    }
                }
                this.context.fillText(line, x, y);
            }
            lineHeight() {
                const m = this.context.measureText("ABCDEFGHYJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@\"\\/#$%^*()_+=?><");
                return Math.floor(m.fontBoundingBoxAscent + m.fontBoundingBoxDescent);
            }
            measureWrappedString(text, maxWidth) {
                let words = text.split(' ');
                let line = '';
                let width = 0;
                let wrapped = false;
                const lineHeight = this.lineHeight();
                let y = lineHeight;
                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    let metrics = this.context.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        line = words[n] + ' ';
                        y += lineHeight;
                        wrapped = true;
                    }
                    else {
                        line = testLine;
                        width = testWidth;
                    }
                }
                if (wrapped)
                    width = maxWidth;
                return new SizeF(Math.floor(width), Math.floor(y));
            }
            fillEllipse(brush, rect) {
            }
            measureString(text, font, width = -1, format) {
                let size;
                this.context.save();
                this.context.font = font.toStringFont();
                if (format && format.formatFlags === StringFormatFlags.Wrap) {
                    size = this.measureWrappedString(text, width);
                }
                else {
                    const m = this.context.measureText(text);
                    size = new SizeF(Math.floor(m.width), this.calcFontHeight(m));
                }
                this.context.restore();
                return size;
            }
            calcFontHeight(m) {
                if (m.fontBoundingBoxAscent !== undefined) {
                    return Math.floor(m.fontBoundingBoxAscent + m.fontBoundingBoxDescent);
                }
                else {
                    return Math.floor(m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + 3);
                }
            }
            getHeight() {
                return this.canvas.height;
            }
            getWidth() {
                return this.canvas.width;
            }
            scale(x, y) {
                this.context.scale(x, y);
            }
        }
        CSDrawing.Graphic = Graphic;
        class Location {
            constructor(left, top) {
                this.left = left;
                this.top = top;
            }
        }
        CSDrawing.Location = Location;
        class RectangleF {
            constructor() {
                this.left = 0;
                this.top = 0;
                this.right = 0;
                this.bottom = 0;
                this.height = 0;
                this.width = 0;
            }
            getHeight() {
                if (isNaN(this.height)) {
                    console.log("in Bitmap.getHeight this.height was NaN");
                    this.setHeight(this.bottom - this.top);
                }
                return this.height;
            }
            getWidth() {
                if (isNaN(this.width)) {
                    console.log("in Bitmap.getWidth this.width was NaN");
                    this.setWidth(this.right - this.left);
                }
                return this.width;
            }
            setHeight(h) {
                if (isNaN(h)) {
                    console.log("in Bitmap.setHeight h was NaN");
                }
                this.height = h;
            }
            setWidth(w) {
                if (isNaN(w)) {
                    debugger;
                }
                this.width = w;
            }
            setX(x) {
                this.left = x;
                this.setWidth(this.right - x);
            }
            setY(y) {
                this.top = y;
                this.setHeight(this.bottom - y);
            }
            static new4(left, top, right, bottom) {
                const r = new RectangleF();
                r.setTop(top);
                r.setLeft(left);
                r.setRight(right);
                r.setBottom(bottom);
                r.setHeight(bottom - top);
                r.setWidth(right - left);
                return r;
            }
            setTop(top) {
                this.top = top;
                this.setHeight(this.bottom - top);
            }
            setBottom(bottom) {
                this.bottom = bottom;
                this.setHeight(bottom - this.top);
            }
            setLeft(left) {
                this.left = left;
                this.setWidth(this.right - left);
            }
            setRight(right) {
                this.right = right;
                this.setWidth(right - this.left);
            }
            getTop() {
                return this.top;
            }
            getBottom() {
                return this.bottom;
            }
            getLeft() {
                return this.left;
            }
            getRight() {
                return this.right;
            }
            static new2(location, sizeF) {
                const r = new RectangleF();
                r.setLeft(location.left);
                r.setTop(location.top);
                r.setRight(location.left + sizeF.width);
                r.setBottom(location.top + sizeF.height);
                r.setHeight(sizeF.height);
                r.setWidth(sizeF.width);
                return r;
            }
            getLocation() {
                return new Location(this.left, this.top);
            }
            toString() {
                return "x0: " + this.getLeft()
                    + "\n y0: " + this.getTop()
                    + "\n x1: " + this.getWidth()
                    + "\n y1: " + this.getBottom();
            }
        }
        CSDrawing.RectangleF = RectangleF;
        class Rectangle extends RectangleF {
        }
        CSDrawing.Rectangle = Rectangle;
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }
        CSDrawing.Point = Point;
        let DashStyle;
        (function (DashStyle) {
            DashStyle[DashStyle["Dot"] = 1] = "Dot";
        })(DashStyle = CSDrawing.DashStyle || (CSDrawing.DashStyle = {}));
        class Pen {
            constructor(color, width) {
                this._color = color;
                this._width = width;
            }
            dispose() {
            }
            color() {
                if (U.isNumber(this._color)) {
                    const numColor = U.valInt(this._color);
                    return (numColor < 0 ? 0 : numColor).toString();
                }
                return this._color;
            }
            width() {
                return this._width;
            }
        }
        CSDrawing.Pen = Pen;
        class Brush {
            dispose() {
            }
            ;
            toString() { return csColors.WHITE; }
            ;
        }
        CSDrawing.Brush = Brush;
        class SolidBrush extends Brush {
            constructor(foreground) {
                super();
                this._foreground = new Color(Color.colorFromNumber(foreground));
            }
            get foreground() {
                return this._foreground;
            }
            toString() {
                return this._foreground.color;
            }
        }
        CSDrawing.SolidBrush = SolidBrush;
        class HatchBrush extends Brush {
            constructor(hatchStyle, foreground, background) {
                super();
                this._hatchStyle = hatchStyle;
                this._foreground = foreground;
                this._background = background;
            }
            get hatchStyle() {
                return this._hatchStyle;
            }
            get foreground() {
                return this._foreground;
            }
            get background() {
                return this._background;
            }
            toString() {
                return this._foreground.color;
            }
        }
        CSDrawing.HatchBrush = HatchBrush;
        let HatchStyle;
        (function (HatchStyle) {
            HatchStyle[HatchStyle["Cross"] = 0] = "Cross";
            HatchStyle[HatchStyle["DottedGrid"] = 1] = "DottedGrid";
            HatchStyle[HatchStyle["Horizontal"] = 2] = "Horizontal";
            HatchStyle[HatchStyle["Vertical"] = 3] = "Vertical";
        })(HatchStyle = CSDrawing.HatchStyle || (CSDrawing.HatchStyle = {}));
        let csColors;
        (function (csColors) {
            csColors["ALICEBLUE"] = "#F0F8FF";
            csColors["ANTIQUEWHITE"] = "#FAEBD7";
            csColors["AQUA"] = "#00FFFF";
            csColors["AQUAMARINE"] = "#7FFFD4";
            csColors["AZURE"] = "#F0FFFF";
            csColors["BEIGE"] = "#F5F5DC";
            csColors["BISQUE"] = "#FFE4C4";
            csColors["BLACK"] = "#000000";
            csColors["BLANCHEDALMOND"] = "#FFEBCD";
            csColors["BLUE"] = "#0000FF";
            csColors["BLUEVIOLET"] = "#8A2BE2";
            csColors["BROWN"] = "#A52A2A";
            csColors["BURLYWOOD"] = "#DEB887";
            csColors["CADETBLUE"] = "#5F9EA0";
            csColors["CHARTREUSE"] = "#7FFF00";
            csColors["CHOCOLATE"] = "#D2691E";
            csColors["CORAL"] = "#FF7F50";
            csColors["CORNFLOWERBLUE"] = "#6495ED";
            csColors["CORNSILK"] = "#FFF8DC";
            csColors["CRIMSON"] = "#DC143C";
            csColors["CYAN"] = "#00FFFF";
            csColors["DARKBLUE"] = "#00008B";
            csColors["DARKCYAN"] = "#008B8B";
            csColors["DARKGOLDENROD"] = "#B8860B";
            csColors["DARKGRAY"] = "#A9A9A9";
            csColors["DARKGREEN"] = "#006400";
            csColors["DARKKHAKI"] = "#BDB76B";
            csColors["DARKMAGENTA"] = "#8B008B";
            csColors["DARKOLIVEGREEN"] = "#556B2F";
            csColors["DARKORANGE"] = "#FF8C00";
            csColors["DARKORCHID"] = "#9932CC";
            csColors["DARKRED"] = "#8B0000";
            csColors["DARKSALMON"] = "#E9967A";
            csColors["DARKSEAGREEN"] = "#8FBC8B";
            csColors["DARKSLATEBLUE"] = "#483D8B";
            csColors["DARKSLATEGRAY"] = "#2F4F4F";
            csColors["DARKTURQUOISE"] = "#00CED1";
            csColors["DARKVIOLET"] = "#9400D3";
            csColors["DEEPPINK"] = "#FF1493";
            csColors["DEEPSKYBLUE"] = "#00BFFF";
            csColors["DIMGRAY"] = "#696969";
            csColors["DODGERBLUE"] = "#1E90FF";
            csColors["FIREBRICK"] = "#B22222";
            csColors["FLORALWHITE"] = "#FFFAF0";
            csColors["FORESTGREEN"] = "#228B22";
            csColors["FUCHSIA"] = "#FF00FF";
            csColors["GAINSBORO"] = "#DCDCDC";
            csColors["GHOSTWHITE"] = "#F8F8FF";
            csColors["GOLD"] = "#FFD700";
            csColors["GOLDENROD"] = "#DAA520";
            csColors["GRAY"] = "#808080";
            csColors["GREEN"] = "#008000";
            csColors["GREENYELLOW"] = "#ADFF2F";
            csColors["HONEYDEW"] = "#F0FFF0";
            csColors["HOTPINK"] = "#FF69B4";
            csColors["INDIANRED"] = "#CD5C5C";
            csColors["INDIGO"] = "#4B0082";
            csColors["IVORY"] = "#FFFFF0";
            csColors["KHAKI"] = "#F0E68C";
            csColors["LAVENDER"] = "#E6E6FA";
            csColors["LAVENDERBLUSH"] = "#FFF0F5";
            csColors["LAWNGREEN"] = "#7CFC00";
            csColors["LEMONCHIFFON"] = "#FFFACD";
            csColors["LIGHTBLUE"] = "#ADD8E6";
            csColors["LIGHTCORAL"] = "#F08080";
            csColors["LIGHTCYAN"] = "#E0FFFF";
            csColors["LIGHTGOLDENRODYELLOW"] = "#FAFAD2";
            csColors["LIGHTGRAY"] = "#D3D3D3";
            csColors["LIGHTGREEN"] = "#90EE90";
            csColors["LIGHTPINK"] = "#FFB6C1";
            csColors["LIGHTSALMON"] = "#FFA07A";
            csColors["LIGHTSEAGREEN"] = "#20B2AA";
            csColors["LIGHTSKYBLUE"] = "#87CEFA";
            csColors["LIGHTSLATEGRAY"] = "#778899";
            csColors["LIGHTSTEELBLUE"] = "#B0C4DE";
            csColors["LIGHTYELLOW"] = "#FFFFE0";
            csColors["LIME"] = "#00FF00";
            csColors["LIMEGREEN"] = "#32CD32";
            csColors["LINEN"] = "#FAF0E6";
            csColors["MAGENTA"] = "#FF00FF";
            csColors["MAROON"] = "#800000";
            csColors["MEDIUMAQUAMARINE"] = "#66CDAA";
            csColors["MEDIUMBLUE"] = "#0000CD";
            csColors["MEDIUMORCHID"] = "#BA55D3";
            csColors["MEDIUMPURPLE"] = "#9370DB";
            csColors["MEDIUMSEAGREEN"] = "#3CB371";
            csColors["MEDIUMSLATEBLUE"] = "#7B68EE";
            csColors["MEDIUMSPRINGGREEN"] = "#00FA9A";
            csColors["MEDIUMTURQUOISE"] = "#48D1CC";
            csColors["MEDIUMVIOLETRED"] = "#C71585";
            csColors["MIDNIGHTBLUE"] = "#191970";
            csColors["MINTCREAM"] = "#F5FFFA";
            csColors["MISTYROSE"] = "#FFE4E1";
            csColors["MOCCASIN"] = "#FFE4B5";
            csColors["NAVAJOWHITE"] = "#FFDEAD";
            csColors["NAVY"] = "#000080";
            csColors["OLDLACE"] = "#FDF5E6";
            csColors["OLIVE"] = "#808000";
            csColors["OLIVEDRAB"] = "#6B8E23";
            csColors["ORANGE"] = "#FFA500";
            csColors["ORANGERED"] = "#FF4500";
            csColors["ORCHID"] = "#DA70D6";
            csColors["PALEGOLDENROD"] = "#EEE8AA";
            csColors["PALEGREEN"] = "#98FB98";
            csColors["PALETURQUOISE"] = "#AFEEEE";
            csColors["PALEVIOLETRED"] = "#DB7093";
            csColors["PAPAYAWHIP"] = "#FFEFD5";
            csColors["PEACHPUFF"] = "#FFDAB9";
            csColors["PERU"] = "#CD853F";
            csColors["PINK"] = "#FFC0CB";
            csColors["PLUM"] = "#DDA0DD";
            csColors["POWDERBLUE"] = "#B0E0E6";
            csColors["PURPLE"] = "#800080";
            csColors["RED"] = "#FF0000";
            csColors["ROSYBROWN"] = "#BC8F8F";
            csColors["ROYALBLUE"] = "#4169E1";
            csColors["SADDLEBROWN"] = "#8B4513";
            csColors["SALMON"] = "#FA8072";
            csColors["SANDYBROWN"] = "#F4A460";
            csColors["SEAGREEN"] = "#2E8B57";
            csColors["SEASHELL"] = "#FFF5EE";
            csColors["SIENNA"] = "#A0522D";
            csColors["SILVER"] = "#C0C0C0";
            csColors["SKYBLUE"] = "#87CEEB";
            csColors["SLATEBLUE"] = "#6A5ACD";
            csColors["SLATEGRAY"] = "#708090";
            csColors["SNOW"] = "#FFFAFA";
            csColors["SPRINGGREEN"] = "#00FF7F";
            csColors["STEELBLUE"] = "#4682B4";
            csColors["TAN"] = "#D2B48C";
            csColors["TEAL"] = "#008080";
            csColors["THISTLE"] = "#D8BFD8";
            csColors["TOMATO"] = "#FF6347";
            csColors["TRANSPARENT"] = "#FFFF";
            csColors["TURQUOISE"] = "#40E0D0";
            csColors["VIOLET"] = "#EE82EE";
            csColors["WHEAT"] = "#F5DEB3";
            csColors["WHITE"] = "#FFFFFF";
            csColors["WHITESMOKE"] = "#F5F5F5";
            csColors["YELLOW"] = "#FFFF00";
            csColors["YELLOWGREEN"] = "#9ACD32";
        })(csColors = CSDrawing.csColors || (CSDrawing.csColors = {}));
        class Color {
            toArgb() {
                return Color.hexToRgb(this._color);
            }
            static colorFromRGB(rgb) {
                return new Color(rgb);
            }
            static hexToRgb(hex) {
                const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                    return r + r + g + g + b + b;
                });
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? "rgb("
                    + parseInt(result[1], 16) + ", "
                    + parseInt(result[2], 16) + ", "
                    + parseInt(result[3], 16) + ")"
                    : null;
            }
            static componentToHex(c) {
                const hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }
            static rgbToHex(r, g, b) {
                return "#" + Color.componentToHex(r) + Color.componentToHex(g) + Color.componentToHex(b);
            }
            constructor(color) {
                this._color = color;
            }
            get color() {
                return this._color;
            }
            static colorFromNumber(color) {
                if (typeof color === 'string' && Number.isInteger(Number(color))) {
                    color = parseInt(color);
                }
                if (typeof color === 'number') {
                    const hex = color.toString(16);
                    color = "#" + "000000".substring(0, 6 - hex.length) + hex;
                }
                return color;
            }
            toString() {
                return Color.colorFromNumber(this._color);
            }
        }
        Color.Orange = new Color(csColors.ORANGE);
        Color.OrangeRed = new Color(csColors.ORANGERED);
        Color.Gray = new Color(csColors.GRAY);
        Color.Black = new Color(csColors.BLACK);
        Color.Red = new Color(csColors.RED);
        Color.White = new Color(csColors.WHITE);
        Color.Blue = new Color(csColors.BLUE);
        Color.AliceBlue = new Color(csColors.ALICEBLUE);
        Color.HoneyDew = new Color(csColors.HONEYDEW);
        CSDrawing.Color = Color;
        class GraphicsPath {
            addRectangle(baseRect) {
            }
            closeFigure() {
            }
            addArc(arc, number, number2) {
            }
            addEllipse(baseRect) {
            }
        }
        CSDrawing.GraphicsPath = GraphicsPath;
        class SizeF {
            constructor(width, height) {
                this.width = width;
                this.height = height;
            }
        }
        CSDrawing.SizeF = SizeF;
        let StringTrimming;
        (function (StringTrimming) {
            StringTrimming[StringTrimming["EllipsisWord"] = 0] = "EllipsisWord";
        })(StringTrimming = CSDrawing.StringTrimming || (CSDrawing.StringTrimming = {}));
        let StringAlignment;
        (function (StringAlignment) {
            StringAlignment[StringAlignment["Near"] = 0] = "Near";
        })(StringAlignment = CSDrawing.StringAlignment || (CSDrawing.StringAlignment = {}));
        let StringFormatFlags;
        (function (StringFormatFlags) {
            StringFormatFlags[StringFormatFlags["Wrap"] = 0] = "Wrap";
            StringFormatFlags[StringFormatFlags["NoWrap"] = 1] = "NoWrap";
        })(StringFormatFlags = CSDrawing.StringFormatFlags || (CSDrawing.StringFormatFlags = {}));
        class StringFormat {
            constructor() {
                this.trimming = StringTrimming.EllipsisWord;
                this.alignment = StringAlignment.Near;
                this.formatFlags = StringFormatFlags.Wrap;
            }
        }
        CSDrawing.StringFormat = StringFormat;
    })(CSDrawing = CSReports.CSDrawing || (CSReports.CSDrawing = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDrawing;
    (function (CSDrawing) {
        class Font {
            constructor(name, size, bold, italic, strike = false, underline = false) {
                this._bold = '';
                this._italic = '';
                this._strike = false;
                this._underline = false;
                this._name = name;
                this._size = size;
                if (bold)
                    this._bold = 'bold ';
                if (italic)
                    this._italic = 'italic ';
                this._strike = strike;
                this._underline = underline;
            }
            resize(size) {
                let bold;
                if (this._bold === 'bold ')
                    bold = true;
                let italic;
                if (this._italic === 'italic ')
                    italic = true;
                return new Font(this._name, size, bold, italic, this._strike, this._underline);
            }
            toStringFont() {
                return this._bold + this._italic + this._size + 'px ' + this._name;
            }
            get name() {
                return this._name;
            }
            get size() {
                return this._size;
            }
            get italic() {
                return this._italic !== '';
            }
            get bold() {
                return this._bold !== '';
            }
            get underline() {
                return this._underline;
            }
            get strike() {
                return this._strike;
            }
            static availableFonts() {
                const fontCheck = new Set([
                    'Arial', 'Arial Black', 'Bahnschrift', 'Calibri', 'Cambria', 'Cambria Math', 'Candara', 'Comic Sans MS', 'Consolas', 'Constantia', 'Corbel', 'Courier New', 'Ebrima', 'Franklin Gothic Medium', 'Gabriola', 'Gadugi', 'Georgia', 'HoloLens MDL2 Assets', 'Impact', 'Ink Free', 'Javanese Text', 'Leelawadee UI', 'Lucida Console', 'Lucida Sans Unicode', 'Malgun Gothic', 'Marlett', 'Microsoft Himalaya', 'Microsoft JhengHei', 'Microsoft New Tai Lue', 'Microsoft PhagsPa', 'Microsoft Sans Serif', 'Microsoft Tai Le', 'Microsoft YaHei', 'Microsoft Yi Baiti', 'MingLiU-ExtB', 'Mongolian Baiti', 'MS Gothic', 'MV Boli', 'Myanmar Text', 'Nirmala UI', 'Palatino Linotype', 'Segoe MDL2 Assets', 'Segoe Print', 'Segoe Script', 'Segoe UI', 'Segoe UI Historic', 'Segoe UI Emoji', 'Segoe UI Symbol', 'SimSun', 'Sitka', 'Sylfaen', 'Symbol', 'Tahoma', 'Times New Roman', 'Trebuchet MS', 'Verdana', 'Webdings', 'Wingdings', 'Yu Gothic',
                    'American Typewriter', 'Andale Mono', 'Arial', 'Arial Black', 'Arial Narrow', 'Arial Rounded MT Bold', 'Arial Unicode MS', 'Avenir', 'Avenir Next', 'Avenir Next Condensed', 'Baskerville', 'Big Caslon', 'Bodoni 72', 'Bodoni 72 Oldstyle', 'Bodoni 72 Smallcaps', 'Bradley Hand', 'Brush Script MT', 'Chalkboard', 'Chalkboard SE', 'Chalkduster', 'Charter', 'Cochin', 'Comic Sans MS', 'Copperplate', 'Courier', 'Courier New', 'Didot', 'DIN Alternate', 'DIN Condensed', 'Futura', 'Geneva', 'Georgia', 'Gill Sans', 'Helvetica', 'Helvetica Neue', 'Herculanum', 'Hoefler Text', 'Impact', 'Lucida Grande', 'Luminari', 'Marker Felt', 'Menlo', 'Microsoft Sans Serif', 'Monaco', 'Noteworthy', 'Optima', 'Palatino', 'Papyrus', 'Phosphate', 'Rockwell', 'Savoye LET', 'SignPainter', 'Skia', 'Snell Roundhand', 'Tahoma', 'Times', 'Times New Roman', 'Trattatello', 'Trebuchet MS', 'Verdana', 'Zapfino',
                ].sort());
                return document.fonts.ready.then(() => {
                    const fontAvailable = new Set();
                    fontCheck.forEach((font) => {
                        if (document.fonts.check(`12px "${font}"`)) {
                            fontAvailable.add(font);
                        }
                    });
                    return fontAvailable;
                });
            }
        }
        CSDrawing.Font = Font;
    })(CSDrawing = CSReports.CSDrawing || (CSReports.CSDrawing = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSDrawing;
    (function (CSDrawing) {
        class cGraphics {
            getGraphics() {
                return this.graphics;
            }
            setGraphics(value) {
                this.graphics = value;
            }
            constructor(graphics) {
                this.graphics = null;
                this.graphics = graphics;
            }
            fillRoundRectangle(brush, x, y, width, height, radius) {
                this.fillRoundRectangleWithBrush(brush, x, y, width, height, radius);
            }
            fillRoundRectangleWithBrush(brush, x, y, width, height, radius) {
                let rectangle = CSDrawing.RectangleF.new4(x, y, width, height);
                let path = cGraphics.getRoundedRect(rectangle, radius);
                this.graphics.fillPath(brush, path);
            }
            drawRoundRectangle(pen, x, y, width, height, radius) {
                let rectangle = CSDrawing.RectangleF.new4(x, y, width, height);
                let path = cGraphics.getRoundedRect(rectangle, radius);
                this.graphics.drawPath(pen, path);
            }
            static getRoundedRect(baseRect, radius) {
                if (radius <= 0) {
                    let mPath = new CSDrawing.GraphicsPath();
                    mPath.addRectangle(baseRect);
                    mPath.closeFigure();
                    return mPath;
                }
                if (radius >= (Math.min(baseRect.getWidth(), baseRect.getHeight())) / 2.0)
                    return cGraphics.getCapsule(baseRect);
                let diameter = radius * 2.0;
                let sizeF = new CSDrawing.SizeF(diameter, diameter);
                let arc = CSDrawing.RectangleF.new2(baseRect.getLocation(), sizeF);
                let path = new CSDrawing.GraphicsPath();
                path.addArc(arc, 180, 90);
                arc.setX(baseRect.getRight() - diameter);
                path.addArc(arc, 270, 90);
                arc.setY(baseRect.getBottom() - diameter);
                path.addArc(arc, 0, 90);
                arc.setX(baseRect.getLeft());
                path.addArc(arc, 90, 90);
                path.closeFigure();
                return path;
            }
            static getCapsule(baseRect, diameter = 0, arc = null) {
                let path = new CSDrawing.GraphicsPath();
                try {
                    if (baseRect.getWidth() > baseRect.getHeight()) {
                        diameter = baseRect.getHeight();
                        let sizeF = new CSDrawing.SizeF(diameter, diameter);
                        arc = CSDrawing.RectangleF.new2(baseRect.getLocation(), sizeF);
                        path.addArc(arc, 90, 180);
                        arc.setX(baseRect.getRight() - diameter);
                        path.addArc(arc, 270, 180);
                    }
                    else if (baseRect.getWidth() < baseRect.getHeight()) {
                        diameter = baseRect.getWidth();
                        let sizeF = new CSDrawing.SizeF(diameter, diameter);
                        arc = CSDrawing.RectangleF.new2(baseRect.getLocation(), sizeF);
                        path.addArc(arc, 180, 180);
                        arc.setY(baseRect.getBottom() - diameter);
                        path.addArc(arc, 0, 180);
                    }
                    else {
                        path.addEllipse(baseRect);
                    }
                }
                catch (ignore) {
                    path.addEllipse(baseRect);
                }
                finally {
                    path.closeFigure();
                }
                return path;
            }
        }
        CSDrawing.cGraphics = cGraphics;
    })(CSDrawing = CSReports.CSDrawing || (CSReports.CSDrawing = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class Button extends CSForms.Control {
        }
        CSForms.Button = Button;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class CheckBox extends CSForms.Control {
            constructor(el = null) {
                super(el);
                this.elInput = el;
            }
            setChecked(checked) {
                this.elInput.checked = checked;
            }
            getChecked() {
                return this.elInput.checked;
            }
        }
        CSForms.CheckBox = CheckBox;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class ComboBox extends CSForms.Control {
            constructor(el = null) {
                super(el);
                this.elSelect = el;
            }
            setText(text) {
                this.changeSelected(text);
            }
            changeSelected(text) {
                const options = Array.from(this.elSelect.options);
                const optionToSelect = options.find(item => item.text === text);
                if (optionToSelect) {
                    optionToSelect.selected = true;
                }
                else {
                    const optionSelected = options.find(item => item.selected === true);
                    if (optionSelected) {
                        optionSelected.selected = false;
                    }
                }
            }
            getText() {
                return this.elSelect.selectedOptions.length > 0 ? this.elSelect.selectedOptions[0].text : "";
            }
            getOptions() {
                return this.elSelect.options;
            }
            getSelectedIndex() {
                return this.elSelect.selectedIndex;
            }
            addItem(text, id) {
                this.getElement().add(new Option(text, id));
            }
        }
        CSForms.ComboBox = ComboBox;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var Map = CSReports.CSOAPI.Map;
        class Container extends CSForms.Control {
            constructor() {
                super(...arguments);
                this.controls = new Map();
            }
            getControls() {
                return this.controls;
            }
        }
        CSForms.Container = Container;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class Cursor {
            constructor(cursor) {
                this.cursor = cursor;
            }
            toString() {
                return this.cursor;
            }
        }
        Cursor.SizeNS = new Cursor('ns-resize');
        Cursor.MoveAll = new Cursor('all-scroll');
        Cursor.SizeNESW = new Cursor('nesw-resize');
        Cursor.SizeEW = new Cursor('ew-resize');
        Cursor.SizeNWSE = new Cursor('nwse-resize');
        Cursor.Move = new Cursor('all-scroll');
        Cursor.Default = new Cursor('default');
        CSForms.Cursor = Cursor;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var Color = CSReports.CSDrawing.Color;
        class Label extends CSForms.Control {
            constructor(el = null) {
                super(el);
                this.elLabel = el;
            }
            setBackColor(backColor) {
                this.elLabel.style.backgroundColor = Color.colorFromNumber(backColor);
            }
            setText(text) {
                this.elLabel.textContent = text;
            }
            getText() {
                return this.elLabel.textContent;
            }
        }
        CSForms.Label = Label;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        let MouseButtons;
        (function (MouseButtons) {
            MouseButtons[MouseButtons["Left"] = 0] = "Left";
            MouseButtons[MouseButtons["Wheel"] = 1] = "Wheel";
            MouseButtons[MouseButtons["Right"] = 2] = "Right";
        })(MouseButtons = CSForms.MouseButtons || (CSForms.MouseButtons = {}));
        class MouseEventArgs {
            constructor(Left, number, x, y, number2) {
            }
        }
        CSForms.MouseEventArgs = MouseEventArgs;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class OptionButton extends CSForms.Control {
            constructor(el = null) {
                super(el);
                this.elInput = el;
            }
            setChecked(checked) {
                this.elInput.checked = checked;
            }
            getChecked() {
                return this.elInput.checked;
            }
        }
        CSForms.OptionButton = OptionButton;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class Panel extends CSForms.Container {
            constructor(name, el) {
                super(el);
            }
        }
        CSForms.Panel = Panel;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var Graphic = CSReports.CSDrawing.Graphic;
        class PictureBox extends CSForms.Control {
            constructor(name, el) {
                super(el);
                this.name = name;
                this.div = el;
                this.canvas = document.createElement('canvas');
                this.canvas.style.left = "0px";
                this.canvas.style.top = "0px";
                this.canvas.width = 1;
                this.canvas.height = 1;
                this.canvas.oncontextmenu = (e) => { e.preventDefault(); };
                this.graphic = new Graphic(this.canvas, name);
                this.canvas.name = name;
                el.appendChild(this.canvas);
            }
            getGraphics() {
                return this.graphic;
            }
            getContext() {
                return this.graphic.getContext();
            }
            refresh() {
                if (this.paint !== null)
                    this.paint(this, { graphics: this.getGraphics() });
            }
            pointToScreen(point) {
                return point;
            }
            setPaint(paint) {
                this.paint = paint;
            }
            getCursor() {
                return new CSForms.Cursor(this.canvas.style.cursor);
            }
            setCursor(cursor) {
                super.setCursor(cursor);
                this.canvas.style.cursor = cursor.toString();
            }
            setWidth(value) {
                super.setWidth(value);
                this.canvas.width = value;
                this.div.style.width = value.toString() + "px";
            }
            setHeight(value) {
                super.setHeight(value);
                this.canvas.height = value;
                this.div.style.height = value.toString() + "px";
            }
            setBacgroundColor(color) {
                this.canvas.style.backgroundColor = color.color;
            }
            setMouseDownEventListner(f) {
                let canvas = this.canvas;
                this.canvas.onmousedown = (event) => {
                    var rect = canvas.getBoundingClientRect();
                    f(event, {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    });
                };
            }
            setMouseUpEventListner(f) {
                let canvas = this.canvas;
                this.canvas.onmouseup = (event) => {
                    var rect = canvas.getBoundingClientRect();
                    f(event, {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    });
                };
            }
            setMouseEventListner(f) {
                let canvas = this.canvas;
                this.canvas.onmousemove = (event) => {
                    var rect = canvas.getBoundingClientRect();
                    f(event, {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    });
                };
            }
            setImage(image) {
            }
            getImage() {
                return null;
            }
        }
        CSForms.PictureBox = PictureBox;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var Color = CSReports.CSDrawing.Color;
        class ProgressBar extends CSForms.Control {
            constructor(el = null) {
                super(el);
                this.elProgressBar = el;
            }
            setBackColor(backColor) {
                this.elProgressBar.style.backgroundColor = Color.colorFromNumber(backColor);
            }
            setText(text) {
                this.elProgressBar.textContent = text;
            }
            setValue(value) {
                this.elProgressBar.style.width = Math.floor(this.getWidth() * (value / 100)).toString() + "px";
            }
            setHeight(value) {
                super.setHeight(value);
                this.elProgressBar.style.height = this.getHeight().toString() + "px";
            }
        }
        CSForms.ProgressBar = ProgressBar;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        class ReportPreview extends CSForms.Control {
            constructor(name, el, parent = null) {
                super(el);
                this.firstPage = null;
                this.previousPage = null;
                this.moveToPage = null;
                this.nextPage = null;
                this.lastPage = null;
                this.exportToPDF = null;
                this.print = null;
                this.name = name;
                this.parent = parent;
                const toolbarNode = document.createElement('div');
                toolbarNode.className = "preview-toolbar";
                el.appendChild(toolbarNode);
                const pnEditorNode = document.createElement('div');
                pnEditorNode.className = "editor-container";
                el.appendChild(pnEditorNode);
                const picReportNode = document.createElement('div');
                picReportNode.className = "report";
                pnEditorNode.appendChild(picReportNode);
                this.div = el;
                this.createToolbar(toolbarNode);
                this.picPreview = new CSForms.PictureBox("pnReport" + ReportPreview.previewIndex++, picReportNode);
            }
            createToolbar(toolbarNode) {
                this.toolbar = new CSForms.Toolbar("preview-toolbar" + ReportPreview.previewIndex++, toolbarNode);
                this.toolbar.addButton("firstPage", ReportPreview.IMAGE_FIRST_PAGE, P.call(this, () => this.buttonClick(this.firstPage, EventArgs.Empty)));
                this.toolbar.addButton("previousPage", ReportPreview.IMAGE_PREVIOUS_PAGE, P.call(this, () => this.buttonClick(this.previousPage, EventArgs.Empty)));
                this.toolbar.addInput("moveToPage", P.call(this, (event) => {
                    if (event.key === "Enter") {
                        const page = U.valInt(event.target.value);
                        if (page > 0 && this.moveToPage !== null)
                            this.moveToPage(this, new PageEventArgs(page));
                    }
                }));
                this.toolbar.addNumberLabel(ReportPreview.TOTAL_PAGES_ID);
                this.toolbar.addButton("nextPage", ReportPreview.IMAGE_NEXT_PAGE, P.call(this, () => this.buttonClick(this.nextPage, EventArgs.Empty)));
                this.toolbar.addButton("lastPage", ReportPreview.IMAGE_LAST_PAGE, P.call(this, () => this.buttonClick(this.lastPage, EventArgs.Empty)));
            }
            buttonClick(f, e) {
                if (f !== null)
                    f(this, e);
            }
            setFirstPage(firstPage) {
                this.firstPage = firstPage;
            }
            setPreviousPage(previousPage) {
                this.previousPage = previousPage;
            }
            setMoveToPage(moveToPage) {
                this.moveToPage = moveToPage;
            }
            setNextPage(nextPage) {
                this.nextPage = nextPage;
            }
            setLastPage(lastPage) {
                this.lastPage = lastPage;
            }
            getBody() {
                return this.picPreview;
            }
            getGraph() {
                return this.picPreview.getGraphics();
            }
            getParent() {
                return this.parent;
            }
            setCurrPage(page) {
                this.toolbar.getControls().item(ReportPreview.CURRENT_PAGE_ID).value = (page + 1).toString();
            }
            setPages(pages) {
                this.toolbar.getControls().item(ReportPreview.TOTAL_PAGES_ID).textContent = pages.toString();
            }
        }
        ReportPreview.IMAGE_FIRST_PAGE = "tsbFirstPage.Image.png";
        ReportPreview.IMAGE_PREVIOUS_PAGE = "tsbPreviousPage.Image.png";
        ReportPreview.IMAGE_NEXT_PAGE = "tsbNextPage.Image.png";
        ReportPreview.IMAGE_LAST_PAGE = "tsbLastPage.Image.png";
        ReportPreview.TOTAL_PAGES_ID = "totalPages";
        ReportPreview.CURRENT_PAGE_ID = "moveToPage";
        ReportPreview.previewIndex = 0;
        CSForms.ReportPreview = ReportPreview;
        class EventArgs {
        }
        EventArgs.Empty = new EventArgs();
        CSForms.EventArgs = EventArgs;
        class PageEventArgs extends EventArgs {
            constructor(page) {
                super();
                this.page = -1;
                this.page = page;
            }
            getPage() {
                return this.page;
            }
        }
        CSForms.PageEventArgs = PageEventArgs;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class TabBar extends CSForms.Container {
            constructor(name, el) {
                super(el);
                this.tabPages = new TabPages(this);
            }
            getPages() {
                return this.tabPages;
            }
        }
        CSForms.TabBar = TabBar;
        class TabPages {
            constructor(tabBar) {
                this.selectorFlags = new CSReports.CSOAPI.Map();
                this.tabBar = tabBar;
            }
            hideAll() {
                for (let i = 0; i < this.tabBar.getControls().count(); i++) {
                    this.tabBar.getControls().item(i).getElement().style.display = 'none';
                    this.selectorFlags.item(i).style.display = 'none';
                }
            }
            add(tabPage, key) {
                const tabSelectorNode = document.createElement('button');
                tabSelectorNode.className = "tablinks";
                tabSelectorNode.onclick = (event) => {
                    if (event.target.nodeName !== 'SPAN') {
                        this.hideAll();
                        tabPage.getElement().style.display = 'block';
                        tabPage.getSelectedFlag().style.display = 'block';
                        if (event.raisedByCode === undefined)
                            tabPage.showTab();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                };
                tabSelectorNode.innerText = tabPage.getText();
                const tabCloseNode = document.createElement('span');
                tabCloseNode.className = "close";
                tabCloseNode.onclick = (event) => {
                    tabPage.getElement().style.display = 'none';
                    tabSelectorNode.parentNode.removeChild(tabSelectorNode);
                    if (tabPage.onClose)
                        tabPage.onClose();
                    this.tabBar.getControls().removeByObject(tabPage);
                    this.selectorFlags.removeByObject(tabPage.getSelectedFlag());
                    if (this.tabBar.getControls().size() > 0) {
                        const nextTab = this.tabBar.getControls().item(0);
                        nextTab.showTab();
                    }
                    else {
                        CSReports.CSReportEditor.cMainEditor.setDocActive(null);
                    }
                };
                tabCloseNode.innerText = "x";
                tabSelectorNode.appendChild(tabCloseNode);
                const div = document.createElement('div');
                div.appendChild(tabSelectorNode);
                div.style.padding = "0";
                const span = document.createElement('span');
                span.style.backgroundColor = "#92e1a3";
                span.style.widows = "100%";
                span.style.height = "2px";
                span.style.display = "block";
                span.style.position = "relative";
                span.style.top = "44px";
                this.selectorFlags.add(span);
                div.appendChild(span);
                this.tabBar.getElement().appendChild(div);
                tabPage.setTabSelector(tabSelectorNode);
                tabPage.setSelectedFlag(span);
                this.tabBar.getElement().parentNode.appendChild(tabPage.getElement());
                this.hideAll();
                tabPage.getElement().style.display = 'block';
                return this.tabBar.getControls().add(tabPage, key);
            }
        }
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var cWindow = CSReports.CSKernelClient.cWindow;
        class TabPage extends CSForms.Container {
            constructor(name, el) {
                super(el);
            }
            setTabSelector(tabSelector) {
                this.tabSelector = tabSelector;
            }
            getSelectedFlag() {
                return this.selectedFlag;
            }
            setSelectedFlag(selectedFlag) {
                this.selectedFlag = selectedFlag;
            }
            getTag() {
                return this.tag;
            }
            setTag(tag) {
                this.tag = tag;
            }
            showTab() {
                cWindow.clickElem(this.tabSelector);
                if (this.onActive !== null) {
                    this.onActive();
                }
            }
            setText(text) {
                this.text = text;
                if (this.tabSelector) {
                    const textToChange = this.tabSelector.childNodes[0];
                    textToChange.nodeValue = this.text;
                }
            }
            getText() {
                return this.text;
            }
        }
        CSForms.TabPage = TabPage;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        class Toolbar extends CSForms.Control {
            constructor(name, el) {
                super(el);
                this.controls = new CSReports.CSOAPI.Map;
                this.name = name;
                this.div = el;
                this.ul = document.createElement('ul');
                this.ul.className = "toolbar";
                this.div.appendChild(this.ul);
            }
            addButton(buttonId, image, onclic) {
                const li = document.createElement('li');
                const link = document.createElement('a');
                link.href = "#";
                link.onclick = onclic;
                const img = document.createElement('img');
                img.src = "images/toolbar/" + image;
                img.style.height = "25px";
                link.appendChild(img);
                li.appendChild(link);
                this.ul.appendChild(li);
                this.controls.add(link, buttonId);
            }
            addInput(inputId, onkeyup) {
                const li = document.createElement('li');
                const input = document.createElement('input');
                input.onkeyup = onkeyup;
                input.style.marginTop = "15px";
                input.style.width = "50px";
                li.appendChild(input);
                this.ul.appendChild(li);
                this.controls.add(input, inputId);
            }
            addNumberLabel(labelId) {
                const li = document.createElement('li');
                const span = document.createElement('span');
                span.className = "toolbar-span-number";
                li.appendChild(span);
                this.ul.appendChild(li);
                this.controls.add(span, labelId);
            }
            getControls() {
                return this.controls;
            }
        }
        CSForms.Toolbar = Toolbar;
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSForms;
    (function (CSForms) {
        var Map = CSReports.CSOAPI.Map;
        var P = CSReports.CSKernelClient.Callable;
        class TreeState {
        }
        class Nodes extends Map {
            constructor(folder, state) {
                super(null, false);
                this.images = ['folder.png', 'property.png', 'formula.png', 'database.png'];
                this.folder = folder;
                this.state = state;
            }
            add(text, imageIndex = null, key = null) {
                const li = document.createElement('li');
                const a = this.addLabel(text, li, imageIndex);
                this.folder.parentElement.classList.add('expanded');
                const node = new Node(li, imageIndex, a, this.state);
                return this.baseAdd(node, key);
            }
            addLabel(text, li, imageIndex) {
                const img = document.createElement('img');
                img.src = './images/tree/' + this.images[imageIndex];
                li.appendChild(img);
                const a = document.createElement('a');
                a.innerText = text;
                li.appendChild(a);
                this.folder.appendChild(li);
                return a;
            }
            clear() {
                this.removeAllChildNodes(this.folder);
                this.folder.parentElement.classList.remove('expanded', 'collapsed');
                super.baseClear();
            }
            removeAllChildNodes(parent) {
                while (parent.firstChild) {
                    parent.removeChild(parent.firstChild);
                }
            }
        }
        class Node {
            constructor(li, imageIndex, a, state) {
                this._items = null;
                this.state = state;
                this.li = li;
                this.imageIndex = imageIndex;
                const ul = document.createElement('ul');
                ul.style.display = 'block';
                this.li.appendChild(ul);
                this._items = new Nodes(ul, state);
                this.a = a;
                a.href = "#";
                a.className = 'nostyle';
                a.onclick = P.call(this, (ev) => {
                    ev.stopPropagation();
                    this.focus(ev);
                });
                li.onclick = (ev) => {
                    if (ev.target === li && ul.childNodes.length > 0) {
                        ul.style.display = ul.style.display === 'none' ? 'block' : 'none';
                        li.classList.toggle("collapsed");
                        ev.stopPropagation();
                        this.focus(ev);
                    }
                };
            }
            deactivate() {
                this.a.classList.remove('active');
            }
            getNodes() {
                return this._items;
            }
            expandAll() {
            }
            setText(text) {
                this.li.childNodes[1].textContent = text;
            }
            focus(event) {
                if (this.state.activeNode) {
                    this.state.activeNode.deactivate();
                }
                this.state.activeNode = this;
                this.a.classList.add('active');
                switch (true) {
                    case event.detail === 0:
                    case event.detail === 1:
                        if (this.state.onclick) {
                            this.state.onclick.call(null, this);
                        }
                        break;
                    case event.detail === 2:
                        if (this.state.onDblclick) {
                            this.state.onDblclick.call(null, this);
                        }
                        break;
                }
            }
            getPrevious() {
                let prev = this.li.previousElementSibling;
                if (prev === null)
                    prev = this.li.parentElement.parentElement;
                return prev;
            }
            getNext() {
                let next;
                let ul = this.li.children.item(2);
                if (ul.style.display === 'block' && ul.childElementCount > 0) {
                    next = ul.children.item(0);
                }
                else {
                    next = this.li.nextElementSibling;
                }
                return next;
            }
        }
        CSForms.Node = Node;
        class TreeView extends CSForms.Control {
            constructor(name, el, text) {
                super(el);
                this._items = null;
                el.tabIndex = 0;
                el.onkeydown = P.call(this, this.onKeyDown);
                el.onkeyup = P.call(this, this.onKeyUp);
                this.name = name;
                this.state = new TreeState();
                this.div = el;
                this.rootUl = document.createElement('ul');
                this.rootUl.className = "tree";
                this._text = text;
                this.addLabel(text);
                this.div.appendChild(this.rootUl);
                this._items = new Nodes(this.rootUl, this.state);
            }
            onKeyDown(event) {
                switch (true) {
                    case event.key === 'ArrowUp':
                    case event.key === 'ArrowDown':
                        event.stopPropagation();
                        event.preventDefault();
                        break;
                }
            }
            onKeyUp(event) {
                let el;
                switch (true) {
                    case event.key === 'ArrowUp':
                        el = this.state.activeNode.getPrevious();
                        event.stopPropagation();
                        break;
                    case event.key === 'ArrowDown':
                        el = this.state.activeNode.getNext();
                        event.stopPropagation();
                        break;
                }
                if (el instanceof HTMLLIElement) {
                    el.children.item(1).click();
                }
            }
            addLabel(text) {
                const img = document.createElement('img');
                img.src = './images/tree/folder.png';
                this.rootUl.appendChild(img);
                const a = document.createElement('a');
                a.innerText = text;
                this.rootUl.appendChild(a);
            }
            getNodes() {
                return this._items;
            }
            selectedNode() {
                return this._selectedNode;
            }
            clear() {
                this.getNodes().clear();
                this.addLabel(this._text);
            }
        }
        CSForms.TreeView = TreeView;
        let TreeViewAction;
        (function (TreeViewAction) {
            TreeViewAction[TreeViewAction["Collapse"] = 0] = "Collapse";
            TreeViewAction[TreeViewAction["Expand"] = 1] = "Expand";
        })(TreeViewAction = CSForms.TreeViewAction || (CSForms.TreeViewAction = {}));
    })(CSForms = CSReports.CSForms || (CSReports.CSForms = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelClient;
    (function (CSKernelClient) {
        class RefWrapper {
            constructor(value = null) {
                this.value = value;
            }
            set(value) {
                this.value = value;
            }
            get() {
                return this.value;
            }
        }
        CSKernelClient.RefWrapper = RefWrapper;
    })(CSKernelClient = CSReports.CSKernelClient || (CSReports.CSKernelClient = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelClient;
    (function (CSKernelClient) {
        let eTypes;
        (function (eTypes) {
            eTypes[eTypes["eInteger"] = 2] = "eInteger";
            eTypes[eTypes["eDouble"] = 5] = "eDouble";
            eTypes[eTypes["eCurrency"] = 6] = "eCurrency";
            eTypes[eTypes["eText"] = 200] = "eText";
            eTypes[eTypes["eId"] = -1] = "eId";
            eTypes[eTypes["eCuit"] = -100] = "eCuit";
            eTypes[eTypes["eBoolean"] = -200] = "eBoolean";
            eTypes[eTypes["eSingle"] = -300] = "eSingle";
            eTypes[eTypes["eVariant"] = -400] = "eVariant";
            eTypes[eTypes["eLong"] = -500] = "eLong";
            eTypes[eTypes["eDate"] = -600] = "eDate";
            eTypes[eTypes["eDateOrNull"] = -700] = "eDateOrNull";
        })(eTypes = CSKernelClient.eTypes || (CSKernelClient.eTypes = {}));
        let eFileMode;
        (function (eFileMode) {
            eFileMode[eFileMode["eRead"] = 1] = "eRead";
            eFileMode[eFileMode["eWrite"] = 2] = "eWrite";
            eFileMode[eFileMode["eAppend"] = 3] = "eAppend";
            eFileMode[eFileMode["eBinaryRead"] = 4] = "eBinaryRead";
            eFileMode[eFileMode["eBinaryWrite"] = 5] = "eBinaryWrite";
        })(eFileMode = CSKernelClient.eFileMode || (CSKernelClient.eFileMode = {}));
        let eFileAccess;
        (function (eFileAccess) {
            eFileAccess[eFileAccess["eShared"] = 1] = "eShared";
            eFileAccess[eFileAccess["eLockRead"] = 2] = "eLockRead";
            eFileAccess[eFileAccess["eLockWrite"] = 3] = "eLockWrite";
            eFileAccess[eFileAccess["eLockReadWrite"] = 4] = "eLockReadWrite";
        })(eFileAccess = CSKernelClient.eFileAccess || (CSKernelClient.eFileAccess = {}));
        let eErrorType;
        (function (eErrorType) {
            eErrorType[eErrorType["eErrorAdo"] = 1] = "eErrorAdo";
            eErrorType[eErrorType["eErrorVba"] = 2] = "eErrorVba";
        })(eErrorType = CSKernelClient.eErrorType || (CSKernelClient.eErrorType = {}));
        let eErrorLevel;
        (function (eErrorLevel) {
            eErrorLevel[eErrorLevel["eErrorWarning"] = 1] = "eErrorWarning";
            eErrorLevel[eErrorLevel["eErrorFatal"] = 2] = "eErrorFatal";
            eErrorLevel[eErrorLevel["eErrorInformation"] = 3] = "eErrorInformation";
        })(eErrorLevel = CSKernelClient.eErrorLevel || (CSKernelClient.eErrorLevel = {}));
        let eFieldType;
        (function (eFieldType) {
            eFieldType[eFieldType["eFieldBoolean"] = -200] = "eFieldBoolean";
            eFieldType[eFieldType["eFieldNumeric"] = 5] = "eFieldNumeric";
            eFieldType[eFieldType["eFieldChar"] = 200] = "eFieldChar";
            eFieldType[eFieldType["eFieldDate"] = -600] = "eFieldDate";
        })(eFieldType = CSKernelClient.eFieldType || (CSKernelClient.eFieldType = {}));
        let CS_MSG_ICONS;
        (function (CS_MSG_ICONS) {
            CS_MSG_ICONS[CS_MSG_ICONS["Exclamation"] = 0] = "Exclamation";
            CS_MSG_ICONS[CS_MSG_ICONS["Information"] = 1] = "Information";
            CS_MSG_ICONS[CS_MSG_ICONS["Error"] = 2] = "Error";
        })(CS_MSG_ICONS = CSKernelClient.CS_MSG_ICONS || (CSKernelClient.CS_MSG_ICONS = {}));
    })(CSKernelClient = CSReports.CSKernelClient || (CSReports.CSKernelClient = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelClient;
    (function (CSKernelClient) {
        class cDateUtils {
            static isDate(value) {
                if (this.isValidDate(value)) {
                    return true;
                }
                else {
                    let t = typeof value;
                    if (t === "string") {
                        return this.isValidDate(Date.parse(value));
                    }
                    else {
                        return false;
                    }
                }
            }
            static isValidDate(date) {
                return date && Object.prototype.toString.call(date) === "[object Date]" && !isNaN(date);
            }
        }
        CSKernelClient.cDateUtils = cDateUtils;
    })(CSKernelClient = CSReports.CSKernelClient || (CSReports.CSKernelClient = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelClient;
    (function (CSKernelClient) {
        class CMouseWait {
            static default() {
            }
            dispose() {
            }
        }
        CSKernelClient.CMouseWait = CMouseWait;
    })(CSKernelClient = CSReports.CSKernelClient || (CSReports.CSKernelClient = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelFile;
    (function (CSKernelFile) {
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        var cWindow = CSReports.CSKernelClient.cWindow;
        class cFile {
            static getPath(fileName) {
                throw new NotImplementedException();
            }
            static getFileName(fileName) {
                throw new NotImplementedException();
            }
            static getFileWithoutExt(fileNameWithExt) {
                throw new NotImplementedException();
            }
            init(title) {
            }
            setFilter(filter) {
            }
            save(name, bExists, bReadonly, s) {
                return false;
            }
            getName() {
                return "";
            }
            getPath() {
                return "";
            }
            open(name, eWrite, b, b2, eLockWrite, b3, b4) {
                return false;
            }
            userOpenFile() {
                return new Promise((resolve, reject) => {
                    this.openFile(resolve, reject);
                });
            }
            saveInBrowser(name, content, type) {
                const file = new Blob([content], { type: type });
                const url = URL.createObjectURL(file);
                const a = document.createElement("a");
                a.style.display = 'none';
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                cWindow.clickElem(a);
                setTimeout(function () {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 0);
            }
            close() {
            }
            fileExists(file) {
                return false;
            }
            static directorySeparatorChar() {
                return "";
            }
            openFile(resolve, reject) {
                const readFile = (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        reject();
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        document.body.removeChild(fileInput);
                        const fc = new FileContent();
                        fc.name = file.name;
                        fc.content = e.target.result;
                        resolve(fc);
                    };
                    reader.readAsText(file);
                };
                const fileInput = document.createElement("input");
                fileInput.type = 'file';
                fileInput.style.display = 'none';
                fileInput.onchange = readFile;
                document.body.appendChild(fileInput);
                cWindow.clickElem(fileInput);
            }
        }
        CSKernelFile.cFile = cFile;
        class FileContent {
        }
        CSKernelFile.FileContent = FileContent;
    })(CSKernelFile = CSReports.CSKernelFile || (CSReports.CSKernelFile = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSKernelNumberToString;
    (function (CSKernelNumberToString) {
        var Maths = CSReports.CSOAPI.Maths;
        class cNumberToString {
            static secondsToString(count) {
                let hours = 0;
                let minutes = 0;
                let second = 0;
                hours = count / 3600;
                minutes = (count % 3600) / 60;
                second = (count % 3600) % 60;
                return this.pad(hours, "00", 2)
                    + ":" + this.pad(minutes, "00", 2)
                    + ":" + this.pad(second, "00", 2);
            }
            static pad(value, pad, size) {
                return pad + value.toString().slice(-size);
            }
            static spanishNumberToString(num) {
                let iMillion = 0;
                let iThousand = 0;
                let rtn = "";
                num = Maths.round(num, 2);
                if (num >= 1000000) {
                    iMillion = cNumberToString.getValue(num, 1000000);
                    if (num >= 2000000) {
                        rtn = cNumberToString.spanishGetNumber(iMillion, true) + " Millones ";
                    }
                    else {
                        rtn = cNumberToString.spanishGetNumber(iMillion, true) + " Millon ";
                    }
                    num = num - (iMillion * 1000000);
                }
                if (num >= 1000) {
                    iThousand = cNumberToString.getValue(num, 1000);
                    rtn = rtn + cNumberToString.spanishGetNumber(iThousand, true) + " Mil ";
                    num = num - (iThousand * 1000);
                }
                rtn = rtn + cNumberToString.spanishGetNumber(Maths.trunc(num), false);
                rtn = rtn + cNumberToString.spanishGetDecimal(num);
                return rtn.substring(0, 1).toUpperCase() + rtn.substring(1).toLowerCase();
            }
            static frenchNumberToString(num) {
                let iMillion = 0;
                let iThousand = 0;
                let rtn = "";
                num = Maths.round(num, 2);
                if (num >= 1000000) {
                    iMillion = cNumberToString.getValue(num, 1000000);
                    if (num >= 2000000) {
                        rtn = cNumberToString.frenchGetNumber(iMillion) + " Millions ";
                    }
                    else {
                        rtn = cNumberToString.frenchGetNumber(iMillion) + " Million ";
                    }
                    num = num - (iMillion * 1000000);
                }
                if (num >= 1000) {
                    iThousand = cNumberToString.getValue(num, 1000);
                    if (iThousand === 1) {
                        rtn = " Mil ";
                    }
                    else {
                        rtn = rtn + cNumberToString.frenchGetNumber(iThousand) + " Mil ";
                    }
                    num = num - (iThousand * 1000);
                }
                rtn = rtn + cNumberToString.frenchGetNumber(Maths.trunc(num));
                rtn = rtn + cNumberToString.frenchGetDecimal(num);
                return rtn.substring(0, 1).toUpperCase() + rtn.substring(2).toLowerCase();
            }
            static englishNumberToString(num) {
                let iMillion = 0;
                let iThousand = 0;
                let rtn = "";
                num = Maths.round(num, 2);
                if (num >= 1000000) {
                    iMillion = cNumberToString.getValue(num, 1000000);
                    rtn = cNumberToString.englishGetNumber(iMillion) + " Million ";
                    num = num - (iMillion * 1000000);
                }
                if (num >= 1000) {
                    iThousand = cNumberToString.getValue(num, 1000);
                    rtn = rtn + cNumberToString.englishGetNumber(iThousand) + " Thousand ";
                    num = num - (iThousand * 1000);
                }
                rtn = rtn + cNumberToString.englishGetNumber(Maths.trunc(num));
                rtn = rtn + cNumberToString.englishGetDecimal(num);
                return rtn.substring(0, 1).toUpperCase() + rtn.substring(2).toLowerCase();
            }
            static spanishGetNumber(num, bPutOne) {
                let rtn = "";
                let iTens = 0;
                let iUnit = 0;
                let iNumAux = 0;
                let bPutOneAux = false;
                if (num === 100) {
                    rtn = "Cien ";
                }
                else {
                    if (num > 100) {
                        iNumAux = num;
                        rtn = cNumberToString.spanishGetNameHundred(iNumAux) + " ";
                        iTens = cNumberToString.getHundred(iNumAux);
                        bPutOne = false;
                    }
                    else {
                        iTens = num;
                    }
                }
                if (iTens !== 0) {
                    if (iTens >= 1 && iTens <= 15) {
                        bPutOneAux = bPutOne;
                        rtn = rtn + cNumberToString.spanishGetNameNumber(iTens, bPutOneAux);
                    }
                    else {
                        if (iTens >= 16 && iTens <= 19) {
                            rtn = rtn + "Dieci" + cNumberToString.spanishGetNameNumber(Maths.trunc(iTens - 10), bPutOne);
                        }
                        else {
                            if (iTens === 20) {
                                rtn = rtn + "Veinte";
                            }
                            else {
                                if (iTens >= 21 && iTens <= 29) {
                                    rtn = rtn + "Venti" + cNumberToString.spanishGetNameNumber(Maths.trunc(iTens - 20), bPutOne);
                                }
                                else {
                                    if (iTens >= 30) {
                                        rtn = rtn + cNumberToString.spanishGetNameTens(iTens);
                                        iUnit = cNumberToString.getUnit(iTens);
                                        rtn = rtn + (iUnit === 0 ? "" : " y ");
                                        rtn = rtn + cNumberToString.spanishGetNameNumber(iUnit, bPutOne);
                                    }
                                }
                            }
                        }
                    }
                }
                return rtn;
            }
            static spanishGetNameNumber(num, bPutOne) {
                switch (num) {
                    case 1:
                        if (bPutOne) {
                            return "Un";
                        }
                        else {
                            return "Uno";
                        }
                    case 2: return "Dos";
                    case 3: return "Tres";
                    case 4: return "Cuatro";
                    case 5: return "Cinco";
                    case 6: return "Seis";
                    case 7: return "Siete";
                    case 8: return "Ocho";
                    case 9: return "Nueve";
                    case 10: return "Diez";
                    case 11: return "Once";
                    case 12: return "Doce";
                    case 13: return "Trece";
                    case 14: return "Catorce";
                    case 15: return "Quince";
                    default: return "";
                }
            }
            static spanishGetNameHundred(num) {
                let number = num;
                if (number >= 900)
                    return "Novecientos";
                else if (number >= 800)
                    return "Ochocientos";
                else if (number >= 700)
                    return "Setecientos";
                else if (number >= 600)
                    return "Seiscientos";
                else if (number >= 500)
                    return "Quinientos";
                else if (number >= 400)
                    return "Cuatrocientos";
                else if (number >= 300)
                    return "trescientos";
                else if (number >= 200)
                    return "Doscientos";
                else if (number >= 100)
                    return "Ciento";
                else
                    return "";
            }
            static spanishGetNameTens(num) {
                let number = num;
                if (number >= 90)
                    return "Noventa";
                else if (number >= 80)
                    return "Ochenta";
                else if (number >= 70)
                    return "Setenta";
                else if (number >= 60)
                    return "Sesenta";
                else if (number >= 50)
                    return "Cincuenta";
                else if (number >= 40)
                    return "Cuarenta";
                else if (number >= 30)
                    return "Treinta";
                else
                    return "";
            }
            static spanishGetDecimal(num) {
                return cNumberToString.getDecimalAux(num, "con");
            }
            static frenchGetNumber(num) {
                let rtn = "";
                let iTens = 0;
                let iUnit = 0;
                let iNumAux = 0;
                if (num === 100) {
                    rtn = "Cent ";
                }
                else {
                    if (num > 100) {
                        iNumAux = num;
                        rtn = cNumberToString.frenchGetNameHundred(iNumAux) + " ";
                        iTens = cNumberToString.getHundred(iNumAux);
                    }
                    else {
                        iTens = num;
                    }
                }
                if (iTens !== 0) {
                    if (iTens >= 1 && iTens <= 16) {
                        rtn = rtn + cNumberToString.frenchGetNameNumber(iTens);
                    }
                    else {
                        if (iTens >= 17 && iTens <= 19) {
                            rtn = rtn + "Dix " + cNumberToString.frenchGetNameNumber(Maths.trunc(iTens - 10));
                        }
                        else {
                            if (iTens === 20) {
                                rtn = rtn + "Vingt";
                            }
                            else {
                                if (iTens >= 21 && iTens <= 29) {
                                    if (iTens === 21) {
                                        rtn = rtn + "Vingt et un";
                                    }
                                    else {
                                        rtn = rtn + "Vingt " + cNumberToString.frenchGetNameNumber(Maths.trunc(iTens - 20));
                                    }
                                }
                                else {
                                    iUnit = cNumberToString.getUnit(iTens);
                                    if (!(iTens >= 70 && iTens < 80) && !(iTens >= 90)) {
                                        rtn = rtn + cNumberToString.frenchGetNameTens(iTens);
                                        if (iUnit === 1) {
                                            rtn = rtn + " et ";
                                        }
                                        if (iUnit > 1) {
                                            rtn = rtn + " ";
                                        }
                                        rtn = rtn + cNumberToString.frenchGetNameNumber(iUnit);
                                    }
                                    else {
                                        rtn = rtn + cNumberToString.frenchGetNameTens(iTens) + this.frenchGetNameNumber(iUnit + 10);
                                    }
                                }
                            }
                        }
                    }
                }
                return rtn;
            }
            static frenchGetNameNumber(num) {
                switch (num) {
                    case 1: return "Un";
                    case 2: return "Deux";
                    case 3: return "Trois";
                    case 4: return "Quatre";
                    case 5: return "Cinq";
                    case 6: return "Six";
                    case 7: return "Sept";
                    case 8: return "Huit";
                    case 9: return "Neuf";
                    case 10: return "Dix";
                    case 11: return "Onze";
                    case 12: return "Douze";
                    case 13: return "Treize";
                    case 14: return "Quatorze";
                    case 15: return "Quinze";
                    case 16: return "Seize";
                    case 17:
                    case 18:
                    case 19: return "Dix " + this.frenchGetNameNumber(Maths.trunc(num - 10));
                    default: return "";
                }
            }
            static frenchGetNameHundred(num) {
                let rtn = "";
                let number = num;
                if (number >= 900)
                    rtn = "Neuf ";
                else if (number >= 800)
                    rtn = "Huit ";
                else if (number >= 700)
                    rtn = "Sept ";
                else if (number >= 600)
                    rtn = "Six ";
                else if (number >= 500)
                    rtn = "Cinq ";
                else if (number >= 400)
                    rtn = "Quatre ";
                else if (number >= 300)
                    rtn = "Trois ";
                else if (number >= 200)
                    rtn = "Deux ";
                else if (number >= 100)
                    rtn = "";
                if (number >= 200) {
                    rtn = rtn + "Cents";
                }
                else {
                    rtn = rtn + "Cent";
                }
                return rtn;
            }
            static frenchGetNameTens(num) {
                let number = num;
                if (number >= 90)
                    return "Quatre Vingt ";
                else if (number >= 80)
                    return "Quatre Vingt";
                else if (number >= 70)
                    return "Soixante ";
                else if (number >= 60)
                    return "Soixante";
                else if (number >= 50)
                    return "Cinquante";
                else if (number >= 40)
                    return "Quarante";
                else if (number >= 30)
                    return "Treinte";
                else
                    return "";
            }
            static frenchGetDecimal(num) {
                return cNumberToString.getDecimalAux(num, "Avec");
            }
            static englishGetNumber(num) {
                let rtn = "";
                let iTens = 0;
                let iUnit = 0;
                let iNumAux = 0;
                if (num === 100) {
                    rtn = "Hundred ";
                }
                else {
                    if (num > 100) {
                        iNumAux = num;
                        rtn = this.englishGetNameHundred(iNumAux) + " ";
                        iTens = this.getHundred(iNumAux);
                    }
                    else {
                        iTens = num;
                    }
                }
                if (iTens !== 0) {
                    if (iTens >= 1 && iTens <= 15) {
                        rtn = rtn + cNumberToString.englishGetNameNumber(iTens);
                    }
                    else {
                        if (iTens >= 16 && iTens <= 19) {
                            rtn = rtn + cNumberToString.englishGetNameNumber(Maths.trunc(iTens - 10)) + "teen";
                        }
                        else {
                            if (iTens === 20) {
                                rtn = rtn + "twenty";
                            }
                            else {
                                rtn = rtn + this.englishGetNameTens(iTens);
                                iUnit = this.getUnit(iTens);
                                rtn = rtn + " ";
                                rtn = rtn + this.englishGetNameNumber(iUnit);
                            }
                        }
                    }
                }
                return rtn;
            }
            static englishGetNameNumber(num) {
                switch (num) {
                    case 1: return "One";
                    case 2: return "Two";
                    case 3: return "Three";
                    case 4: return "Four";
                    case 5: return "Five";
                    case 6: return "Six";
                    case 7: return "Seven";
                    case 8: return "Eight";
                    case 9: return "Nine";
                    case 10: return "Ten";
                    case 11: return "Eleven";
                    case 12: return "Twelve";
                    case 13: return "Thirteen";
                    case 14: return "Fourteen";
                    case 15: return "Fifteen";
                    default: return "";
                }
            }
            static englishGetNameHundred(num) {
                return cNumberToString.englishGetNameNumber(num) + " Hundred";
            }
            static englishGetNameTens(num) {
                let number = num;
                if (number >= 90)
                    return "Ninety";
                else if (number >= 80)
                    return "Eighty";
                else if (number >= 70)
                    return "Seventy";
                else if (number >= 60)
                    return "Sixty";
                else if (number >= 50)
                    return "Fifty";
                else if (number >= 40)
                    return "Forty";
                else if (number >= 30)
                    return "Thirty";
                else if (number >= 20)
                    return "Twenty";
                else
                    return "";
            }
            static englishGetDecimal(num) {
                return cNumberToString.getDecimalAux(num, "with");
            }
            static getDecimalAux(num, word) {
                let iDecimal = 0;
                num = Maths.round(num, 2);
                iDecimal = Maths.round((num - Maths.trunc(num)) * 100, 2);
                if (iDecimal !== 0)
                    return " " + word + " " + iDecimal.toString() + "/100";
                else
                    return "";
            }
            static getUnit(iTens) {
                return iTens - (Maths.trunc(iTens / 10) * 10);
            }
            static getHundred(iHundred) {
                return iHundred - (Maths.trunc(iHundred / 100) * 100);
            }
            static getValue(num, iDividing) {
                return Maths.trunc(Maths.trunc(num) / iDividing);
            }
        }
        CSKernelNumberToString.cNumberToString = cNumberToString;
    })(CSKernelNumberToString = CSReports.CSKernelNumberToString || (CSReports.CSKernelNumberToString = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSOAPI;
    (function (CSOAPI) {
        var U = CSOAPI.Utils;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        class FormInput extends Form {
            constructor() {
                super();
                this.el = U.el('input-dlg');
                this.img = U.imageEl('input-dlg-icon');
                this.img.src = "images/dialogs/info.png";
                this.title = U.labelEl('input-dlg-title');
                this.input = U.inputEl('input-dlg-input');
                this.description = U.labelEl('input-dlg-description');
                this.dialog = new Dialog(this.el, 'input-dlg-okay');
                super.setDialog(this.dialog);
            }
            setDetails(details) {
                this.description.textContent = details;
            }
            showDialog() {
                return this.showModal();
            }
            showModal() {
                return this.dialog
                    .show({ title: this.title.textContent, height: 500, width: 800, overlay: true })
                    .then((success) => { return { success: success, value: this.input.value }; });
            }
            setTitle(title) {
                this.title.textContent = title;
            }
            setInput(input) {
                this.input.value = input;
            }
            setInputType(inputType) {
                this.input.type = inputType;
            }
        }
        CSOAPI.FormInput = FormInput;
    })(CSOAPI = CSReports.CSOAPI || (CSReports.CSOAPI = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSOAPI;
    (function (CSOAPI) {
        class List {
        }
        CSOAPI.List = List;
    })(CSOAPI = CSReports.CSOAPI || (CSReports.CSOAPI = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSConnect;
    (function (CSConnect) {
        class cColumnInfo {
            constructor() {
                this.name = "";
                this.columnType = null;
                this.position = 0;
                this.key = "";
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getColumnType() {
                return this.columnType;
            }
            setColumnType(rhs) {
                this.columnType = rhs;
            }
            getPosition() {
                return this.position;
            }
            setPosition(rhs) {
                this.position = rhs;
            }
        }
        CSConnect.cColumnInfo = cColumnInfo;
    })(CSConnect = CSReports.CSConnect || (CSReports.CSConnect = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportGlobals;
    (function (CSReportGlobals) {
        var Utils = CSReports.CSOAPI.Utils;
        var Constants = CSReports.CSDatabase.Constants;
        var ArgumentException = CSReports.CSOAPI.ArgumentException;
        class ReportGlobals {
            static getNextKey() {
                ReportGlobals.nextKey++;
                return ReportGlobals.nextKey;
            }
            static refreshNextKey(key) {
                let keyNumber = 0;
                if (Utils.isNumber(key)) {
                    keyNumber = Utils.parseInt(key);
                }
                else {
                    if (key.length > 1) {
                        if (Utils.isNumber(key.substring(1))) {
                            keyNumber = Utils.parseInt(key.substring(1));
                        }
                    }
                }
                if (ReportGlobals.nextKey < keyNumber) {
                    ReportGlobals.nextKey = keyNumber + 1;
                }
            }
            static getKey(value) {
                if (value.length > 0) {
                    if ("0123456789".contains(value.substring(0, 1))) {
                        value = "K" + value;
                    }
                }
                return value;
            }
            isDbNull(val) {
                return val === null;
            }
            static toType(obj) {
                return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
            }
            static valVariant(value) {
                if (value === null) {
                    let typeCode = this.toType(value);
                    switch (typeCode) {
                        case "string":
                            return "";
                        case "number":
                            return 0;
                        case "date":
                            return Constants.NO_DATE;
                        case "boolean":
                            return false;
                        default:
                            return null;
                    }
                }
                else {
                    return value;
                }
            }
            static dateValue(value) {
                if (value === null) {
                    return CSReports.CSDatabase.Constants.NO_DATE;
                }
                else {
                    let utcDate = Date.parse(value.toString());
                    if (!isNaN(utcDate)) {
                        return new Date(utcDate);
                    }
                    else {
                        return CSReports.CSDatabase.Constants.NO_DATE;
                    }
                }
            }
            isDate(value) {
                return !isNaN(Date.parse(value.toString()));
            }
            static format(expression, strFormat) {
                if (expression === null) {
                    return "";
                }
                else {
                    let isDate = false;
                    if (expression instanceof Date) {
                        if (expression === CSReports.CSDatabase.Constants.NO_DATE) {
                            return "";
                        }
                        isDate = true;
                    }
                    else if (typeof expression === 'string'
                        && !isNaN(Date.parse(expression))
                        && (expression.indexOf("/") > -1
                            || expression.indexOf(":") > -1
                            || "ABCDEFGHYJKNLMOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".indexOf(expression.charAt(0)) > -1)) {
                        isDate = true;
                    }
                    if (strFormat === "") {
                        return expression.toString();
                    }
                    else {
                        if (isDate) {
                            return this.formatDate(expression, strFormat);
                        }
                        else {
                            return this.formatNumber(expression, strFormat);
                        }
                    }
                }
            }
            static formatDate(value, format) {
                try {
                    const date = new Date(value);
                    const z = {
                        M: date.getMonth() + 1,
                        d: date.getDate(),
                        h: date.getHours(),
                        m: date.getMinutes(),
                        s: date.getSeconds()
                    };
                    format = format.replace(/(M+|d+|h+|m+|s+)/g, function (v) {
                        return ((v.length > 1 ? "0" : "") + z[v.slice(-1)]).slice(-2);
                    });
                    return format.replace(/(y+)/g, function (v) {
                        return date.getFullYear().toString().slice(-v.length);
                    });
                }
                catch (ex) {
                    return "error: " + ex.message;
                }
            }
            static formatNumber(value, format) {
                const validateFormat = (format) => {
                    var regExp = new RegExp("^[0#.,;+\-]*$");
                    var isValid = regExp.test(format);
                    if (isValid) {
                        if (format.indexOf(";") > -1) {
                            isValid = format.split(";").length === 2;
                        }
                    }
                    return isValid;
                };
                if (!validateFormat(format)) {
                    throw new ArgumentException("strFormat must only contain # . + - and 0. It was " + format);
                }
                const numberValue = Utils.val(value);
                if (format.indexOf(";") > -1) {
                    const vformat = format.split(";");
                    let positiveFormat;
                    let negativeFormat;
                    if (vformat[0].charAt(0) === "-") {
                        negativeFormat = vformat[0];
                        positiveFormat = vformat[1];
                    }
                    else {
                        negativeFormat = vformat[1];
                        positiveFormat = vformat[0];
                    }
                    if (numberValue < 0) {
                        return this.formatNumber(value, vformat[1]);
                    }
                    else {
                        return this.formatNumber(value, vformat[0]);
                    }
                }
                const num = numberValue.toString();
                const vformat = format.split(".");
                const integerFormat = vformat[0];
                const decimalFormat = vformat[1];
                const vnumber = num.split(".");
                let integerPart = vnumber[0];
                let decimalPart = vnumber[1];
                if (decimalFormat) {
                    decimalPart = decimalPart || '';
                    decimalPart = (decimalPart + decimalFormat).substring(0, decimalFormat.length);
                }
                let intPart = "";
                let j = -1;
                let i = -1;
                for (i = integerFormat.length - 1,
                    j = integerPart.length - 1; i > -1 && j > -1; i--) {
                    const c = integerFormat.charAt(i);
                    if (c === "#" || c === "0") {
                        intPart = integerPart[j] + intPart;
                        j--;
                    }
                    else {
                        intPart = integerFormat[i] + intPart;
                    }
                }
                if (j > -1) {
                    intPart = intPart.substring(0, j) + intPart;
                }
                if (i > -1) {
                    for (; i > -1; i--) {
                        if (integerFormat.charAt(i) !== "#") {
                            intPart = integerFormat.charAt(i) + intPart;
                        }
                    }
                }
                const start = intPart.substring(0, 2);
                if (start === '-,' || start === '+,') {
                    intPart = intPart.substring(2);
                }
                while (true) {
                    const c = intPart.charAt(0);
                    if (c === "," || c === ".") {
                        intPart = intPart.substring(1);
                    }
                    else {
                        break;
                    }
                }
                decimalPart = decimalPart !== undefined ? "." + decimalPart : "";
                if (decimalPart === '.un')
                    debugger;
                return intPart + decimalPart;
            }
            static getRealName(name) {
                let n = name.indexOf("}.");
                n = (n > -1) ? n + 2 : 0;
                return name.substring(n);
            }
        }
        ReportGlobals.KEY_INDEX_COL = "indexcol";
        ReportGlobals.KEY_INDEX_COL2 = "indexcol2";
        ReportGlobals.KEY_INDEX_GROUP = "indexgroup";
        ReportGlobals.nextKey = 1000;
        CSReportGlobals.ReportGlobals = ReportGlobals;
        let csRptControlType;
        (function (csRptControlType) {
            csRptControlType[csRptControlType["RPT_CT_LABEL"] = 1] = "RPT_CT_LABEL";
            csRptControlType[csRptControlType["RPT_CT_FIELD"] = 2] = "RPT_CT_FIELD";
            csRptControlType[csRptControlType["RPT_CT_IMAGE"] = 3] = "RPT_CT_IMAGE";
            csRptControlType[csRptControlType["RPT_CT_DB_IMAGE"] = 4] = "RPT_CT_DB_IMAGE";
            csRptControlType[csRptControlType["RPT_CT_CHART"] = 5] = "RPT_CT_CHART";
        })(csRptControlType = CSReportGlobals.csRptControlType || (CSReportGlobals.csRptControlType = {}));
        let csRptSectionType;
        (function (csRptSectionType) {
            csRptSectionType[csRptSectionType["HEADER"] = 0] = "HEADER";
            csRptSectionType[csRptSectionType["DETAIL"] = 1] = "DETAIL";
            csRptSectionType[csRptSectionType["FOOTER"] = 2] = "FOOTER";
            csRptSectionType[csRptSectionType["GROUP_HEADER"] = 3] = "GROUP_HEADER";
            csRptSectionType[csRptSectionType["GROUP_FOOTER"] = 4] = "GROUP_FOOTER";
            csRptSectionType[csRptSectionType["MAIN_HEADER"] = 100] = "MAIN_HEADER";
            csRptSectionType[csRptSectionType["MAIN_DETAIL"] = 101] = "MAIN_DETAIL";
            csRptSectionType[csRptSectionType["MAIN_FOOTER"] = 102] = "MAIN_FOOTER";
            csRptSectionType[csRptSectionType["CONTROL"] = 50] = "CONTROL";
            csRptSectionType[csRptSectionType["SECLN_HEADER"] = 1000] = "SECLN_HEADER";
            csRptSectionType[csRptSectionType["SECLN_DETAIL"] = 1001] = "SECLN_DETAIL";
            csRptSectionType[csRptSectionType["SECLN_FOOTER"] = 1002] = "SECLN_FOOTER";
            csRptSectionType[csRptSectionType["SECLN_GROUPH"] = 1003] = "SECLN_GROUPH";
            csRptSectionType[csRptSectionType["SECLN_GROUPF"] = 1004] = "SECLN_GROUPF";
        })(csRptSectionType = CSReportGlobals.csRptSectionType || (CSReportGlobals.csRptSectionType = {}));
        let csRptLaunchAction;
        (function (csRptLaunchAction) {
            csRptLaunchAction[csRptLaunchAction["CS_RPT_LAUNCH_PRINTER"] = 0] = "CS_RPT_LAUNCH_PRINTER";
            csRptLaunchAction[csRptLaunchAction["CS_RPT_LAUNCH_FILE"] = 1] = "CS_RPT_LAUNCH_FILE";
            csRptLaunchAction[csRptLaunchAction["CS_RPT_LAUNCH_PREVIEW"] = 2] = "CS_RPT_LAUNCH_PREVIEW";
        })(csRptLaunchAction = CSReportGlobals.csRptLaunchAction || (CSReportGlobals.csRptLaunchAction = {}));
        let csRptWhenEval;
        (function (csRptWhenEval) {
            csRptWhenEval[csRptWhenEval["CS_RPT_EVAL_PRE"] = 0] = "CS_RPT_EVAL_PRE";
            csRptWhenEval[csRptWhenEval["CS_RPT_EVAL_POST"] = 1] = "CS_RPT_EVAL_POST";
        })(csRptWhenEval = CSReportGlobals.csRptWhenEval || (CSReportGlobals.csRptWhenEval = {}));
        let csDataSourceType;
        (function (csDataSourceType) {
            csDataSourceType[csDataSourceType["CS_DT_TABLE"] = 1] = "CS_DT_TABLE";
            csDataSourceType[csDataSourceType["CS_DT_PROCEDURE"] = 2] = "CS_DT_PROCEDURE";
        })(csDataSourceType = CSReportGlobals.csDataSourceType || (CSReportGlobals.csDataSourceType = {}));
        let csRptErrors;
        (function (csRptErrors) {
            csRptErrors[csRptErrors["LAUNCH_INFO_UNDEFINED"] = 1001] = "LAUNCH_INFO_UNDEFINED";
            csRptErrors[csRptErrors["SYNTAX_ERROR_MISSING_BRACKETS"] = 1002] = "SYNTAX_ERROR_MISSING_BRACKETS";
            csRptErrors[csRptErrors["CS_RPT_ERR_UNDEFINED_FUNCTION"] = 1003] = "CS_RPT_ERR_UNDEFINED_FUNCTION";
            csRptErrors[csRptErrors["CS_RPT_ERR_MISSING_PARAM"] = 1004] = "CS_RPT_ERR_MISSING_PARAM";
            csRptErrors[csRptErrors["CONTROL_NOT_FOUND"] = 1005] = "CONTROL_NOT_FOUND";
            csRptErrors[csRptErrors["GROUP_NOT_FOUND"] = 1006] = "GROUP_NOT_FOUND";
            csRptErrors[csRptErrors["FIELD_NOT_FOUND"] = 1007] = "FIELD_NOT_FOUND";
            csRptErrors[csRptErrors["CS_RPT_ERR_VAR_NOT_DEFINED"] = 1008] = "CS_RPT_ERR_VAR_NOT_DEFINED";
            csRptErrors[csRptErrors["PRINTER_NOT_DEFINED"] = 1009] = "PRINTER_NOT_DEFINED";
            csRptErrors[csRptErrors["GROUP_NOT_FOUND_IN_MAIN_RS"] = 1010] = "GROUP_NOT_FOUND_IN_MAIN_RS";
            csRptErrors[csRptErrors["CS_RPT_ERR_PARAM_NOT_DEFINED"] = 1011] = "CS_RPT_ERR_PARAM_NOT_DEFINED";
            csRptErrors[csRptErrors["ERROR_IN_SCRIPT"] = 1012] = "ERROR_IN_SCRIPT";
            csRptErrors[csRptErrors["ERROR_WHEN_RUNNING_REPORT"] = 1013] = "ERROR_WHEN_RUNNING_REPORT";
        })(csRptErrors = CSReportGlobals.csRptErrors || (CSReportGlobals.csRptErrors = {}));
        let csReportPaperType;
        (function (csReportPaperType) {
            csReportPaperType[csReportPaperType["CS_RPT_PAPER_TYPE_A4"] = 9] = "CS_RPT_PAPER_TYPE_A4";
            csReportPaperType[csReportPaperType["CS_RPT_PAPER_TYPE_A3"] = 8] = "CS_RPT_PAPER_TYPE_A3";
            csReportPaperType[csReportPaperType["CS_RPT_PAPER_TYPE_LETTER"] = 1] = "CS_RPT_PAPER_TYPE_LETTER";
            csReportPaperType[csReportPaperType["CS_RPT_PAPER_TYPE_LEGAL"] = 5] = "CS_RPT_PAPER_TYPE_LEGAL";
            csReportPaperType[csReportPaperType["CS_RPT_PAPER_NOT_SUPPORTED"] = 0] = "CS_RPT_PAPER_NOT_SUPPORTED";
            csReportPaperType[csReportPaperType["CS_RPT_PAPER_USER"] = 99] = "CS_RPT_PAPER_USER";
        })(csReportPaperType = CSReportGlobals.csReportPaperType || (CSReportGlobals.csReportPaperType = {}));
        let RptGrpOrderType;
        (function (RptGrpOrderType) {
            RptGrpOrderType[RptGrpOrderType["CS_RPT_GRP_ASC"] = 1] = "CS_RPT_GRP_ASC";
            RptGrpOrderType[RptGrpOrderType["CS_RPT_GRP_DESC"] = 2] = "CS_RPT_GRP_DESC";
        })(RptGrpOrderType = CSReportGlobals.RptGrpOrderType || (CSReportGlobals.RptGrpOrderType = {}));
        let RptGrpComparisonType;
        (function (RptGrpComparisonType) {
            RptGrpComparisonType[RptGrpComparisonType["CS_RPT_GRP_TEXT"] = 1] = "CS_RPT_GRP_TEXT";
            RptGrpComparisonType[RptGrpComparisonType["CS_RPT_GRP_NUMBER"] = 2] = "CS_RPT_GRP_NUMBER";
            RptGrpComparisonType[RptGrpComparisonType["CS_RPT_GRP_DATE"] = 3] = "CS_RPT_GRP_DATE";
        })(RptGrpComparisonType = CSReportGlobals.RptGrpComparisonType || (CSReportGlobals.RptGrpComparisonType = {}));
        let csRptFormulaType;
        (function (csRptFormulaType) {
            csRptFormulaType[csRptFormulaType["CSRPTF_NONE"] = 0] = "CSRPTF_NONE";
            csRptFormulaType[csRptFormulaType["CSRPTF_PAGE_NUMBER"] = 10001] = "CSRPTF_PAGE_NUMBER";
            csRptFormulaType[csRptFormulaType["CSRPTF_TOTAL_PAGES"] = 10002] = "CSRPTF_TOTAL_PAGES";
            csRptFormulaType[csRptFormulaType["CSRPTF_AVERAGE"] = 10003] = "CSRPTF_AVERAGE";
            csRptFormulaType[csRptFormulaType["CSRPTF_SUM"] = 10004] = "CSRPTF_SUM";
            csRptFormulaType[csRptFormulaType["CSRPTF_MAX"] = 10005] = "CSRPTF_MAX";
            csRptFormulaType[csRptFormulaType["CSRPTF_MIN"] = 10006] = "CSRPTF_MIN";
            csRptFormulaType[csRptFormulaType["CSRPTF_COUNT"] = 10007] = "CSRPTF_COUNT";
            csRptFormulaType[csRptFormulaType["CSRPTF_LENGTH"] = 10008] = "CSRPTF_LENGTH";
            csRptFormulaType[csRptFormulaType["CSRPTF_CALCULATE"] = 10009] = "CSRPTF_CALCULATE";
            csRptFormulaType[csRptFormulaType["CSRPTF_SUM_TIME"] = 10010] = "CSRPTF_SUM_TIME";
            csRptFormulaType[csRptFormulaType["CSRPTF_GET_STRING"] = 10011] = "CSRPTF_GET_STRING";
            csRptFormulaType[csRptFormulaType["CSRPTF_NUMBER_TO_STRING"] = 10012] = "CSRPTF_NUMBER_TO_STRING";
            csRptFormulaType[csRptFormulaType["CSRPTF_VAL"] = 1010] = "CSRPTF_VAL";
            csRptFormulaType[csRptFormulaType["CSRPTF_DECLARE_VAR"] = 10013] = "CSRPTF_DECLARE_VAR";
            csRptFormulaType[csRptFormulaType["CSRPTF_GET_VAR"] = 10014] = "CSRPTF_GET_VAR";
            csRptFormulaType[csRptFormulaType["CSRPTF_ADD_TO_VAR"] = 10015] = "CSRPTF_ADD_TO_VAR";
            csRptFormulaType[csRptFormulaType["CSRPTF_SET_VAR"] = 10016] = "CSRPTF_SET_VAR";
            csRptFormulaType[csRptFormulaType["CSRPTF_GET_DATA_FROM_RS_AD"] = 10017] = "CSRPTF_GET_DATA_FROM_RS_AD";
            csRptFormulaType[csRptFormulaType["CSRPTF_GET_PARAM"] = 10018] = "CSRPTF_GET_PARAM";
            csRptFormulaType[csRptFormulaType["CSRPTF_IS_EQUAL"] = 10019] = "CSRPTF_IS_EQUAL";
            csRptFormulaType[csRptFormulaType["CSRPTF_IS_NOT_EQUAL"] = 10020] = "CSRPTF_IS_NOT_EQUAL";
            csRptFormulaType[csRptFormulaType["CSRPTF_IS_GREATER_THAN"] = 10021] = "CSRPTF_IS_GREATER_THAN";
            csRptFormulaType[csRptFormulaType["CSRPTF_IS_LESS_THAN"] = 10022] = "CSRPTF_IS_LESS_THAN";
            csRptFormulaType[csRptFormulaType["CSRPTF_GET_DATA_FROM_RS"] = 10023] = "CSRPTF_GET_DATA_FROM_RS";
            csRptFormulaType[csRptFormulaType["CSRPTF_GROUP_TOTAL"] = 10024] = "CSRPTF_GROUP_TOTAL";
            csRptFormulaType[csRptFormulaType["CSRPTF_GROUP_MAX"] = 10025] = "CSRPTF_GROUP_MAX";
            csRptFormulaType[csRptFormulaType["CSRPTF_GROUP_MIN"] = 10026] = "CSRPTF_GROUP_MIN";
            csRptFormulaType[csRptFormulaType["CSRPTF_GROUP_AVERAGE"] = 10027] = "CSRPTF_GROUP_AVERAGE";
            csRptFormulaType[csRptFormulaType["CSRPTF_GROUP_PERCENT"] = 10028] = "CSRPTF_GROUP_PERCENT";
            csRptFormulaType[csRptFormulaType["CSRPTF_GROUP_COUNT"] = 10029] = "CSRPTF_GROUP_COUNT";
            csRptFormulaType[csRptFormulaType["CSRPTF_GROUP_LINE_NUMBER"] = 10030] = "CSRPTF_GROUP_LINE_NUMBER";
            csRptFormulaType[csRptFormulaType["CSRPTF_IS_IN_RS"] = 10031] = "CSRPTF_IS_IN_RS";
            csRptFormulaType[csRptFormulaType["CSRPTF_TEXT_REPLACE"] = 10032] = "CSRPTF_TEXT_REPLACE";
            csRptFormulaType[csRptFormulaType["CSRPTF_GET_BARCODE"] = 10033] = "CSRPTF_GET_BARCODE";
        })(csRptFormulaType = CSReportGlobals.csRptFormulaType || (CSReportGlobals.csRptFormulaType = {}));
        let csRptFileFormat;
        (function (csRptFileFormat) {
            csRptFileFormat[csRptFileFormat["CS_RPT_EXPORT_HTML"] = 0] = "CS_RPT_EXPORT_HTML";
            csRptFileFormat[csRptFileFormat["CS_RPT_EXPORT_EXCEL"] = 1] = "CS_RPT_EXPORT_EXCEL";
            csRptFileFormat[csRptFileFormat["CS_RPT_EXPORT_WORD"] = 2] = "CS_RPT_EXPORT_WORD";
            csRptFileFormat[csRptFileFormat["CS_RPT_EXPORT_TXT"] = 3] = "CS_RPT_EXPORT_TXT";
            csRptFileFormat[csRptFileFormat["CS_RPT_EXPORT_TXT_TAB"] = 4] = "CS_RPT_EXPORT_TXT_TAB";
            csRptFileFormat[csRptFileFormat["CS_RPT_EXPORT_XML"] = 5] = "CS_RPT_EXPORT_XML";
        })(csRptFileFormat = CSReportGlobals.csRptFileFormat || (CSReportGlobals.csRptFileFormat = {}));
        let HorizontalAlignment;
        (function (HorizontalAlignment) {
            HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
            HorizontalAlignment[HorizontalAlignment["Right"] = 1] = "Right";
            HorizontalAlignment[HorizontalAlignment["Center"] = 2] = "Center";
        })(HorizontalAlignment = CSReportGlobals.HorizontalAlignment || (CSReportGlobals.HorizontalAlignment = {}));
        let csReportBorderType;
        (function (csReportBorderType) {
            csReportBorderType[csReportBorderType["CS_RPT_BS_NONE"] = 0] = "CS_RPT_BS_NONE";
            csReportBorderType[csReportBorderType["CS_RPT_BS_FIXED"] = 1] = "CS_RPT_BS_FIXED";
            csReportBorderType[csReportBorderType["CS_RPT_BS_3D"] = 2] = "CS_RPT_BS_3D";
        })(csReportBorderType = CSReportGlobals.csReportBorderType || (CSReportGlobals.csReportBorderType = {}));
        let csRptGetLineResult;
        (function (csRptGetLineResult) {
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_NONE"] = 0] = "CS_RPT_GL_NONE";
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_DETAIL"] = 1] = "CS_RPT_GL_DETAIL";
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_GROUP_HEADER"] = 2] = "CS_RPT_GL_GROUP_HEADER";
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_GROUP_FOOTER"] = 3] = "CS_RPT_GL_GROUP_FOOTER";
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_END"] = 4] = "CS_RPT_GL_END";
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_NEW_PAGE"] = 5] = "CS_RPT_GL_NEW_PAGE";
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_VIRTUAL_H"] = 6] = "CS_RPT_GL_VIRTUAL_H";
            csRptGetLineResult[csRptGetLineResult["CS_RPT_GL_VIRTUAL_F"] = 7] = "CS_RPT_GL_VIRTUAL_F";
        })(csRptGetLineResult = CSReportGlobals.csRptGetLineResult || (CSReportGlobals.csRptGetLineResult = {}));
        let csRptNewPageResult;
        (function (csRptNewPageResult) {
            csRptNewPageResult[csRptNewPageResult["CS_RPT_NP_ERROR"] = 1] = "CS_RPT_NP_ERROR";
            csRptNewPageResult[csRptNewPageResult["CS_RPT_NP_SUCCESS"] = 2] = "CS_RPT_NP_SUCCESS";
            csRptNewPageResult[csRptNewPageResult["CS_RPT_NP_END"] = 3] = "CS_RPT_NP_END";
        })(csRptNewPageResult = CSReportGlobals.csRptNewPageResult || (CSReportGlobals.csRptNewPageResult = {}));
        let csRptEndPageResult;
        (function (csRptEndPageResult) {
            csRptEndPageResult[csRptEndPageResult["CS_RPT_EP_ERROR"] = 1] = "CS_RPT_EP_ERROR";
            csRptEndPageResult[csRptEndPageResult["CS_RPT_EP_SUCCESS"] = 2] = "CS_RPT_EP_SUCCESS";
        })(csRptEndPageResult = CSReportGlobals.csRptEndPageResult || (CSReportGlobals.csRptEndPageResult = {}));
        let csRptChartLineStyle;
        (function (csRptChartLineStyle) {
            csRptChartLineStyle[csRptChartLineStyle["NONE"] = 0] = "NONE";
            csRptChartLineStyle[csRptChartLineStyle["HORIZONTAL"] = 1] = "HORIZONTAL";
            csRptChartLineStyle[csRptChartLineStyle["NUMBERED"] = 2] = "NUMBERED";
            csRptChartLineStyle[csRptChartLineStyle["BOTH"] = 3] = "BOTH";
        })(csRptChartLineStyle = CSReportGlobals.csRptChartLineStyle || (CSReportGlobals.csRptChartLineStyle = {}));
        let csRptChartPieThickness;
        (function (csRptChartPieThickness) {
            csRptChartPieThickness[csRptChartPieThickness["NONE"] = 0] = "NONE";
            csRptChartPieThickness[csRptChartPieThickness["WAFER"] = 2] = "WAFER";
            csRptChartPieThickness[csRptChartPieThickness["THIN"] = 4] = "THIN";
            csRptChartPieThickness[csRptChartPieThickness["MEDIUM"] = 8] = "MEDIUM";
            csRptChartPieThickness[csRptChartPieThickness["THICK"] = 16] = "THICK";
            csRptChartPieThickness[csRptChartPieThickness["THICKEST"] = 32] = "THICKEST";
        })(csRptChartPieThickness = CSReportGlobals.csRptChartPieThickness || (CSReportGlobals.csRptChartPieThickness = {}));
        let csRptChartPieDiameter;
        (function (csRptChartPieDiameter) {
            csRptChartPieDiameter[csRptChartPieDiameter["SMALLEST"] = 50] = "SMALLEST";
            csRptChartPieDiameter[csRptChartPieDiameter["SMALLER"] = 100] = "SMALLER";
            csRptChartPieDiameter[csRptChartPieDiameter["SMALL"] = 150] = "SMALL";
            csRptChartPieDiameter[csRptChartPieDiameter["MEDIUM"] = 200] = "MEDIUM";
            csRptChartPieDiameter[csRptChartPieDiameter["LARGE"] = 250] = "LARGE";
            csRptChartPieDiameter[csRptChartPieDiameter["LARGER"] = 350] = "LARGER";
            csRptChartPieDiameter[csRptChartPieDiameter["LARGEST"] = 450] = "LARGEST";
        })(csRptChartPieDiameter = CSReportGlobals.csRptChartPieDiameter || (CSReportGlobals.csRptChartPieDiameter = {}));
        let csRptChartFormat;
        (function (csRptChartFormat) {
            csRptChartFormat[csRptChartFormat["GIF"] = 0] = "GIF";
            csRptChartFormat[csRptChartFormat["JPEG"] = 1] = "JPEG";
            csRptChartFormat[csRptChartFormat["PNG"] = 2] = "PNG";
            csRptChartFormat[csRptChartFormat["BMP"] = 3] = "BMP";
        })(csRptChartFormat = CSReportGlobals.csRptChartFormat || (CSReportGlobals.csRptChartFormat = {}));
        let csRptChartType;
        (function (csRptChartType) {
            csRptChartType[csRptChartType["PIE"] = 0] = "PIE";
            csRptChartType[csRptChartType["BAR"] = 1] = "BAR";
        })(csRptChartType = CSReportGlobals.csRptChartType || (CSReportGlobals.csRptChartType = {}));
        let csEZoom;
        (function (csEZoom) {
            csEZoom[csEZoom["csEZoomCustom"] = -1] = "csEZoomCustom";
            csEZoom[csEZoom["csEZoomAllPage"] = -2] = "csEZoomAllPage";
            csEZoom[csEZoom["csEZoomWidth"] = -3] = "csEZoomWidth";
        })(csEZoom = CSReportGlobals.csEZoom || (CSReportGlobals.csEZoom = {}));
        let csEAlignConst;
        (function (csEAlignConst) {
            csEAlignConst[csEAlignConst["csEAlignTextLeft"] = 1] = "csEAlignTextLeft";
            csEAlignConst[csEAlignConst["csEAlignTextRight"] = 2] = "csEAlignTextRight";
            csEAlignConst[csEAlignConst["csEAlignTextCenter"] = 3] = "csEAlignTextCenter";
            csEAlignConst[csEAlignConst["csEAlignCtlLeft"] = 4] = "csEAlignCtlLeft";
            csEAlignConst[csEAlignConst["csEAlignCtlHorizontal"] = 5] = "csEAlignCtlHorizontal";
            csEAlignConst[csEAlignConst["csEAlignCtlRight"] = 6] = "csEAlignCtlRight";
            csEAlignConst[csEAlignConst["csEAlignCtlVertical"] = 7] = "csEAlignCtlVertical";
            csEAlignConst[csEAlignConst["csEAlignCtlTop"] = 8] = "csEAlignCtlTop";
            csEAlignConst[csEAlignConst["csEAlignCtlBottom"] = 9] = "csEAlignCtlBottom";
            csEAlignConst[csEAlignConst["csEAlignCtlWidth"] = 10] = "csEAlignCtlWidth";
            csEAlignConst[csEAlignConst["csEAlignCtlHeight"] = 11] = "csEAlignCtlHeight";
        })(csEAlignConst = CSReportGlobals.csEAlignConst || (CSReportGlobals.csEAlignConst = {}));
        let csECtlAlignConst;
        (function (csECtlAlignConst) {
            csECtlAlignConst[csECtlAlignConst["csECtlAlignLeft"] = 4] = "csECtlAlignLeft";
            csECtlAlignConst[csECtlAlignConst["csECtlAlignHorizontal"] = 5] = "csECtlAlignHorizontal";
            csECtlAlignConst[csECtlAlignConst["csECtlAlignRight"] = 6] = "csECtlAlignRight";
            csECtlAlignConst[csECtlAlignConst["csECtlAlignVertical"] = 7] = "csECtlAlignVertical";
            csECtlAlignConst[csECtlAlignConst["csECtlAlignTop"] = 8] = "csECtlAlignTop";
            csECtlAlignConst[csECtlAlignConst["csECtlAlignBottom"] = 9] = "csECtlAlignBottom";
            csECtlAlignConst[csECtlAlignConst["csECtlAlignWidth"] = 10] = "csECtlAlignWidth";
            csECtlAlignConst[csECtlAlignConst["csECtlAlignHeight"] = 11] = "csECtlAlignHeight";
        })(csECtlAlignConst = CSReportGlobals.csECtlAlignConst || (CSReportGlobals.csECtlAlignConst = {}));
        let csRptPageOrientation;
        (function (csRptPageOrientation) {
            csRptPageOrientation[csRptPageOrientation["PORTRAIT"] = 1] = "PORTRAIT";
            csRptPageOrientation[csRptPageOrientation["LANDSCAPE"] = 2] = "LANDSCAPE";
        })(csRptPageOrientation = CSReportGlobals.csRptPageOrientation || (CSReportGlobals.csRptPageOrientation = {}));
    })(CSReportGlobals = CSReports.CSReportGlobals || (CSReports.CSReportGlobals = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSConnect;
    (function (CSConnect) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cColumnsInfo extends Map {
            constructor() {
                super(null, false, CSConnect.cColumnInfo);
            }
            add(c, key) {
                try {
                    if (c === null) {
                        c = new CSConnect.cColumnInfo();
                    }
                    if (key === "") {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
        }
        CSConnect.cColumnsInfo = cColumnsInfo;
    })(CSConnect = CSReports.CSConnect || (CSReports.CSConnect = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSConnect;
    (function (CSConnect) {
        var P = CSReports.CSKernelClient.Callable;
        var DatabaseGlobals = CSReports.CSDatabase.DatabaseGlobals;
        class cConnect {
            constructor() {
                this.parameters = new CSConnect.cParameters();
                this.columnsInfo = new CSConnect.cColumnsInfo();
                this.strConnect = "";
                this.dataSource = "";
                this.dataSourceType = null;
            }
            getParameters() {
                return this.parameters;
            }
            getColumnsInfo() {
                return this.columnsInfo;
            }
            getDataSourceColumnsInfo(serverConnection) {
                return serverConnection.getDataSourceInfo(this.dataSource).then(P.call(this, (dataSource) => {
                    if (dataSource !== undefined) {
                        if (cConnect.f === null)
                            cConnect.f = new CSConnect.fParameters();
                        dataSource.params.forEach(p => {
                            const p2 = this.parameters.getValues().find(p2 => p2.getName() === p.name);
                            if (p2 !== undefined)
                                p.value = p2.getValue();
                        });
                        cConnect.f.initDialog(dataSource.params);
                        return cConnect.f.showModal().then(P.call(this, (result) => {
                            if (result.success) {
                                return serverConnection.excute(this.dataSource, result.params).then(P.call(this, (dataSource) => {
                                    if (dataSource) {
                                        this.updateParamsAndColumns(result.params, dataSource);
                                        return { success: true, dataSource: dataSource };
                                    }
                                    else {
                                        return { success: false, dataSource: null };
                                    }
                                }));
                            }
                            else
                                return { success: false, dataSource: null };
                        }));
                    }
                    return { success: false, dataSource: null };
                }));
            }
            updateParamsAndColumns(params, dataSource) {
                const columns = dataSource.recordset.columns;
                for (let i = 0; i < columns.length; i++) {
                    const column = new CSConnect.cColumnInfo();
                    column.setName(columns[i].name);
                    column.setPosition(i);
                    column.setColumnType(DatabaseGlobals.getDataTypeFromString(columns[i].columnType));
                    this.columnsInfo.add(column, "");
                }
                this.parameters.clear();
                for (let i = 0; i < params.length; i++) {
                    const param = this.parameters.add(null, "");
                    param.setValue(params[i].value);
                    param.setColumnType(DatabaseGlobals.getDataTypeFromString(params[i].type));
                    param.setPosition(i + 1);
                    param.setName(params[i].name);
                }
            }
            setStrConnect(strConnect) {
                this.strConnect = strConnect;
            }
            setDataSource(dataSource) {
                this.dataSource = dataSource;
            }
            setDataSourceType(dataSourceType) {
                this.dataSourceType = dataSourceType;
            }
            getDataSource() {
                return this.dataSource;
            }
            getDataSourceType() {
                return this.dataSourceType;
            }
        }
        cConnect.f = null;
        CSConnect.cConnect = cConnect;
    })(CSConnect = CSReports.CSConnect || (CSReports.CSConnect = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSConnect;
    (function (CSConnect) {
        class cParameter {
            constructor() {
                this.name = "";
                this.columnType = null;
                this.value = "";
                this.position = 0;
                this.key = "";
                this.hasDefault = null;
                this.default = "";
                this.isNullable = true;
                this.maxLength = 0;
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getColumnType() {
                return this.columnType;
            }
            setColumnType(rhs) {
                this.columnType = rhs;
            }
            getValue() {
                return this.value;
            }
            setValue(rhs) {
                this.value = rhs;
            }
            getPosition() {
                return this.position;
            }
            setPosition(rhs) {
                this.position = rhs;
            }
            getHasDefault() {
                return this.hasDefault;
            }
            setHasDefault(rhs) {
                this.hasDefault = rhs;
            }
            getDefaultValue() {
                return this.default;
            }
            setDefaultValue(rhs) {
                this.default = rhs;
            }
            getIsNullable() {
                return this.isNullable;
            }
            setIsNullable(rhs) {
                this.isNullable = rhs;
            }
            getMaxLength() {
                return this.maxLength;
            }
            setMaxLength(rhs) {
                this.maxLength = rhs;
            }
        }
        CSConnect.cParameter = cParameter;
    })(CSConnect = CSReports.CSConnect || (CSReports.CSConnect = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSConnect;
    (function (CSConnect) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cParameters extends Map {
            constructor() {
                super(null, false, CSConnect.cParameter);
            }
            add(c, key) {
                try {
                    if (c === null) {
                        c = new CSConnect.cParameter();
                    }
                    if (key === "") {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
        }
        CSConnect.cParameters = cParameters;
    })(CSConnect = CSReports.CSConnect || (CSReports.CSConnect = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSConnect;
    (function (CSConnect) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        class fParameters extends Form {
            constructor() {
                super();
                this.el = U.el('params-dlg');
                this.dialog = new Dialog(this.el, 'params-dlg-apply', 'params-dlg-cancel');
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                super.setDialog(this.dialog);
            }
            initDialog(parameters) {
                this.parameters = parameters;
                const container = U.divEl("params-params-section");
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                this.paramInputs = [];
                parameters.forEach(P.call(this, p => {
                    const div = document.createElement('div');
                    div.className = 'row';
                    const div2 = document.createElement('div');
                    div2.style.marginTop = '20px';
                    const label = document.createElement('label');
                    label.textContent = p.name;
                    div2.appendChild(label);
                    const input = document.createElement('input');
                    input.value = p.value || '';
                    input.type = 'text';
                    div2.appendChild(input);
                    div.appendChild(div2);
                    container.appendChild(div);
                    this.paramInputs.push(input);
                }));
            }
            cmdApplyClick() {
                for (let i = 0; i < this.paramInputs.length; i++) {
                    this.parameters[i].value = this.paramInputs[i].value;
                }
                return true;
            }
            showModal() {
                return this.dialog.show({ title: 'Connection Settings', height: 600, width: 500, overlay: true })
                    .then(P.call(this, (result) => {
                    if (result)
                        return {
                            success: true,
                            params: this.parameters
                        };
                    else
                        return {
                            success: false
                        };
                }));
            }
        }
        CSConnect.fParameters = fParameters;
    })(CSConnect = CSReports.CSConnect || (CSReports.CSConnect = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportBarcode;
    (function (CSReportBarcode) {
        class cReportBarcode {
            encodeTo128(dataToEncode) {
                return dataToEncode;
            }
            code128a(dataToEncode) {
                return dataToEncode;
            }
        }
        CSReportBarcode.cReportBarcode = cReportBarcode;
    })(CSReportBarcode = CSReports.CSReportBarcode || (CSReports.CSReportBarcode = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var P = CSReports.CSKernelClient.Callable;
        class PreviewTab {
            close() {
                return P._();
            }
            constructor(fMain, reportPreview, previewTab) {
            }
            isEditor() {
                return false;
            }
            keyUp(sender, e) { }
            keyDown(sender, e) { }
        }
        CSReportEditor.PreviewTab = PreviewTab;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        var P = CSReports.CSKernelClient.Callable;
        var Color = CSReports.CSDrawing.Color;
        var csRptChartType = CSReports.CSReportGlobals.csRptChartType;
        var csRptChartLineStyle = CSReports.CSReportGlobals.csRptChartLineStyle;
        var Label = CSReports.CSForms.Label;
        var TextBox = CSReports.CSForms.TextBox;
        var CheckBox = CSReports.CSForms.CheckBox;
        var Button = CSReports.CSForms.Button;
        var OptionButton = CSReports.CSForms.OptionButton;
        var ComboBox = CSReports.CSForms.ComboBox;
        var PictureBox = CSReports.CSForms.PictureBox;
        class PropertyDlg {
            constructor() {
                this.index = 0;
                this.fieldType = 0;
                this.formulaHide = "";
                this.formulaValue = "";
                this.sectionFormulaHide = "";
                this.sectionLineFormulaHide = "";
                this.formulaName = "";
                this.isAccounting = null;
                this.textChanged = null;
                this.tagChanged = null;
                this.fontChanged = null;
                this.foreColorChanged = null;
                this.backColorChanged = null;
                this.formatChanged = null;
                this.leftChanged = null;
                this.topChanged = null;
                this.heightChanged = null;
                this.widthChanged = null;
                this.symbolChanged = null;
                this.transparentChanged = null;
                this.strikeChanged = null;
                this.underlineChanged = null;
                this.wordWrapChanged = null;
                this.italicChanged = null;
                this.boldChanged = null;
                this.alignChanged = null;
                this.fontSizeChanged = null;
                this.canGrowChanged = null;
                this.formulaHideChanged = null;
                this.formulaValueChanged = null;
                this.bSetFormulaHideChanged = null;
                this.bSetFormulaValueChanged = null;
                this.idxGroupChanged = null;
                this.whenEvalChanged = null;
                this.dbFieldChanged = null;
                this.pictureChanged = null;
                this.borderTypeChanged = null;
                this.border3DChanged = null;
                this.border3DShadowChanged = null;
                this.borderRoundedChanged = null;
                this.borderWidthChanged = null;
                this.borderColorChanged = null;
                this.chartFieldVal1Changed = null;
                this.chartFieldVal2Changed = null;
                this.chartFieldLbl1Changed = null;
                this.chartFieldLbl2Changed = null;
                this.chartSizeChanged = null;
                this.chartThicknessChanged = null;
                this.chartColorSerie1Changed = null;
                this.chartColorSerie2Changed = null;
                this.chartLinesTypeChanged = null;
                this.chartTypeChanged = null;
                this.chartShowLinesChanged = null;
                this.chartShowValuesChanged = null;
                this.chartTopChanged = null;
                this.chartSortChanged = null;
                this.chartFieldGroupChanged = null;
                this.chartGroupValueChanged = null;
                this.isFreeCtrlChanged = null;
                this.exportColIdxChanged = null;
                this.chartIndex = [];
                this.chartFieldType = [];
                this.chartGroupIndex = 0;
                this.chartGroupFieldType = 0;
                this.sectionFormulaHideChanged = null;
                this.sectionLineFormulaHideChanged = null;
                this.bSetSectionFormulaHideChanged = null;
                this.bSetSectionLineFormulaHideChanged = null;
                this.formulaDlg = new CSReportEditor.FFormula();
                this.currentTab = null;
                this.lbControl = new Label(U.labelEl('ctrl-lb-name'));
                this.txName = new TextBox(U.inputEl('ctrl-name'));
                this.txText = new TextBox(U.inputEl('ctrl-text'));
                this.txTag = new TextBox(U.inputEl('ctrl-tag'));
                this.cbFont = new ComboBox(U.selectEl('ctrl-font'));
                this.txFontSize = new TextBox(U.inputEl('ctrl-font-size'));
                this.cbAlign = new ComboBox(U.selectEl('ctrl-align'));
                this.chkFontBold = new CheckBox(U.inputEl('ctrl-bold'));
                this.chkFontUnderline = new CheckBox(U.inputEl('ctrl-underline'));
                this.chkFontItalic = new CheckBox(U.inputEl('ctrl-italic'));
                this.chkFontStrike = new CheckBox(U.inputEl('ctrl-strike'));
                this.txForeColor = new TextBox(U.inputEl('ctrl-text-color'));
                this.shForeColor = new Label(U.labelEl('ctrl-text-color-sample'));
                this.chkTransparent = new CheckBox(U.inputEl('ctrl-transparent'));
                this.txBackColor = new TextBox(U.inputEl('ctrl-back-color'));
                this.shBackColor = new Label(U.labelEl('ctrl-back-color-sample'));
                this.txSymbol = new TextBox(U.inputEl('ctrl-symbol'));
                this.txFormat = new TextBox(U.inputEl('ctrl-format'));
                this.txLeft = new TextBox(U.inputEl('ctrl-left'));
                this.txTop = new TextBox(U.inputEl('ctrl-top'));
                this.txWidth = new TextBox(U.inputEl('ctrl-width'));
                this.txHeight = new TextBox(U.inputEl('ctrl-height'));
                this.chkCanGrow = new CheckBox(U.inputEl('ctrl-can-grow'));
                this.chkWordWrap = new CheckBox(U.inputEl('ctrl-wrap-text'));
                this.chkIsFreeCtrl = new CheckBox(U.inputEl('ctrl-is-in-background'));
                this.txExportColIdx = new TextBox(U.inputEl('ctrl-export-id'));
                this.chkFormulaHide = new CheckBox(U.inputEl('ctrl-has-visible-formula'));
                this.lbFormulaHide = new Label(U.labelEl('ctrl-visible-formula'));
                this.cmdFormulaHide = new Button(U.el('ctrl-hide-formula-edit'));
                this.chkFormulaValue = new CheckBox(U.inputEl('ctrl-has-value-formula'));
                this.lbFormulaValue = new Label(U.labelEl('ctrl-value-formula'));
                this.cmdFormulaValue = new Button(U.el('ctrl-value-formula-edit'));
                this.txIdxGroup = new TextBox(U.inputEl('ctrl-formula-group'));
                this.opBeforePrint = new OptionButton(U.inputEl('ctrl-formula-run-before'));
                this.opAfterPrint = new OptionButton(U.inputEl('ctrl-formula-run-after'));
                this.txImageFile = new TextBox(U.inputEl('ctrl-image-file'));
                this.picImage = new PictureBox("ctrl-image-preview", U.el('ctrl-image-preview'));
                this.txDbField = new TextBox(U.inputEl('ctrl-db-field'));
                U.el('ctrl-db-field-button').onclick = P.call(this, () => this.selectDbField(this.txDbField.getText(), this.setDbField));
                this.cbBorderType = new ComboBox(U.selectEl('ctl-border-type'));
                this.txBorderColor = new TextBox(U.inputEl('ctrl-border-color'));
                this.shBorderColor = new Label(U.labelEl('ctrl-border-color-sample'));
                this.txBorder3D = new TextBox(U.inputEl('ctrl-border-color-3d'));
                this.shBorder3D = new Label(U.labelEl('ctrl-border-color-3d-sample'));
                this.txBorderShadow = new TextBox(U.inputEl('ctrl-border-color-shadow'));
                this.shBorderShadow = new Label(U.labelEl('ctrl-border-color-shadow-sample'));
                this.txBorderWidth = new TextBox(U.inputEl('ctrl-border-width'));
                this.chkBorderRounded = new CheckBox(U.inputEl('ctrl-border-rounded'));
                this.cbType = new ComboBox(U.selectEl('ctl-chart-type'));
                this.cbLinesType = new ComboBox(U.selectEl('ctl-chart-bar-grid-lines'));
                this.chkShowBarValues = new CheckBox(U.inputEl('ctrl-chart-show-bar-values'));
                this.chkShowOutlines = new CheckBox(U.inputEl('ctrl-chart-show-outline'));
                this.cbChartSize = new ComboBox(U.selectEl('ctl-chart-pie-size'));
                this.cbChartThickness = new ComboBox(U.selectEl('ctl-chart-pie-thickness'));
                this.txChartTop = new TextBox(U.inputEl('ctrl-chart-top'));
                this.chkSort = new CheckBox(U.inputEl('ctrl-chart-sort'));
                this.txChartDbFieldGroup = new TextBox(U.inputEl('ctrl-chart-group-db-field'));
                this.txChartGroupValue = new TextBox(U.inputEl('ctrl-chart-group-value'));
                this.txChartDbFieldVal1 = new TextBox(U.inputEl('ctrl-chart-serie1-db-field-value'));
                this.txChartDbFieldLbl1 = new TextBox(U.inputEl('ctrl-chart-serie1-db-field-label'));
                this.cbColorSerie1 = new ComboBox(U.selectEl('ctrl-chart-serie1-color'));
                this.txChartDbFieldVal2 = new TextBox(U.inputEl('ctrl-chart-serie2-db-field-value'));
                this.txChartDbFieldLbl2 = new TextBox(U.inputEl('ctrl-chart-serie2-db-field-label'));
                this.cbColorSerie2 = new ComboBox(U.selectEl('ctrl-chart-serie2-color'));
                U.el('ctrl-chart-group-db-field-button').onclick = P.call(this, () => this.selectDbField(this.txChartDbFieldGroup.getText(), this.setChartGroupDbField));
                U.el('ctrl-chart-serie1-db-field-value-button').onclick = P.call(this, () => this.selectDbField(this.txChartDbFieldVal1.getText(), this.setChartSerie1DbFieldValue));
                U.el('ctrl-chart-serie1-db-field-label-button').onclick = P.call(this, () => this.selectDbField(this.txChartDbFieldLbl1.getText(), this.setChartSerie1DbFieldLabel));
                U.el('ctrl-chart-serie2-db-field-value-button').onclick = P.call(this, () => this.selectDbField(this.txChartDbFieldVal2.getText(), this.setChartSerie2DbFieldValue));
                U.el('ctrl-chart-serie2-db-field-label-button').onclick = P.call(this, () => this.selectDbField(this.txChartDbFieldLbl2.getText(), this.setChartSerie2DbFieldLabel));
                this.txSectionName = new TextBox(U.inputEl('section-name'));
                this.lbSectionLineName = new Label(U.labelEl('section-line-name'));
                this.chkSectionFormulaHide = new CheckBox(U.inputEl('section-has-visible-formula'));
                this.chkSectionFormulaHide.setOnClick(P.call(this, this.chkSectionFormulaHideClick));
                this.chkSectionLineFormulaHide = new CheckBox(U.inputEl('section-line-has-visible-formula'));
                this.lbSectionFormulaHide = new Label(U.labelEl('section-visible-formula'));
                this.lbSectionLineFormulaHide = new Label(U.labelEl('section-line-visible-formula'));
                this.cmdSectionFormulaHide = new Button(U.el('ctrl-section-hide-formula-edit'));
                this.cmdSectionLineFormulaHide = new Button(U.el('ctrl-section-line-hide-formula-edit'));
                this.txGroupName = new TextBox(U.inputEl('group-name'));
                this.txGroupDbField = new TextBox(U.inputEl('ctrl-group-db-field'));
                this.opAsc = new OptionButton(U.inputEl('ctrl-group-sort-asc'));
                this.opDesc = new OptionButton(U.inputEl('ctrl-group-sort-desc'));
                this.opText = new OptionButton(U.inputEl('ctrl-group-comparison-text'));
                this.opDate = new OptionButton(U.inputEl('ctrl-group-comparison-date'));
                this.opNumber = new OptionButton(U.inputEl('ctrl-group-comparison-number'));
                this.chkGrandTotal = new CheckBox(U.inputEl('ctrl-group-grand-total'));
                this.chkReprintGroup = new CheckBox(U.inputEl('ctrl-group-header-in-every-page'));
                this.chkPrintInNewPage = new CheckBox(U.inputEl('ctrl-group-in-new-page'));
                this.chkSectionLineFormulaHide.setOnClick(P.call(this, this.chkSectionLineFormulaHideClick));
                this.chkFormulaHide.setOnClick(P.call(this, this.chkFormulaHideClick));
                this.chkFormulaValue.setOnClick(P.call(this, this.chkFormulaValueClick));
                this.opBeforePrint.setOnClick(P.call(this, this.opAfterPrintClick));
                this.opAfterPrint.setOnClick(P.call(this, this.opBeforePrintClick));
                this.txText.setChange(P.call(this, this.txTextChanged));
                this.txTag.setChange(P.call(this, this.txTagChanged));
                this.cbFont.setOnClick(P.call(this, this.cbFontClick));
                this.cbAlign.setOnClick(P.call(this, this.cbAlignClick));
                this.cbBorderType.setOnClick(P.call(this, this.cbBorderTypeClick));
                this.chkBorderRounded.setOnClick(P.call(this, this.chkBorderRoundedClick));
                this.txFontSize.setChange(P.call(this, this.txFontSizeChanged));
                this.txFormat.setChange(P.call(this, this.txFormatChanged));
                this.txSymbol.setChange(P.call(this, this.txSymbolChanged));
                this.chkFontBold.setChange(P.call(this, this.chkFontBoldChanged));
                this.chkFontUnderline.setChange(P.call(this, this.chkFontUnderlineChanged));
                this.chkFontItalic.setChange(P.call(this, this.chkFontItalicChanged));
                this.chkFontStrike.setChange(P.call(this, this.chkFontStrikeChanged));
                this.txLeft.setChange(P.call(this, this.txLeftChanged));
                this.txTop.setChange(P.call(this, this.txTopChanged));
                this.txHeight.setChange(P.call(this, this.txHeightChanged));
                this.txWidth.setChange(P.call(this, this.txWidthChanged));
                this.chkCanGrow.setChange(P.call(this, this.chkCanGrowCheckedChanged));
                this.chkWordWrap.setChange(P.call(this, this.chkWordWrapCheckedChanged));
                this.chkIsFreeCtrl.setChange(P.call(this, this.chkIsFreeCtrlCheckedChanged));
                this.txExportColIdx.setChange(P.call(this, this.txExportColIdxTextChanged));
                this.txForeColor.setChange(P.call(this, this.txForeColorChanged));
                this.txBackColor.setChange(P.call(this, this.txBackColorChanged));
                this.chkTransparent.setChange(P.call(this, this.chkTransparentChanged));
                this.txBorderColor.setChange(P.call(this, this.txBorderColorChanged));
                this.txBorder3D.setChange(P.call(this, this.txBorder3DChanged));
                this.txBorderShadow.setChange(P.call(this, this.txBorderShadowChanged));
                this.txBorderWidth.setChange(P.call(this, this.txBorderWidthChanged));
                this.txForeColor.setLostFocus(P.call(this, this.txForeColorLostFocus));
                this.txBackColor.setLostFocus(P.call(this, this.txBackColorLostFocus));
                this.txBorderColor.setLostFocus(P.call(this, this.txBorderColorLostFocus));
                this.txBorder3D.setLostFocus(P.call(this, this.txBorder3DLostFocus));
                this.txBorderShadow.setLostFocus(P.call(this, this.txBorderShadowLostFocus));
                this.txChartGroupValue.setChange(P.call(this, this.txChartGroupValueChanged));
                this.txChartTop.setChange(P.call(this, this.txChartTopChanged));
                this.cbType.setOnClick(P.call(this, this.cbTypeSelectedIndexChanged));
                this.cbLinesType.setOnClick(P.call(this, this.cbLinesTypeSelectedIndexChanged));
                this.cbChartSize.setOnClick(P.call(this, this.cbChartSizeSelectedIndexChanged));
                this.txChartTop.setChange(P.call(this, this.txChartTopTextChanged));
                this.cbChartThickness.setOnClick(P.call(this, this.cbChartThicknessSelectedIndexChanged));
                this.chkShowBarValues.setChange(P.call(this, this.chkShowBarValuesCheckedChanged));
                this.chkShowOutlines.setChange(P.call(this, this.chkShowOutlinesCheckedChanged));
                this.chkSort.setChange(P.call(this, this.chkSortCheckedChanged));
                this.txChartDbFieldGroup.setChange(P.call(this, this.txDbFieldGroupTextChanged));
                this.txChartDbFieldVal1.setChange(P.call(this, this.txDbFieldVal1TextChanged));
                this.txChartDbFieldLbl1.setChange(P.call(this, this.txDbFieldLbl1TextChanged));
                this.cbColorSerie1.setOnClick(P.call(this, this.cbColorSerie1SelectedIndexChanged));
                this.txChartDbFieldVal2.setChange(P.call(this, this.txDbFieldVal2TextChanged));
                this.txChartDbFieldLbl2.setChange(P.call(this, this.txDbFieldLbl2TextChanged));
                this.cbColorSerie2.setOnClick(P.call(this, this.cbColorSerie2SelectedIndexChanged));
                this.tabFormat = U.el('property-format-tab-selector');
                this.tabBorders = U.el('property-borders-tab-selector');
                this.tabFormulas = U.el('property-formulas-tab-selector');
                this.tabImage = U.el('property-image-tab-selector');
                this.tabField = U.el('property-database-tab-selector');
                this.tabChart = U.el('property-chart-tab-selector');
                this.tabSection = U.el('property-section-tab-selector');
                this.tabGroup = U.el('property-group-tab-selector');
                this.hideTabField();
                this.hideTabImage();
                this.hideTabChart();
                this.hideTabSection();
                this.cmdFormulaHide.setOnClick(P.call(this, this.editFormulaHideClick));
                this.cmdFormulaValue.setOnClick(P.call(this, this.editFormulaValueClick));
                this.cmdSectionFormulaHide.setOnClick(P.call(this, this.editSectionFormulaHideClick));
                this.cmdSectionLineFormulaHide.setOnClick(P.call(this, this.editSectionLineFormulaHideClick));
                this.initChart();
                this.cmdApply = new Button(U.el('ctrl-properties-dlg-apply'));
                this.cmdApply.setOnClick(P.call(this, this.cmdApplyClick));
                this.cmdCancel = new Button(U.el('ctrl-properties-dlg-cancel'));
                this.cmdCancel.setOnClick(P.call(this, this.cmdCancelClick));
                this.divLockEditor = U.el('lock-editor');
            }
            cmdApplyClick() {
                this.editor.applyProperties();
                this.unlockEditor();
            }
            cmdCancelClick() {
                this.editor.restoreProperties();
                this.unlockEditor();
            }
            lockEditor() {
                this.divLockEditor.style.display = 'block';
            }
            unlockEditor() {
                this.divLockEditor.style.display = 'none';
            }
            editFormulaHideClick() {
                this.formulaName = "Hide";
                this.formulaDlg.setFormula(this.formulaHide);
                this.formulaDlg.setHandler(this.editor);
                this.formulaDlg.createTree();
                this.formulaDlg.expandTree();
                return this.formulaDlg.showModal().then(P.call(this, (result) => {
                    if (result) {
                        this.formulaHide = this.formulaDlg.getFormula();
                        this.formulaHideChanged = true;
                        this.lbFormulaHide.setText(this.formulaHide);
                        this.lockEditor();
                    }
                }));
            }
            editFormulaValueClick() {
                this.formulaName = "Value";
                this.formulaDlg.setFormula(this.formulaValue);
                this.formulaDlg.setHandler(this.editor);
                this.formulaDlg.createTree();
                this.formulaDlg.expandTree();
                return this.formulaDlg.showModal().then(P.call(this, (result) => {
                    if (result) {
                        this.formulaValue = this.formulaDlg.getFormula();
                        this.formulaValueChanged = true;
                        this.lbFormulaValue.setText(this.formulaValue);
                        this.lockEditor();
                    }
                }));
            }
            editSectionFormulaHideClick() {
                this.formulaName = "Hide";
                this.formulaDlg.setFormula(this.sectionFormulaHide);
                this.formulaDlg.setHandler(this.editor);
                this.formulaDlg.createTree();
                this.formulaDlg.expandTree();
                return this.formulaDlg.showModal().then(P.call(this, (result) => {
                    if (result) {
                        this.sectionFormulaHide = this.formulaDlg.getFormula();
                        this.sectionFormulaHideChanged = true;
                        this.lbSectionFormulaHide.setText(this.sectionFormulaHide);
                        this.lockEditor();
                    }
                }));
            }
            editSectionLineFormulaHideClick() {
                this.formulaName = "Hide";
                this.formulaDlg.setFormula(this.sectionLineFormulaHide);
                this.formulaDlg.setHandler(this.editor);
                this.formulaDlg.createTree();
                this.formulaDlg.expandTree();
                return this.formulaDlg.showModal().then(P.call(this, (result) => {
                    if (result) {
                        this.sectionLineFormulaHide = this.formulaDlg.getFormula();
                        this.sectionLineFormulaHideChanged = true;
                        this.lbSectionLineFormulaHide.setText(this.sectionLineFormulaHide);
                        this.lockEditor();
                    }
                }));
            }
            setHandler(editor) {
                this.editor = editor;
            }
            getIndex() {
                return this.index;
            }
            setIndex(value) {
                this.index = value;
            }
            getFieldType() {
                return this.fieldType;
            }
            setFieldType(value) {
                this.fieldType = value;
            }
            getFormulaHide() {
                return this.formulaHide;
            }
            setFormulaHide(formula) {
                this.formulaHide = formula;
                this.lbFormulaHide.setText(formula);
            }
            getFormulaValue() {
                return this.formulaValue;
            }
            setFormulaValue(formula) {
                this.formulaValue = formula;
                this.lbFormulaValue.setText(formula);
            }
            getFormulaName() {
                return this.formulaName;
            }
            setFormulaName(value) {
                this.formulaName = value;
            }
            getIsAccounting() {
                return this.isAccounting;
            }
            setIsAccounting(value) {
                this.isAccounting = value;
            }
            getSectionFormulaHide() {
                return this.sectionFormulaHide;
            }
            setSectionFormulaHide(formula) {
                this.sectionFormulaHide = formula;
                this.lbSectionFormulaHide.setText(formula);
            }
            getSectionLineFormulaHide() {
                return this.sectionLineFormulaHide;
            }
            setSectionLineFormulaHide(formula) {
                this.sectionLineFormulaHide = formula;
                this.lbSectionLineFormulaHide.setText(formula);
            }
            getTextChanged() {
                return this.textChanged;
            }
            setTextChanged(value) {
                this.textChanged = value;
            }
            getTagChanged() {
                return this.tagChanged;
            }
            setTagChanged(value) {
                this.tagChanged = value;
            }
            getFontChanged() {
                return this.fontChanged;
            }
            setFontChanged(value) {
                this.fontChanged = value;
            }
            getForeColorChanged() {
                return this.foreColorChanged;
            }
            setForeColorChanged(value) {
                this.foreColorChanged = value;
            }
            getBackColorChanged() {
                return this.backColorChanged;
            }
            setBackColorChanged(value) {
                this.backColorChanged = value;
            }
            getFormatChanged() {
                return this.formatChanged;
            }
            setFormatChanged(value) {
                this.formatChanged = value;
            }
            getLeftChanged() {
                return this.leftChanged;
            }
            setLeftChanged(value) {
                this.leftChanged = value;
            }
            getTopChanged() {
                return this.topChanged;
            }
            setTopChanged(value) {
                this.topChanged = value;
            }
            getHeightChanged() {
                return this.heightChanged;
            }
            setHeightChanged(value) {
                this.heightChanged = value;
            }
            getWidthChanged() {
                return this.widthChanged;
            }
            setWidthChanged(value) {
                this.widthChanged = value;
            }
            getSymbolChanged() {
                return this.symbolChanged;
            }
            setSymbolChanged(value) {
                this.symbolChanged = value;
            }
            getTransparentChanged() {
                return this.transparentChanged;
            }
            setTransparentChanged(value) {
                this.transparentChanged = value;
            }
            getStrikeChanged() {
                return this.strikeChanged;
            }
            setStrikeChanged(value) {
                this.strikeChanged = value;
            }
            getUnderlineChanged() {
                return this.underlineChanged;
            }
            setUnderlineChanged(value) {
                this.underlineChanged = value;
            }
            getWordWrapChanged() {
                return this.wordWrapChanged;
            }
            setWordWrapChanged(value) {
                this.wordWrapChanged = value;
            }
            getItalicChanged() {
                return this.italicChanged;
            }
            setItalicChanged(value) {
                this.italicChanged = value;
            }
            getBoldChanged() {
                return this.boldChanged;
            }
            setBoldChanged(value) {
                this.boldChanged = value;
            }
            getAlignChanged() {
                return this.alignChanged;
            }
            setAlignChanged(value) {
                this.alignChanged = value;
            }
            getFontSizeChanged() {
                return this.fontSizeChanged;
            }
            setFontSizeChanged(value) {
                this.fontSizeChanged = value;
            }
            getCanGrowChanged() {
                return this.canGrowChanged;
            }
            setCanGrowChanged(value) {
                this.canGrowChanged = value;
            }
            getFormulaHideChanged() {
                return this.formulaHideChanged;
            }
            setFormulaHideChanged(value) {
                this.formulaHideChanged = value;
            }
            getFormulaValueChanged() {
                return this.formulaValueChanged;
            }
            setFormulaValueChanged(value) {
                this.formulaValueChanged = value;
            }
            getWhenEvalChanged() {
                return this.whenEvalChanged;
            }
            setWhenEvalChanged(value) {
                this.whenEvalChanged = value;
            }
            getIdxGroupChanged() {
                return this.idxGroupChanged;
            }
            setIdxGroupChanged(value) {
                this.idxGroupChanged = value;
            }
            getDbFieldChanged() {
                return this.dbFieldChanged;
            }
            setDbFieldChanged(value) {
                this.dbFieldChanged = value;
            }
            getSetFormulaHideChanged() {
                return this.bSetFormulaHideChanged;
            }
            setSetFormulaHideChanged(value) {
                this.bSetFormulaHideChanged = value;
            }
            getSetFormulaValueChanged() {
                return this.bSetFormulaValueChanged;
            }
            setSetFormulaValueChanged(value) {
                this.bSetFormulaValueChanged = value;
            }
            getBorderTypeChanged() {
                return this.borderTypeChanged;
            }
            setBorderTypeChanged(value) {
                this.borderTypeChanged = value;
            }
            getBorder3DChanged() {
                return this.border3DChanged;
            }
            setBorder3DChanged(value) {
                this.border3DChanged = value;
            }
            getBorder3DShadowChanged() {
                return this.border3DShadowChanged;
            }
            setBorder3DShadowChanged(value) {
                this.border3DShadowChanged = value;
            }
            getBorderRoundedChanged() {
                return this.borderRoundedChanged;
            }
            setBorderRoundedChanged(value) {
                this.borderRoundedChanged = value;
            }
            getBorderWidthChanged() {
                return this.borderWidthChanged;
            }
            setBorderWidthChanged(value) {
                this.borderWidthChanged = value;
            }
            getBorderColorChanged() {
                return this.borderColorChanged;
            }
            setBorderColorChanged(value) {
                this.borderColorChanged = value;
            }
            getPictureChanged() {
                return this.pictureChanged;
            }
            setPictureChanged(value) {
                this.pictureChanged = value;
            }
            getIsFreeCtrlChanged() {
                return this.isFreeCtrlChanged;
            }
            setIsFreeCtrlChanged(value) {
                this.isFreeCtrlChanged = value;
            }
            getExportColIdxChanged() {
                return this.exportColIdxChanged;
            }
            setExportColIdxChanged(value) {
                this.exportColIdxChanged = value;
            }
            getChartGroupIndex() {
                return this.chartGroupIndex;
            }
            getChartIndex(idx) {
                return this.chartIndex[idx];
            }
            getChartFieldType(idx) {
                return this.chartFieldType[idx];
            }
            getChartGroupFieldType() {
                return this.chartGroupFieldType;
            }
            setChartGroupIndex(value) {
                this.chartGroupIndex = value;
            }
            setChartIndex(idx, value) {
                this.chartIndex[idx] = value;
            }
            setChartGroupFieldType(value) {
                this.chartGroupFieldType = value;
            }
            setChartFieldType(idx, value) {
                this.chartFieldType[idx] = value;
            }
            getChartFieldVal1Changed() {
                return this.chartFieldVal1Changed;
            }
            setChartFieldVal1Changed(value) {
                this.chartFieldVal1Changed = value;
            }
            getChartFieldVal2Changed() {
                return this.chartFieldVal2Changed;
            }
            setChartFieldVal2Changed(value) {
                this.chartFieldVal2Changed = value;
            }
            getChartFieldLbl1Changed() {
                return this.chartFieldLbl1Changed;
            }
            setChartFieldLbl1Changed(value) {
                this.chartFieldLbl1Changed = value;
            }
            getChartFieldGroupChanged() {
                return this.chartFieldGroupChanged;
            }
            setChartFieldGroupChanged(value) {
                this.chartFieldGroupChanged = value;
            }
            getChartGroupValueChanged() {
                return this.chartGroupValueChanged;
            }
            setChartGroupValueChanged(value) {
                this.chartGroupValueChanged = value;
            }
            getChartFieldLbl2Changed() {
                return this.chartFieldLbl2Changed;
            }
            setChartFieldLbl2Changed(value) {
                this.chartFieldLbl2Changed = value;
            }
            getChartSizeChanged() {
                return this.chartSizeChanged;
            }
            setChartSizeChanged(value) {
                this.chartSizeChanged = value;
            }
            getChartThicknessChanged() {
                return this.chartThicknessChanged;
            }
            setChartThicknessChanged(value) {
                this.chartThicknessChanged = value;
            }
            getChartColorSerie1Changed() {
                return this.chartColorSerie1Changed;
            }
            setChartColorSerie1Changed(value) {
                this.chartColorSerie1Changed = value;
            }
            getChartColorSerie2Changed() {
                return this.chartColorSerie2Changed;
            }
            setChartColorSerie2Changed(value) {
                this.chartColorSerie2Changed = value;
            }
            getChartLinesTypeChanged() {
                return this.chartLinesTypeChanged;
            }
            setChartLinesTypeChanged(value) {
                this.chartLinesTypeChanged = value;
            }
            getChartTypeChanged() {
                return this.chartTypeChanged;
            }
            setChartTypeChanged(value) {
                this.chartTypeChanged = value;
            }
            getChartShowLinesChanged() {
                return this.chartShowLinesChanged;
            }
            setChartShowLinesChanged(value) {
                this.chartShowLinesChanged = value;
            }
            getChartShowValuesChanged() {
                return this.chartShowValuesChanged;
            }
            setChartShowValuesChanged(value) {
                this.chartShowValuesChanged = value;
            }
            getChartTopChanged() {
                return this.chartTopChanged;
            }
            setChartTopChanged(value) {
                this.chartTopChanged = value;
            }
            getChartSortChanged() {
                return this.chartSortChanged;
            }
            setChartSortChanged(value) {
                this.chartSortChanged = value;
            }
            getHasSectionFormulaHideChanged() {
                return this.bSetSectionFormulaHideChanged;
            }
            setHasSectionFormulaHideChanged(value) {
                this.bSetSectionFormulaHideChanged = value;
            }
            getSectionFormulaHideChanged() {
                return this.sectionFormulaHideChanged;
            }
            setSectionFormulaHideChanged(value) {
                this.sectionFormulaHideChanged = value;
            }
            getHasSectionLineFormulaHideChanged() {
                return this.bSetSectionLineFormulaHideChanged;
            }
            setHasSectionLineFormulaHideChanged(value) {
                this.bSetSectionLineFormulaHideChanged = value;
            }
            getSectionLineFormulaHideChanged() {
                return this.sectionLineFormulaHideChanged;
            }
            setSectionLineFormulaHideChanged(value) {
                this.sectionLineFormulaHideChanged = value;
            }
            cbFontClick() {
                this.fontChanged = true;
                this.lockEditor();
            }
            cbAlignClick() {
                this.alignChanged = true;
                this.lockEditor();
            }
            cbBorderTypeClick() {
                this.borderTypeChanged = true;
                this.lockEditor();
            }
            chkBorderRoundedClick() {
                this.borderRoundedChanged = true;
                this.lockEditor();
            }
            chkFormulaHideClick() {
                this.bSetFormulaHideChanged = true;
                this.lockEditor();
            }
            chkFormulaValueClick() {
                this.bSetFormulaValueChanged = true;
                this.lockEditor();
            }
            chkSectionFormulaHideClick() {
                this.bSetSectionFormulaHideChanged = true;
                this.lockEditor();
            }
            chkSectionLineFormulaHideClick() {
                this.bSetSectionLineFormulaHideChanged = true;
                this.lockEditor();
            }
            opAfterPrintClick() {
                this.whenEvalChanged = true;
                this.lockEditor();
            }
            opBeforePrintClick() {
                this.whenEvalChanged = true;
                this.lockEditor();
            }
            txForeColorLostFocus() {
                try {
                    this.shForeColor.setBackColor(new Color(this.txForeColor.getText()).color.toString());
                }
                catch (ignore) { }
            }
            txBackColorLostFocus() {
                try {
                    this.shBackColor.setBackColor(new Color(this.txBackColor.getText()).color.toString());
                }
                catch (ignore) { }
            }
            txBorder3DLostFocus() {
                try {
                    this.shBorder3D.setBackColor(new Color(this.txBorder3D.getText()).color);
                }
                catch (ignore) { }
            }
            txBorderColorLostFocus() {
                try {
                    this.shBorderColor.setBackColor(new Color(this.txBorderColor.getText()).color);
                }
                catch (ignore) { }
            }
            txBorderShadowLostFocus() {
                try {
                    this.shBorderShadow.setBackColor(new Color(this.txBorderShadow.getText()).color);
                }
                catch (ignore) { }
            }
            cmdDbFieldGroupValueClick() {
            }
            cmdDbFieldLbl1Click() {
            }
            cmdDbFieldLbl2Click() {
            }
            cmdDbFieldVal1Click() {
            }
            cmdDbFieldVal2Click() {
            }
            initChart() {
                U.listAdd(this.cbType, "Pie", csRptChartType.PIE);
                U.listAdd(this.cbType, "Bar", csRptChartType.BAR);
                U.listSetListIndex(this.cbType, 0);
                this.chkShowOutlines.setChecked(true);
                this.chkShowBarValues.setChecked(true);
                this.fillColors(this.cbColorSerie1);
                U.listSetListIndex(this.cbColorSerie1, 10);
                this.fillColors(this.cbColorSerie2);
                U.listSetListIndex(this.cbColorSerie2, 69);
                U.listAdd(this.cbChartSize, "Smallest", 50);
                U.listAdd(this.cbChartSize, "Smaller", 100);
                U.listAdd(this.cbChartSize, "Small", 150);
                U.listAdd(this.cbChartSize, "Medium", 200);
                U.listAdd(this.cbChartSize, "Large", 250);
                U.listAdd(this.cbChartSize, "Big", 350);
                U.listSetListIndex(this.cbChartSize, 3);
                U.listAdd(this.cbChartThickness, "None", 0);
                U.listAdd(this.cbChartThickness, "Wafer", 2);
                U.listAdd(this.cbChartThickness, "Thin", 4);
                U.listAdd(this.cbChartThickness, "Medium", 8);
                U.listAdd(this.cbChartThickness, "Thick", 16);
                U.listAdd(this.cbChartThickness, "Thickest", 32);
                U.listSetListIndex(this.cbChartThickness, 2);
                U.listAdd(this.cbLinesType, "None", csRptChartLineStyle.NONE);
                U.listAdd(this.cbLinesType, "Horizontal", csRptChartLineStyle.HORIZONTAL);
                U.listAdd(this.cbLinesType, "Numbered", csRptChartLineStyle.NUMBERED);
                U.listAdd(this.cbLinesType, "Both", csRptChartLineStyle.BOTH);
                U.listSetListIndex(this.cbLinesType, 3);
            }
            fillColors(cbList) {
                U.listAdd(cbList, "AliceBlue", "#FFF0F8FF");
                U.listAdd(cbList, "AntiqueWhite", "#FAEBD7");
                U.listAdd(cbList, "Aqua", "#00FFFF");
                U.listAdd(cbList, "Aquamarine", "#7FFFD4");
                U.listAdd(cbList, "Azure", "#F0FFFF");
                U.listAdd(cbList, "Beige", "#F5F5DC");
                U.listAdd(cbList, "Bisque", "#FFE4C4");
                U.listAdd(cbList, "Black", "#000000");
                U.listAdd(cbList, "BlanchedAlmond", "#FFEBCD");
                U.listAdd(cbList, "Blue", "#0000FF");
                U.listAdd(cbList, "BlueViolet", "#8A2BE2");
                U.listAdd(cbList, "Brown", "#A52A2A");
                U.listAdd(cbList, "BurlyWood", "#DEB887");
                U.listAdd(cbList, "CadetBlue", "#5F9EA0");
                U.listAdd(cbList, "Chartreuse", "#7FFF00");
                U.listAdd(cbList, "Chocolate", "#D2691E");
                U.listAdd(cbList, "Coral", "#FF7F50");
                U.listAdd(cbList, "CornflowerBlue", "#6495ED");
                U.listAdd(cbList, "Cornsilk", "#FFF8DC");
                U.listAdd(cbList, "Crimson", "#DC143C");
                U.listAdd(cbList, "Cyan", "#00FFFF");
                U.listAdd(cbList, "DarkBlue", "#00008B");
                U.listAdd(cbList, "DarkCyan", "#008B8B");
                U.listAdd(cbList, "DarkGoldenrod", "#B8860B");
                U.listAdd(cbList, "DarkGray", "#A9A9A9");
                U.listAdd(cbList, "DarkGreen", "#006400");
                U.listAdd(cbList, "DarkKhaki", "#BDB76B");
                U.listAdd(cbList, "DarkMagenta", "#8B008B");
                U.listAdd(cbList, "DarkOliveGreen", "#556B2F");
                U.listAdd(cbList, "DarkOrange", "#FF8C00");
                U.listAdd(cbList, "DarkOrchid", "#9932CC");
                U.listAdd(cbList, "DarkRed", "#8B0000");
                U.listAdd(cbList, "DarkSalmon", "#E9967A");
                U.listAdd(cbList, "DarkSeaGreen", "#8FBC8B");
                U.listAdd(cbList, "DarkSlateBlue", "#483D8B");
                U.listAdd(cbList, "DarkSlateGray", "#2F4F4F");
                U.listAdd(cbList, "DarkTurquoise", "#00CED1");
                U.listAdd(cbList, "DarkViolet", "#9400D3");
                U.listAdd(cbList, "DeepPink", "#FF1493");
                U.listAdd(cbList, "DeepSkyBlue", "#00BFFF");
                U.listAdd(cbList, "DimGray", "#696969");
                U.listAdd(cbList, "DodgerBlue", "#1E90FF");
                U.listAdd(cbList, "Firebrick", "#B22222");
                U.listAdd(cbList, "FloralWhite", "#FFFAF0");
                U.listAdd(cbList, "ForestGreen", "#228B22");
                U.listAdd(cbList, "Fuchsia", "#FF00FF");
                U.listAdd(cbList, "Gainsboro", "#DCDCDC");
                U.listAdd(cbList, "GhostWhite", "#F8F8FF");
                U.listAdd(cbList, "Gold", "#FFD700");
                U.listAdd(cbList, "Goldenrod", "#DAA520");
                U.listAdd(cbList, "Gray", "#808080");
                U.listAdd(cbList, "Green", "#008000");
                U.listAdd(cbList, "GreenYellow", "#ADFF2F");
                U.listAdd(cbList, "Honeydew", "#F0FFF0");
                U.listAdd(cbList, "HotPink", "#FF69B4");
                U.listAdd(cbList, "IndianRed", "#CD5C5C");
                U.listAdd(cbList, "Indigo", "#4B0082");
                U.listAdd(cbList, "Ivory", "#FFFFF0");
                U.listAdd(cbList, "Khaki", "#F0E68C");
                U.listAdd(cbList, "Lavender", "#E6E6FA");
                U.listAdd(cbList, "LavenderBlush", "#FFF0F5");
                U.listAdd(cbList, "LawnGreen", "#7CFC00");
                U.listAdd(cbList, "LemonChiffon", "#FFFACD");
                U.listAdd(cbList, "LightBlue", "#ADD8E6");
                U.listAdd(cbList, "LightCoral", "#F08080");
                U.listAdd(cbList, "LightCyan", "#E0FFFF");
                U.listAdd(cbList, "LightGoldenrodYellow", "#FAFAD2");
                U.listAdd(cbList, "LightGray", "#D3D3D3");
                U.listAdd(cbList, "LightGreen", "#90EE90");
                U.listAdd(cbList, "LightPink", "#FFB6C1");
                U.listAdd(cbList, "LightSalmon", "#FFA07A");
                U.listAdd(cbList, "LightSeaGreen", "#20B2AA");
                U.listAdd(cbList, "LightSkyBlue", "#87CEFA");
                U.listAdd(cbList, "LightSlateGray", "#778899");
                U.listAdd(cbList, "LightSteelBlue", "#B0C4DE");
                U.listAdd(cbList, "LightYellow", "#FFFFE0");
                U.listAdd(cbList, "Lime", "#00FF00");
                U.listAdd(cbList, "LimeGreen", "#32CD32");
                U.listAdd(cbList, "Linen", "#FAF0E6");
                U.listAdd(cbList, "Magenta", "#FF00FF");
                U.listAdd(cbList, "Maroon", "#800000");
                U.listAdd(cbList, "MediumAquamarine", "#66CDAA");
                U.listAdd(cbList, "MediumBlue", "#0000CD");
                U.listAdd(cbList, "MediumOrchid", "#BA55D3");
                U.listAdd(cbList, "MediumPurple", "#9370DB");
                U.listAdd(cbList, "MediumSeaGreen", "#3CB371");
                U.listAdd(cbList, "MediumSlateBlue", "#7B68EE");
                U.listAdd(cbList, "MediumSpringGreen", "#00FA9A");
                U.listAdd(cbList, "MediumTurquoise", "#48D1CC");
                U.listAdd(cbList, "MediumVioletRed", "#C71585");
                U.listAdd(cbList, "MidnightBlue", "#191970");
                U.listAdd(cbList, "MintCream", "#F5FFFA");
                U.listAdd(cbList, "MistyRose", "#FFE4E1");
                U.listAdd(cbList, "Moccasin", "#FFE4B5");
                U.listAdd(cbList, "NavajoWhite", "#FFDEAD");
                U.listAdd(cbList, "Navy", "#000080");
                U.listAdd(cbList, "OldLace", "#FDF5E6");
                U.listAdd(cbList, "Olive", "#808000");
                U.listAdd(cbList, "OliveDrab", "#6B8E23");
                U.listAdd(cbList, "Orange", "#FFA500");
                U.listAdd(cbList, "OrangeRed", "#FF4500");
                U.listAdd(cbList, "Orchid", "#DA70D6");
                U.listAdd(cbList, "PaleGoldenrod", "#EEE8AA");
                U.listAdd(cbList, "PaleGreen", "#98FB98");
                U.listAdd(cbList, "PaleTurquoise", "#AFEEEE");
                U.listAdd(cbList, "PaleVioletRed", "#DB7093");
                U.listAdd(cbList, "PapayaWhip", "#FFEFD5");
                U.listAdd(cbList, "PeachPuff", "#FFDAB9");
                U.listAdd(cbList, "Peru", "#CD853F");
                U.listAdd(cbList, "Pink", "#FFC0CB");
                U.listAdd(cbList, "Plum", "#DDA0DD");
                U.listAdd(cbList, "PowderBlue", "#B0E0E6");
                U.listAdd(cbList, "Purple", "#800080");
                U.listAdd(cbList, "Red", "#FF0000");
                U.listAdd(cbList, "RosyBrown", "#BC8F8F");
                U.listAdd(cbList, "RoyalBlue", "#4169E1");
                U.listAdd(cbList, "SaddleBrown", "#8B4513");
                U.listAdd(cbList, "Salmon", "#FA8072");
                U.listAdd(cbList, "SandyBrown", "#F4A460");
                U.listAdd(cbList, "SeaGreen", "#2E8B57");
                U.listAdd(cbList, "SeaShell", "#FFF5EE");
                U.listAdd(cbList, "Sienna", "#A0522D");
                U.listAdd(cbList, "Silver", "#C0C0C0");
                U.listAdd(cbList, "SkyBlue", "#87CEEB");
                U.listAdd(cbList, "SlateBlue", "#6A5ACD");
                U.listAdd(cbList, "SlateGray", "#708090");
                U.listAdd(cbList, "Snow", "#FFFAFA");
                U.listAdd(cbList, "SpringGreen", "#00FF7F");
                U.listAdd(cbList, "SteelBlue", "#4682B4");
                U.listAdd(cbList, "Tan", "#D2B48C");
                U.listAdd(cbList, "Teal", "#008080");
                U.listAdd(cbList, "Thistle", "#D8BFD8");
                U.listAdd(cbList, "Tomato", "#FF6347");
                U.listAdd(cbList, "Transparent", "#FFFF");
                U.listAdd(cbList, "Turquoise", "#40E0D0");
                U.listAdd(cbList, "Violet", "#EE82EE");
                U.listAdd(cbList, "Wheat", "#F5DEB3");
                U.listAdd(cbList, "White", "#FFFFFF");
                U.listAdd(cbList, "WhiteSmoke", "#F5F5F5");
                U.listAdd(cbList, "Yellow", "#FFFF00");
                U.listAdd(cbList, "YellowGreen", "#9ACD32");
            }
            cmdForeColorClick() {
                this.picColor(this.txForeColor, this.shForeColor);
            }
            cmdBackColorClick() {
                this.picColor(this.txBackColor, this.shBackColor);
            }
            cmdBorderColorClick() {
                this.picColor(this.txBorderColor, this.shBorderColor);
            }
            cmdBorder3DClick() {
                this.picColor(this.txBorder3D, this.shBorder3D);
            }
            cmdBorderShadowClick() {
                this.picColor(this.txBorderShadow, this.shBorderShadow);
            }
            picColor(txColor, shColor) {
            }
            cmdFontClick() {
            }
            cmdDbFieldClick() {
                this.editor.showHelpDbField().then(P.call(this, (result) => {
                    if (result) {
                        this.dbFieldChanged = true;
                        this.lockEditor();
                    }
                }));
            }
            txChartGroupValueChanged() {
                this.chartGroupValueChanged = true;
                this.lockEditor();
            }
            txChartTopChanged() {
                this.chartTopChanged = true;
                this.lockEditor();
            }
            txTextChanged() {
                this.textChanged = true;
                this.lockEditor();
            }
            txTagChanged() {
                this.tagChanged = true;
                this.lockEditor();
            }
            txFontSizeChanged() {
                this.fontSizeChanged = true;
                this.lockEditor();
            }
            txForeColorChanged() {
                this.foreColorChanged = true;
                this.txForeColorLostFocus();
                this.lockEditor();
            }
            txBackColorChanged() {
                this.backColorChanged = true;
                this.txBackColorLostFocus();
                this.lockEditor();
            }
            chkTransparentChanged() {
                this.transparentChanged = true;
                this.lockEditor();
            }
            txFormatChanged() {
                this.formatChanged = true;
                this.lockEditor();
            }
            txSymbolChanged() {
                this.symbolChanged = true;
                this.lockEditor();
            }
            chkFontBoldChanged() {
                this.boldChanged = true;
                this.lockEditor();
            }
            chkFontUnderlineChanged() {
                this.underlineChanged = true;
                this.lockEditor();
            }
            chkFontItalicChanged() {
                this.italicChanged = true;
                this.lockEditor();
            }
            chkFontStrikeChanged() {
                this.strikeChanged = true;
                this.lockEditor();
            }
            txLeftChanged() {
                this.leftChanged = true;
                this.lockEditor();
            }
            txTopChanged() {
                this.topChanged = true;
                this.lockEditor();
            }
            txHeightChanged() {
                this.heightChanged = true;
                this.lockEditor();
            }
            txWidthChanged() {
                this.widthChanged = true;
                this.lockEditor();
            }
            chkCanGrowCheckedChanged() {
                this.canGrowChanged = true;
                this.lockEditor();
            }
            chkWordWrapCheckedChanged() {
                this.wordWrapChanged = true;
                this.lockEditor();
            }
            chkIsFreeCtrlCheckedChanged() {
                this.isFreeCtrlChanged = true;
                this.lockEditor();
            }
            txExportColIdxTextChanged() {
                this.exportColIdxChanged = true;
                this.lockEditor();
            }
            txBorderColorChanged() {
                this.borderColorChanged = true;
                this.txBorderColorLostFocus();
                this.lockEditor();
            }
            txBorder3DChanged() {
                this.border3DChanged = true;
                this.txBorder3DLostFocus();
                this.lockEditor();
            }
            txBorderShadowChanged() {
                this.border3DShadowChanged = true;
                this.txBorderShadowLostFocus();
                this.lockEditor();
            }
            txBorderWidthChanged() {
                this.borderWidthChanged = true;
                this.lockEditor();
            }
            cbTypeSelectedIndexChanged() {
                this.chartTypeChanged = true;
                this.lockEditor();
            }
            cbLinesTypeSelectedIndexChanged() {
                this.chartLinesTypeChanged = true;
                this.lockEditor();
            }
            cbChartSizeSelectedIndexChanged() {
                this.chartSizeChanged = true;
                this.lockEditor();
            }
            txChartTopTextChanged() {
                this.chartTopChanged = true;
                this.lockEditor();
            }
            cbChartThicknessSelectedIndexChanged() {
                this.chartThicknessChanged = true;
                this.lockEditor();
            }
            chkShowBarValuesCheckedChanged() {
                this.chartShowValuesChanged = true;
                this.lockEditor();
            }
            chkShowOutlinesCheckedChanged() {
                this.chartShowLinesChanged = true;
                this.lockEditor();
            }
            chkSortCheckedChanged() {
                this.chartSortChanged = true;
                this.lockEditor();
            }
            txDbFieldGroupTextChanged() {
                this.chartFieldGroupChanged = true;
                this.lockEditor();
            }
            txDbFieldVal1TextChanged() {
                this.chartFieldVal1Changed = true;
                this.lockEditor();
            }
            txDbFieldLbl1TextChanged() {
                this.chartFieldLbl1Changed = true;
                this.lockEditor();
            }
            cbColorSerie1SelectedIndexChanged() {
                this.chartColorSerie1Changed = true;
                this.lockEditor();
            }
            txDbFieldVal2TextChanged() {
                this.chartFieldVal2Changed = true;
                this.lockEditor();
            }
            txDbFieldLbl2TextChanged() {
                this.chartFieldLbl2Changed = true;
                this.lockEditor();
            }
            cbColorSerie2SelectedIndexChanged() {
                this.chartColorSerie2Changed = true;
                this.lockEditor();
            }
            resetChangedFlags() {
                this.textChanged = false;
                this.tagChanged = false;
                this.fontChanged = false;
                this.foreColorChanged = false;
                this.backColorChanged = false;
                this.formatChanged = false;
                this.leftChanged = false;
                this.topChanged = false;
                this.heightChanged = false;
                this.widthChanged = false;
                this.symbolChanged = false;
                this.transparentChanged = false;
                this.strikeChanged = false;
                this.underlineChanged = false;
                this.wordWrapChanged = false;
                this.italicChanged = false;
                this.boldChanged = false;
                this.alignChanged = false;
                this.fontSizeChanged = false;
                this.canGrowChanged = false;
                this.formulaHideChanged = false;
                this.formulaValueChanged = false;
                this.idxGroupChanged = false;
                this.whenEvalChanged = false;
                this.dbFieldChanged = false;
                this.bSetFormulaHideChanged = false;
                this.bSetFormulaValueChanged = false;
                this.pictureChanged = false;
                this.borderTypeChanged = false;
                this.border3DChanged = false;
                this.border3DShadowChanged = false;
                this.borderRoundedChanged = false;
                this.borderWidthChanged = false;
                this.borderColorChanged = false;
                this.chartFieldGroupChanged = false;
                this.chartFieldLbl1Changed = false;
                this.chartFieldLbl2Changed = false;
                this.chartFieldVal1Changed = false;
                this.chartFieldVal2Changed = false;
                this.chartSizeChanged = false;
                this.chartThicknessChanged = false;
                this.chartColorSerie1Changed = false;
                this.chartColorSerie2Changed = false;
                this.chartLinesTypeChanged = false;
                this.chartTypeChanged = false;
                this.chartShowLinesChanged = false;
                this.chartShowValuesChanged = false;
                this.chartTopChanged = false;
                this.chartTopChanged = false;
                this.chartFieldGroupChanged = false;
                this.chartGroupValueChanged = false;
                this.isFreeCtrlChanged = false;
                this.exportColIdxChanged = false;
                this.bSetSectionFormulaHideChanged = false;
                this.bSetSectionLineFormulaHideChanged = false;
            }
            hideTabFormats() {
                this.tabFormat.style.display = 'none';
            }
            hideTabBorders() {
                this.tabBorders.style.display = 'none';
            }
            hideTabFormulas() {
                this.tabFormulas.style.display = 'none';
            }
            hideTabField() {
                this.tabField.style.display = 'none';
            }
            hideTabImage() {
                this.tabImage.style.display = 'none';
            }
            hideTabChart() {
                this.tabChart.style.display = 'none';
            }
            hideTabSection() {
                this.tabSection.style.display = 'none';
            }
            hideTabGroup() {
                this.tabGroup.style.display = 'none';
            }
            showTabFormat() {
                this.tabFormat.style.display = 'block';
            }
            showTabBorders() {
                this.tabBorders.style.display = 'block';
            }
            showTabFormulas() {
                this.tabFormulas.style.display = 'block';
            }
            showTabField() {
                this.tabField.style.display = 'block';
            }
            showTabImage() {
                this.tabImage.style.display = 'block';
            }
            showTabChart() {
                this.tabChart.style.display = 'block';
            }
            showTabSection() {
                this.tabSection.style.display = 'block';
            }
            showTabGroup() {
                this.tabGroup.style.display = 'block';
            }
            displayCtrlPropertyTabs() {
                this.hideTabSection();
                this.hideTabGroup();
                this.showTabFormat();
                this.showTabField();
                this.showTabBorders();
                this.showTabFormulas();
            }
            showCtrlPropertyTabs() {
                if (!this.isCtrlTab(this.currentTab) || !this.tabIsVisible(this.currentTab)) {
                    this.selectTab('property-format-tab');
                }
            }
            isCtrlTab(tab) {
                return PropertyDlg.CTRL_TABS.indexOf(tab) > -1;
            }
            tabIsVisible(tab) {
                if (tab === null)
                    return false;
                return U.el(tab).style.display === 'block';
            }
            showSectionPropertyTabs(isGroup) {
                this.hideTabChart();
                this.hideTabImage();
                this.hideTabFormats();
                this.hideTabField();
                this.hideTabBorders();
                this.hideTabFormulas();
                this.showTabSection();
                if (isGroup)
                    this.showTabGroup();
                if (!this.isSectionTab(this.currentTab) || !this.tabIsVisible(this.currentTab)) {
                    this.selectTab('property-section-tab');
                }
            }
            isSectionTab(tab) {
                return PropertyDlg.SECTION_TABS.indexOf(tab) > -1;
            }
            disable() {
                this.setEnabled(false);
            }
            enable() {
                this.setEnabled(true);
            }
            setEnabled(enable) {
                this.lbControl.setEnabled(enable);
                this.txName.setEnabled(enable);
                this.txText.setEnabled(enable);
                this.txTag.setEnabled(enable);
                this.cbFont.setEnabled(enable);
                this.txFontSize.setEnabled(enable);
                this.cbAlign.setEnabled(enable);
                this.chkFontBold.setEnabled(enable);
                this.chkFontUnderline.setEnabled(enable);
                this.chkFontItalic.setEnabled(enable);
                this.chkFontStrike.setEnabled(enable);
                this.txForeColor.setEnabled(enable);
                this.shForeColor.setEnabled(enable);
                this.chkTransparent.setEnabled(enable);
                this.txBackColor.setEnabled(enable);
                this.shBackColor.setEnabled(enable);
                this.txSymbol.setEnabled(enable);
                this.txFormat.setEnabled(enable);
                this.txLeft.setEnabled(enable);
                this.txTop.setEnabled(enable);
                this.txWidth.setEnabled(enable);
                this.txHeight.setEnabled(enable);
                this.chkCanGrow.setEnabled(enable);
                this.chkWordWrap.setEnabled(enable);
                this.chkIsFreeCtrl.setEnabled(enable);
                this.txExportColIdx.setEnabled(enable);
                this.chkFormulaHide.setEnabled(enable);
                this.lbFormulaHide.setEnabled(enable);
                this.cmdFormulaHide.setEnabled(enable);
                this.chkFormulaValue.setEnabled(enable);
                this.lbFormulaValue.setEnabled(enable);
                this.cmdFormulaValue.setEnabled(enable);
                this.txIdxGroup.setEnabled(enable);
                this.opBeforePrint.setEnabled(enable);
                this.opAfterPrint.setEnabled(enable);
                this.txImageFile.setEnabled(enable);
                this.picImage.setEnabled(enable);
                this.txDbField.setEnabled(enable);
                this.cbBorderType.setEnabled(enable);
                this.txBorderColor.setEnabled(enable);
                this.shBorderColor.setEnabled(enable);
                this.txBorder3D.setEnabled(enable);
                this.shBorder3D.setEnabled(enable);
                this.txBorderShadow.setEnabled(enable);
                this.shBorderShadow.setEnabled(enable);
                this.txBorderWidth.setEnabled(enable);
                this.chkBorderRounded.setEnabled(enable);
            }
            getDbFieldGroupValue() {
                throw new NotImplementedException();
            }
            setDbFieldGroupValue(sField) {
                throw new NotImplementedException();
            }
            getTxName() {
                return this.txName;
            }
            getTxText() {
                return this.txText;
            }
            getTxTag() {
                return this.txTag;
            }
            getCbFont() {
                return this.cbFont;
            }
            getShForeColor() {
                return this.shForeColor;
            }
            getTxForeColor() {
                return this.txForeColor;
            }
            getChkFontBold() {
                return this.chkFontBold;
            }
            getChkFontItalic() {
                return this.chkFontItalic;
            }
            getTxFontSize() {
                return this.txFontSize;
            }
            getChkFontUnderline() {
                return this.chkFontUnderline;
            }
            getChkFontStrike() {
                return this.chkFontStrike;
            }
            getTxImageFile() {
                return this.txImageFile;
            }
            getPicImage() {
                return this.picImage;
            }
            getTxDbField() {
                return this.txDbField;
            }
            getLbControl() {
                return this.lbControl;
            }
            getChkFormulaHide() {
                return this.chkFormulaHide;
            }
            getChkFormulaValue() {
                return this.chkFormulaValue;
            }
            getTxExportColIdx() {
                return this.txExportColIdx;
            }
            getChkIsFreeCtrl() {
                return this.chkIsFreeCtrl;
            }
            getTxIdxGroup() {
                return this.txIdxGroup;
            }
            getOpBeforePrint() {
                return this.opBeforePrint;
            }
            getOpAfterPrint() {
                return this.opAfterPrint;
            }
            getChkCanGrow() {
                return this.chkCanGrow;
            }
            getTxFormat() {
                return this.txFormat;
            }
            getTxSymbol() {
                return this.txSymbol;
            }
            getChkWordWrap() {
                return this.chkWordWrap;
            }
            getTxBorderColor() {
                return this.txBorderColor;
            }
            getShBorderColor() {
                return this.shBorderColor;
            }
            getTxBorder3D() {
                return this.txBorder3D;
            }
            getShBorder3D() {
                return this.shBorder3D;
            }
            getTxBorderShadow() {
                return this.txBorderShadow;
            }
            getShBorderShadow() {
                return this.shBorderShadow;
            }
            getChkBorderRounded() {
                return this.chkBorderRounded;
            }
            getTxBorderWidth() {
                return this.txBorderWidth;
            }
            getCbBorderType() {
                return this.cbBorderType;
            }
            getTxLeft() {
                return this.txLeft;
            }
            getTxTop() {
                return this.txTop;
            }
            getTxWidth() {
                return this.txWidth;
            }
            getTxHeight() {
                return this.txHeight;
            }
            getTxBackColor() {
                return this.txBackColor;
            }
            getShBackColor() {
                return this.shBackColor;
            }
            getChkTransparent() {
                return this.chkTransparent;
            }
            getCbAlign() {
                return this.cbAlign;
            }
            getCbType() {
                return this.cbType;
            }
            getCbChartSize() {
                return this.cbChartSize;
            }
            getCbChartThickness() {
                return this.cbChartThickness;
            }
            getCbLinesType() {
                return this.cbLinesType;
            }
            getTxChartTop() {
                return this.txChartTop;
            }
            getTxDbFieldGroupValue() {
                return this.txChartDbFieldGroup;
            }
            getTxChartGroupValue() {
                return this.txChartGroupValue;
            }
            getChkShowOutlines() {
                return this.chkShowOutlines;
            }
            getChkSort() {
                return this.chkSort;
            }
            getChkShowBarValues() {
                return this.chkShowBarValues;
            }
            getTxDbFieldLbl1() {
                return this.txChartDbFieldLbl1;
            }
            getTxDbFieldVal1() {
                return this.txChartDbFieldVal1;
            }
            getCbColorSerie1() {
                return this.cbColorSerie1;
            }
            getTxDbFieldLbl2() {
                return this.txChartDbFieldLbl2;
            }
            getTxDbFieldVal2() {
                return this.txChartDbFieldVal2;
            }
            getCbColorSerie2() {
                return this.cbColorSerie2;
            }
            getTxSectionName() {
                return this.txSectionName;
            }
            getLbSectionLineName() {
                return this.lbSectionLineName;
            }
            getChkSectionFormulaHide() {
                return this.chkSectionFormulaHide;
            }
            getChkSectionLineFormulaHide() {
                return this.chkSectionLineFormulaHide;
            }
            getTxGroupName() {
                return this.txGroupName;
            }
            getTxGroupDbField() {
                return this.txGroupDbField;
            }
            getOpAsc() {
                return this.opAsc;
            }
            getOpDesc() {
                return this.opDesc;
            }
            getChkPrintInNewPage() {
                return this.chkPrintInNewPage;
            }
            getChkReprintGroup() {
                return this.chkReprintGroup;
            }
            getChkGrandTotal() {
                return this.chkGrandTotal;
            }
            getOpDate() {
                return this.opDate;
            }
            getOpNumber() {
                return this.opNumber;
            }
            getOpText() {
                return this.opText;
            }
            clear() {
                this.lbControl.setText("");
                this.txName.setText("");
                this.txText.setText("");
                this.txTag.setText("");
                this.cbFont.setText("");
                this.txFontSize.setText("");
                this.cbAlign.setText("");
                this.chkFontBold.setChecked(false);
                this.chkFontUnderline.setChecked(false);
                this.chkFontItalic.setChecked(false);
                this.chkFontStrike.setChecked(false);
                this.txForeColor.setText("");
                this.shForeColor.setBackColor(null);
                this.chkTransparent.setChecked(false);
                this.txBackColor.setText("");
                this.shBackColor.setBackColor(null);
                this.txSymbol.setText("");
                this.txFormat.setText("");
                this.txLeft.setText("");
                this.txTop.setText("");
                this.txWidth.setText("");
                this.txHeight.setText("");
                this.chkCanGrow.setChecked(false);
                this.chkIsFreeCtrl.setChecked(false);
                this.txExportColIdx.setText("");
                this.chkFormulaHide.setChecked(false);
                this.lbFormulaHide.setText("");
                this.chkFormulaValue.setChecked(false);
                this.lbFormulaValue.setText("");
                this.txIdxGroup.setText("");
                this.txImageFile.setText("");
                this.picImage.setImage(null);
                this.txDbField.setText("");
                this.cbBorderType.setText("");
                this.txBorderColor.setText("");
                this.shBorderColor.setBackColor(null);
                this.txBorder3D.setText("");
                this.shBorder3D.setBackColor(null);
                this.txBorderShadow.setText("");
                this.shBorderShadow.setBackColor(null);
                this.txBorderWidth.setText("");
                this.chkBorderRounded.setChecked(false);
                this.txSectionName.setText("");
                this.txGroupName.setText("");
                this.txGroupDbField.setText("");
                this.chkPrintInNewPage.setChecked(false);
                this.chkReprintGroup.setChecked(false);
                this.chkGrandTotal.setChecked(false);
                this.opAsc.setChecked(false);
                this.opDesc.setChecked(false);
                this.opNumber.setChecked(false);
                this.opDate.setChecked(false);
                this.opText.setChecked(false);
            }
            selectTab(tab) {
                this.currentTab = tab;
                U.el('property-format-tab').style.display = tab === 'property-format-tab' ? 'block' : 'none';
                U.el('property-formulas-tab').style.display = tab === 'property-formulas-tab' ? 'block' : 'none';
                U.el('property-database-tab').style.display = tab === 'property-database-tab' ? 'block' : 'none';
                U.el('property-borders-tab').style.display = tab === 'property-borders-tab' ? 'block' : 'none';
                U.el('property-image-tab').style.display = tab === 'property-image-tab' ? 'block' : 'none';
                U.el('property-chart-tab').style.display = tab === 'property-chart-tab' ? 'block' : 'none';
                U.el('property-section-tab').style.display = tab === 'property-section-tab' ? 'block' : 'none';
                U.el('property-group-tab').style.display = tab === 'property-group-tab' ? 'block' : 'none';
                U.el('property-format-tab-selector').style.backgroundColor = tab === 'property-format-tab' ? '#111' : '#494947';
                U.el('property-formulas-tab-selector').style.backgroundColor = tab === 'property-formulas-tab' ? '#111' : '#494947';
                U.el('property-database-tab-selector').style.backgroundColor = tab === 'property-database-tab' ? '#111' : '#494947';
                U.el('property-borders-tab-selector').style.backgroundColor = tab === 'property-borders-tab' ? '#111' : '#494947';
                U.el('property-image-tab-selector').style.backgroundColor = tab === 'property-image-tab' ? '#111' : '#494947';
                U.el('property-chart-tab-selector').style.backgroundColor = tab === 'property-chart-tab' ? '#111' : '#494947';
                U.el('property-section-tab-selector').style.backgroundColor = tab === 'property-section-tab' ? '#111' : '#494947';
                U.el('property-group-tab-selector').style.backgroundColor = tab === 'property-group-tab' ? '#111' : '#494947';
            }
            setDbField(result) {
                if (result.success) {
                    this.txDbField.setText(result.field);
                    this.setFieldType(result.fieldType);
                    this.setIndex(result.fieldIndex);
                    this.dbFieldChanged = true;
                    this.lockEditor();
                    return true;
                }
                else {
                    return false;
                }
            }
            setChartGroupDbField(result) {
                if (result.success) {
                    this.txChartDbFieldGroup.setText(result.field);
                    this.setChartGroupFieldType(result.fieldType);
                    this.setChartGroupIndex(result.fieldIndex);
                    this.chartFieldGroupChanged = true;
                    this.lockEditor();
                    return true;
                }
                else {
                    return false;
                }
            }
            setChartSerie1DbFieldLabel(result) {
                if (result.success) {
                    this.txChartDbFieldLbl1.setText(result.field);
                    this.setChartFieldType(0, result.fieldType);
                    this.setChartIndex(0, result.fieldIndex);
                    this.chartFieldLbl1Changed = true;
                    this.lockEditor();
                    return true;
                }
                else {
                    return false;
                }
            }
            setChartSerie1DbFieldValue(result) {
                if (result.success) {
                    this.txChartDbFieldVal1.setText(result.field);
                    this.setChartFieldType(1, result.fieldType);
                    this.setChartIndex(1, result.fieldIndex);
                    this.chartFieldVal1Changed = true;
                    this.lockEditor();
                    return true;
                }
                else {
                    return false;
                }
            }
            setChartSerie2DbFieldLabel(result) {
                if (result.success) {
                    this.txChartDbFieldLbl2.setText(result.field);
                    this.setChartFieldType(2, result.fieldType);
                    this.setChartIndex(2, result.fieldIndex);
                    this.chartFieldLbl2Changed = true;
                    this.lockEditor();
                    return true;
                }
                else {
                    return false;
                }
            }
            setChartSerie2DbFieldValue(result) {
                if (result.success) {
                    this.txChartDbFieldVal2.setText(result.field);
                    this.setChartFieldType(3, result.fieldType);
                    this.setChartIndex(3, result.fieldIndex);
                    this.chartFieldVal2Changed = true;
                    this.lockEditor();
                    return true;
                }
                else {
                    return false;
                }
            }
            selectDbField(field, f) {
                this.editor.showHelpDbField3(field).then((result) => f.apply(this, [result]));
            }
        }
        PropertyDlg.CTRL_TABS = [
            "property-format-tab",
            "property-formulas-tab",
            "property-borders-tab",
            "property-database-tab",
            "property-image-tab",
            "property-chart-tab"
        ];
        PropertyDlg.SECTION_TABS = [
            "property-section-tab",
            "property-group-tab"
        ];
        CSReportEditor.PropertyDlg = PropertyDlg;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSXml;
    (function (CSXml) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        var cDateUtils = CSReports.CSKernelClient.cDateUtils;
        class cXmlProperty {
            constructor() {
                this.name = "";
                this.value = "";
                this.parent = "";
                this.binaryValue = null;
            }
            getBinaryValue() {
                return this.binaryValue;
            }
            setBinaryValue(value) {
                if (value === null) {
                    this.binaryValue = null;
                }
                else {
                    if (Array.isArray(value)) {
                        let valueArray = value;
                        let newArray = [...valueArray];
                        this.binaryValue = newArray;
                    }
                    else if (value instanceof ArrayBuffer) {
                        this.binaryValue = new Uint8Array(value);
                    }
                    else {
                        this.binaryValue = null;
                    }
                }
            }
            getName() {
                return this.name;
            }
            setName(value) {
                this.name = value;
            }
            getValueInt(type) {
                return Math.trunc(this.getValue(type));
            }
            getValueString(type) {
                return this.getValue(type);
            }
            getValueBool(type) {
                return (this.getValue(type) !== 0);
            }
            getValue(type) {
                switch (type) {
                    case eTypes.eBoolean:
                        switch (this.value.toLowerCase()) {
                            case "true":
                            case "verdadero":
                            case "-1":
                            case "1":
                                return -1;
                            default:
                                return 0;
                        }
                    case eTypes.eDate:
                    case eTypes.eDateOrNull:
                        if (cDateUtils.isDate(this.value)) {
                            return this.value;
                        }
                        else {
                            return 0;
                        }
                    case eTypes.eLong:
                    case eTypes.eInteger:
                    case eTypes.eId:
                    case eTypes.eSingle:
                    case eTypes.eCurrency:
                        if (!Number.isNaN(this.value)) {
                            return Number(this.value);
                        }
                        else {
                            return 0;
                        }
                    case eTypes.eText:
                    case eTypes.eVariant:
                    case eTypes.eCuit:
                        return this.value;
                    default:
                        return this.value;
                }
            }
            setValue(type, value) {
                if (type === eTypes.eBoolean) {
                    this.value = value ? "-1" : "0";
                }
                else if (type === eTypes.eInteger) {
                    this.value = parseInt(value).toString();
                }
                else {
                    this.value = value.toString();
                }
            }
            setValue2(value) {
                if (typeof value === "boolean") {
                    this.value = value ? "-1" : "0";
                }
                else {
                    this.value = value.toString();
                }
            }
            getParent() {
                return this.parent;
            }
            setParent(parent) {
                this.parent = parent;
            }
        }
        CSXml.cXmlProperty = cXmlProperty;
    })(CSXml = CSReports.CSXml || (CSReports.CSXml = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSXml;
    (function (CSXml) {
        var cWindow = CSReports.CSKernelClient.cWindow;
        var MessageBoxDefaultButton = CSReports.CSKernelClient.MessageBoxDefaultButton;
        var cError = CSReports.CSKernelClient.cError;
        var eFileMode = CSReports.CSKernelClient.eFileMode;
        var eFileAccess = CSReports.CSKernelClient.eFileAccess;
        var eTypes = CSReports.CSKernelClient.eTypes;
        var cFile = CSReports.CSKernelFile.cFile;
        class cXml {
            constructor() {
                this.name = "";
                this.path = "";
                this.domDoc = new CSXml.XmlDocument();
                this.filter = "";
                this.createDomDoc();
            }
            createDomDoc() {
                this.domDoc = new CSXml.XmlDocument();
                let node = this.domDoc.createNode("Root", "");
                this.domDoc.appendChild(node);
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getPath() {
                let _rtn = "";
                if (this.path.substring(this.path.length - 1) === cFile.directorySeparatorChar()) {
                    _rtn = this.path;
                }
                else {
                    _rtn = this.path + cFile.directorySeparatorChar();
                }
                return _rtn;
            }
            setPath(rhs) {
                this.path = rhs;
            }
            getFilter() {
                return this.filter;
            }
            setFilter(rhs) {
                this.filter = rhs;
            }
            openXmlWithDialog() {
                let file = new CSReports.CSKernelFile.cFile();
                file.setFilter(this.filter);
                file.init("OpenXmlWithDialog");
                return file.userOpenFile().then((fc) => {
                    this.path = "{{unknown: running in browser}}";
                    this.name = fc.name;
                    this.domDoc.load(fc.content);
                    return true;
                });
            }
            saveInBrowser() {
                let file = new CSReports.CSKernelFile.cFile();
                return file.saveInBrowser(this.name, this.getXml(), 'text/xml');
            }
            openXml(xml = null) {
                try {
                    xml = xml || this.getXml();
                    this.domDoc.load(xml);
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            newXmlWithDialog() {
                try {
                    let msg = "";
                    let file = new CSReports.CSKernelFile.cFile();
                    file.init("NewXmlWithDialog");
                    file.setFilter(this.filter);
                    let bExists = false;
                    let bReadonly = false;
                    if (!file.save(this.name, bExists, bReadonly, "")) {
                        return false;
                    }
                    if (bExists && bReadonly) {
                        msg = "There is already a file with this name and it is read only. Do you want to replace this file?";
                    }
                    else if (bExists) {
                        if (this.name !== file.getName()) {
                            msg = "There is already a file with this name. Do you want to replace this file?";
                        }
                    }
                    if (msg !== "") {
                        if (!cWindow.ask(msg, MessageBoxDefaultButton.Button2)) {
                            return false;
                        }
                    }
                    this.name = file.getName();
                    this.path = file.getPath();
                    file = null;
                    return this.newXml();
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            newXml() {
                try {
                    this.createDomDoc();
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            saveWithDialog() {
                try {
                    let file = new CSReports.CSKernelFile.cFile();
                    if (!file.open(this.name, eFileMode.eWrite, false, false, eFileAccess.eLockWrite, false, false)) {
                        return false;
                    }
                    this.name = file.getName();
                    this.path = file.getPath();
                    file = null;
                    return this.save();
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            setNodeText(node, text) {
                node.value = text;
            }
            getXml() {
                const xml = new XMLSerializer().serializeToString(this.getRootNode().getDomNode());
                return xml.replace(' xmlns="http://www.w3.org/1999/xhtml"', '');
            }
            save() {
                try {
                    this.domDoc.save(this.getPath() + this.name);
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            addProperty(xProperty) {
                return this.addPropertyToNodeByTag("Root", xProperty);
            }
            addPropertyToNodeByTag(nodeTag, xProperty) {
                let element = this.domDoc.getElementsByTagName(nodeTag);
                return this.addPropertyToNode(element[0], xProperty);
            }
            addPropertyToNode(node, xProperty) {
                let attr = this.domDoc.createAttribute(xProperty.getName());
                attr.value = xProperty.getValueString(eTypes.eVariant);
                node.addAttribute(attr);
                return true;
            }
            addBinaryPropertyToNode(node, xProperty) {
                let attr = this.domDoc.createAttribute(xProperty.getName());
                attr.value = btoa(xProperty.getBinaryValue());
                node.addAttribute(attr);
                return true;
            }
            addNode(xProperty) {
                return this.addNodeToNodeByTag("Root", xProperty);
            }
            addNodeToNodeByTag(nodeTag, xProperty) {
                let element = this.domDoc.getElementsByTagName(nodeTag);
                return this.addNodeToNode(element[0], xProperty);
            }
            addNodeToNode(nodeFather, xProperty) {
                let node = this.domDoc.createNode(xProperty.getName(), "");
                nodeFather.appendChild(node);
                return node;
            }
            getRootNode() {
                if (this.domDoc.getElementsByTagName("Root").length > 0) {
                    return this.domDoc.getElementsByTagName("Root")[0];
                }
                else {
                    return null;
                }
            }
            getNode(nodeTag) {
                if (this.domDoc.getElementsByTagName(nodeTag).length > 0) {
                    return this.domDoc.getElementsByTagName(nodeTag)[0];
                }
                else {
                    return null;
                }
            }
            getNodeFromNode(node, nodeTag) {
                return node.selectSingleNode(nodeTag);
            }
            getNodeChild(node) {
                if (this.nodeHasChild(node)) {
                    return node.getChildNodes()[0];
                }
                else {
                    return null;
                }
            }
            getNextNode(node) {
                return node.getNextSibling();
            }
            getNodeValue(node) {
                let o = new CSXml.cXmlProperty();
                o.setValue(eTypes.eText, node.name);
                return o;
            }
            getNodeProperty(node, propertyName) {
                try {
                    let o = new CSXml.cXmlProperty();
                    let txt = "";
                    if (node.attributeByName(propertyName) !== null) {
                        txt = node.attributeByName(propertyName).value;
                    }
                    o.setValue(eTypes.eVariant, txt);
                    return o;
                }
                catch (ex) {
                    cError.mngError(ex);
                    throw ex;
                }
            }
            getBinaryNodeProperty(node, propertyName) {
                let o = new CSXml.cXmlProperty();
                let vBuffer;
                let attr = node.attributeByName(propertyName);
                if (attr !== null) {
                    vBuffer = cXml.base64ToArrayBuffer(attr.value);
                }
                else {
                    vBuffer = [];
                }
                o.setBinaryValue(vBuffer);
                return o;
            }
            static base64ToArrayBuffer(base64) {
                let binaryString = atob(base64);
                let bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }
            nodeHasChild(node) {
                return node.getChildNodes().length > 0;
            }
        }
        CSXml.cXml = cXml;
    })(CSXml = CSReports.CSXml || (CSReports.CSXml = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var RptGrpComparisonType = CSReports.CSReportGlobals.RptGrpComparisonType;
        var RptGrpOrderType = CSReports.CSReportGlobals.RptGrpOrderType;
        var DatabaseEngine = CSReports.CSDatabase.DatabaseEngine;
        var csRptSectionType = CSReports.CSReportGlobals.csRptSectionType;
        var csRptNewPageResult = CSReports.CSReportGlobals.csRptNewPageResult;
        var csRptWhenEval = CSReports.CSReportGlobals.csRptWhenEval;
        var csRptEndPageResult = CSReports.CSReportGlobals.csRptEndPageResult;
        var csRptGetLineResult = CSReports.CSReportGlobals.csRptGetLineResult;
        var cError = CSReports.CSKernelClient.cError;
        var RefWrapper = CSReports.CSKernelClient.RefWrapper;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        var U = CSReports.CSOAPI.Utils;
        var csRptControlType = CSReports.CSReportGlobals.csRptControlType;
        var csRptErrors = CSReports.CSReportGlobals.csRptErrors;
        var csRptLaunchAction = CSReports.CSReportGlobals.csRptLaunchAction;
        var cFile = CSReports.CSKernelFile.cFile;
        var eTypes = CSReports.CSKernelClient.eTypes;
        var cXmlProperty = CSReports.CSXml.cXmlProperty;
        var cXml = CSReports.CSXml.cXml;
        var DataTable = CSReports.CSDatabase.DataTable;
        var Map = CSReports.CSOAPI.Map;
        var Bitmap = CSReports.CSDrawing.Bitmap;
        var Image = CSReports.CSDrawing.ImageX;
        var CMouseWait = CSReports.CSKernelClient.CMouseWait;
        var DataType = CSReports.CSDatabase.DataType;
        var csRptFormulaType = CSReports.CSReportGlobals.csRptFormulaType;
        var csReportPaperType = CSReports.CSReportGlobals.csReportPaperType;
        var cWindow = CSReports.CSKernelClient.cWindow;
        var csDataSourceType = CSReports.CSReportGlobals.csDataSourceType;
        var P = CSReports.CSKernelClient.Callable;
        class T_Group {
            constructor() {
                this.first = null;
                this.last = null;
            }
        }
        CSReportEngine.T_Group = T_Group;
        class T_Groups {
            constructor() {
                this.value = null;
                this.indexField = null;
                this.changed = null;
                this.reprintHeader = null;
                this.footerMustBeClosed = null;
                this.comparisonType = null;
                this.oderType = null;
                this.grandTotalGroup = null;
                this.groups = null;
                this.lastHPreRowEvaluated = null;
                this.lastHPostRowEvaluated = null;
                this.lastFPreRowEvaluated = null;
                this.lastFPostRowEvaluated = null;
                this.lineNumber = null;
            }
        }
        CSReportEngine.T_Groups = T_Groups;
        class cReport {
            constructor() {
                this.HEADERS = 1;
                this.FOOTERS = 2;
                this.NODE_RPT_HEADERS = "RptHeaders";
                this.NODE_RPT_DETAILS = "RptDetails";
                this.NODE_GROUPS = "RptGroups";
                this.NODE_RPT_FOOTERS = "RptFooters";
                this.RPT_CONNECT = "RptConnect";
                this.NODE_RPT_FORMULAS = "RptFormulas";
                this.NODE_RPT_PAGES_SETTING = "RptPagesSetting";
                this.NODE_RPT_PAGES = "RptPages";
                this.NODE_PAPER_INFO = "PaperInfo";
                this.FILE_EX = "CrowSoft Report|*.csr| Archivos Xml|*.xml";
                this.FILE_DATA_EX = "CrowSoft Report data|*.csd| Archivos Xml|*.xml";
                this.IDX_GROUP_HEADER = -1000;
                this.IDX_GROUP_DETAIL = 0;
                this.IDX_GROUP_FOOTER = -1001;
                this.IDX_GROUP_REPORT_HEADER = -2000;
                this.IDX_GROUP_REPORT_FOOTER = -2001;
                this.IDX_H_LAST_ROW_EVALUATED = 0;
                this.IDX_D_LAST_ROW_EVALUATED = 1;
                this.IDX_F_LAST_ROW_EVALUATED = 2;
                this.IDX_G_LAST_ROW_EVALUATED = -1;
                this.launchInfo = null;
                this.groups = null;
                this.details = null;
                this.headers = null;
                this.footers = null;
                this.groupsHeaders = null;
                this.groupsFooters = null;
                this.paperInfo = null;
                this.originalHeight = 0;
                this.controls = null;
                this.formulas = null;
                this.formulaTypes = null;
                this.name = "";
                this.path = "";
                this.pathDefault = "";
                this.userDescription = "";
                this.connect = null;
                this.connectsAux = null;
                this.pageSetting = null;
                this.pages = null;
                this.compiler = null;
                this.reportDisconnected = null;
                this.tables = null;
                this.images = null;
                this.table = null;
                this.recordCount = 0;
                this.vRowsIndex = null;
                this.lastRowIndex = -1;
                this.vRowsIndexAux = null;
                this.iRow = 0;
                this.iRow2 = 0;
                this.iRowFormula = 0;
                this.lineIndex = 0;
                this.lastRowPreEvaluated = null;
                this.lastRowPostEvaluated = null;
                this.bExistsGrpToRePrintInNP = null;
                this.bHaveToRePrintGroup = null;
                this.NO_GROUP_INDEX = 0;
                this.idxGroupToPrintNP = this.NO_GROUP_INDEX;
                this.idxGroupHeader = this.NO_GROUP_INDEX;
                this.idxGroupFooter = this.NO_GROUP_INDEX;
                this.bPrintFooter = null;
                this.bLastFootersWasPrinted = null;
                this.groupIndexChange = this.NO_GROUP_INDEX;
                this.bEvalPreGroups = null;
                this.bCloseFooter = null;
                this.bOpenHeader = null;
                this.lineNumber = 0;
                this.vGroups = null;
                this.firstGroup = null;
                this.groupCount = 0;
                this.isForWeb = null;
                this.databaseEngine = DatabaseEngine.SQL_SERVER;
                this.exportEmailAddress = "";
                this.runningInWebWorker = false;
                try {
                    this.headers = new CSReportEngine.cReportSections();
                    this.details = new CSReportEngine.cReportSections();
                    this.footers = new CSReportEngine.cReportSections();
                    this.groups = new CSReportEngine.cReportGroups();
                    this.groupsHeaders = this.getGroups().getGroupsHeaders();
                    this.groupsFooters = this.getGroups().getGroupsFooters();
                    this.paperInfo = new CSReportEngine.cReportPaperInfo();
                    this.controls = new CSReportEngine.cReportControls2();
                    this.formulas = new CSReportEngine.cReportFormulas();
                    this.formulaTypes = new CSReportEngine.cReportFormulaTypes();
                    this.connect = new CSReportEngine.cReportConnect();
                    this.pageSetting = new CSReportEngine.cReportPageSettings();
                    this.pages = new CSReportEngine.cReportPages();
                    this.compiler = new CSReportEngine.cReportCompiler();
                    this.setConnectsAux(new CSReportEngine.cReportConnectsAux());
                    this.details.setCopyColl(this.controls);
                    this.headers.setCopyColl(this.controls);
                    this.footers.setCopyColl(this.controls);
                    this.groupsHeaders.setCopyColl(this.controls);
                    this.groupsFooters.setCopyColl(this.controls);
                    this.details.setTypeSection(csRptSectionType.DETAIL);
                    this.headers.setTypeSection(csRptSectionType.HEADER);
                    this.footers.setTypeSection(csRptSectionType.FOOTER);
                    this.groupsHeaders.setTypeSection(csRptSectionType.GROUP_HEADER);
                    this.groupsFooters.setTypeSection(csRptSectionType.GROUP_FOOTER);
                    this.details.setMainTypeSection(csRptSectionType.MAIN_DETAIL);
                    this.headers.setMainTypeSection(csRptSectionType.MAIN_HEADER);
                    this.footers.setMainTypeSection(csRptSectionType.MAIN_FOOTER);
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            getExportEmailAddress() {
                return this.exportEmailAddress;
            }
            setExportEmailAddress(rhs) {
                this.exportEmailAddress = rhs;
            }
            getIsForWeb() {
                return this.isForWeb;
            }
            setIsForWeb(rhs) {
                this.isForWeb = rhs;
            }
            setDatabaseEngine(databaseEngine) {
                this.databaseEngine = databaseEngine;
            }
            getConnectsAux() {
                return this.connectsAux;
            }
            setConnectsAux(rhs) {
                this.connectsAux = rhs;
            }
            getGroups() {
                return this.groups;
            }
            setGroups(rhs) {
                this.groups = rhs;
            }
            getDetails() {
                return this.details;
            }
            setDetails(rhs) {
                this.details = rhs;
            }
            getHeaders() {
                return this.headers;
            }
            setHeaders(rhs) {
                this.headers = rhs;
            }
            getFooters() {
                return this.footers;
            }
            setFooters(rhs) {
                this.footers = rhs;
            }
            getGroupsHeaders() {
                return this.groupsHeaders;
            }
            getGroupsFooters() {
                return this.groupsFooters;
            }
            getPaperInfo() {
                return this.paperInfo;
            }
            setPaperInfo(rhs) {
                this.paperInfo = rhs;
            }
            getControls() {
                return this.controls;
            }
            getFormulas() {
                return this.formulas;
            }
            getFormulaTypes() {
                return this.formulaTypes;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getPath() {
                return this.path;
            }
            setPathDefault(rhs) {
                this.pathDefault = rhs;
            }
            getConnect() {
                return this.connect;
            }
            getPages() {
                return this.pages;
            }
            setPages(pages) {
                this.pages = pages;
            }
            getPageSetting() {
                return this.pageSetting;
            }
            setPageSetting(rhs) {
                this.pageSetting = rhs;
            }
            getLaunchInfo() {
                return this.launchInfo;
            }
            getCompiler() {
                return this.compiler;
            }
            getReportDisconnected() {
                return this.reportDisconnected;
            }
            setReportDisconnected(value) {
                this.reportDisconnected = value;
            }
            getDescripUser() {
                return this.userDescription;
            }
            setDescripUser(value) {
                this.userDescription = value;
            }
            getCurrenPage() {
                return this.pages.count();
            }
            getTotalPages() {
                return this.pages.count();
            }
            moveGroup(from, to) {
                if (from < 1 || from > this.groups.count()) {
                    return false;
                }
                if (to < 1 || to > this.groups.count()) {
                    return false;
                }
                if (from !== to) {
                    let group = null;
                    let collGroups = new CSReportEngine.cReportGroups();
                    for (let _i = 0; _i < this.groups.count(); _i++) {
                        group = this.groups.item(_i);
                        collGroups.add(group, group.getKey());
                    }
                    this.groups.clear();
                    let index = 0;
                    for (let _i = 0; _i < collGroups.count(); _i++) {
                        group = collGroups.item(_i);
                        index = index + 1;
                        if (index !== from) {
                            if (index === to) {
                                let group2 = collGroups.item(from);
                                this.groups.add2(group2, group2.getKey());
                            }
                            this.groups.add2(group, group.getKey());
                        }
                    }
                }
                return true;
            }
            newPage() {
                let page = this.pages.add(null, "");
                page.setPageNumber(this.pages.count());
                if (!this.progress("", this.pages.count(), 0, 0)) {
                    return csRptNewPageResult.CS_RPT_NP_ERROR;
                }
                if (this.pages.count() === 1) {
                    this.evalFunctions(this.IDX_GROUP_REPORT_HEADER, csRptWhenEval.CS_RPT_EVAL_PRE);
                }
                this.evalFunctions(this.IDX_GROUP_HEADER, csRptWhenEval.CS_RPT_EVAL_PRE);
                this.addFieldToNewPage(this.headers, page, this.HEADERS);
                this.evalFunctions(this.IDX_GROUP_HEADER, csRptWhenEval.CS_RPT_EVAL_POST);
                if (this.pages.count() === 1) {
                    this.evalFunctions(this.IDX_GROUP_REPORT_HEADER, csRptWhenEval.CS_RPT_EVAL_POST);
                }
                page.setHeaderBottom(this.getHeightHeader());
                page.setFooterTop(this.getTopFooter());
                if (this.table === null) {
                    return csRptNewPageResult.CS_RPT_NP_END;
                }
                else if (this.iRow > this.lastRowIndex) {
                    return csRptNewPageResult.CS_RPT_NP_END;
                }
                if (this.bExistsGrpToRePrintInNP) {
                    this.bHaveToRePrintGroup = true;
                    this.markGroupHeadersToReprint();
                }
                return csRptNewPageResult.CS_RPT_NP_SUCCESS;
            }
            markGroupHeadersToReprint() {
                if (this.firstGroup) {
                    return;
                }
                for (let i = 0; i < this.groupCount; i++) {
                    if (this.groups.item(i).getRePrintInNewPage()) {
                        this.vGroups[i].reprintHeader = true;
                    }
                }
            }
            existsGroupHeadersToReprint() {
                for (let i = 0; i < this.groupCount; i++) {
                    if (this.vGroups[i].reprintHeader) {
                        this.idxGroupHeader = i + 1;
                        this.bOpenHeader = true;
                        return true;
                    }
                }
                this.bHaveToRePrintGroup = false;
                return false;
            }
            checkExistsGroupHToReprint() {
                for (let i = 0; i < this.groupCount; i++) {
                    if (this.vGroups[i].reprintHeader) {
                        return;
                    }
                }
                this.bHaveToRePrintGroup = false;
            }
            endPage() {
                let page = this.pages.item(this.pages.count() - 1);
                this.evalFunctions(this.IDX_GROUP_FOOTER, csRptWhenEval.CS_RPT_EVAL_PRE);
                this.addFieldToNewPage(this.footers, page, this.FOOTERS);
                this.evalFunctions(this.IDX_GROUP_FOOTER, csRptWhenEval.CS_RPT_EVAL_POST);
                return csRptEndPageResult.CS_RPT_EP_SUCCESS;
            }
            markGroupHeaderPrinted() {
                if (this.vGroups[this.idxGroupHeader - 1].reprintHeader) {
                    this.vGroups[this.idxGroupHeader - 1].reprintHeader = false;
                    this.checkExistsGroupHToReprint();
                    if (this.notPendingFooters()) {
                        this.markGroupHeaderPrintedAux();
                    }
                }
                else if (this.vGroups[this.idxGroupHeader - 1].changed) {
                    this.markGroupHeaderPrintedAux();
                }
            }
            markGroupHeaderPrintedAux() {
                this.vGroups[this.idxGroupHeader - 1].changed = false;
                if (this.idxGroupToPrintNP === this.idxGroupHeader) {
                    this.idxGroupToPrintNP = this.NO_GROUP_INDEX;
                }
                let headerSec = this.groups.item(this.idxGroupHeader - 1).getHeader();
                for (let _i = 0; _i < headerSec.getSectionLines().count(); _i++) {
                    let secLn = headerSec.getSectionLines().item(_i);
                    for (let _j = 0; _j < secLn.getControls().count(); _j++) {
                        let ctrl = secLn.getControls().item(_j);
                        if (ctrl.getHasFormulaHide()) {
                            this.compiler.initVariable(ctrl.getFormulaHide());
                        }
                        if (ctrl.getHasFormulaValue()) {
                            this.compiler.initVariable(ctrl.getFormulaValue());
                        }
                    }
                }
            }
            markGroupFooterPrinted() {
                this.vGroups[this.idxGroupFooter - 1].footerMustBeClosed = false;
                let footerSec = this.groups.item(this.idxGroupFooter - 1).getFooter();
                for (let _i = 0; _i < footerSec.getSectionLines().count(); _i++) {
                    let secLn = footerSec.getSectionLines().item(_i);
                    for (let _j = 0; _j < secLn.getControls().count(); _j++) {
                        let ctrl = secLn.getControls().item(_j);
                        if (ctrl.getHasFormulaHide()) {
                            this.compiler.initVariable(ctrl.getFormulaHide());
                        }
                        if (ctrl.getHasFormulaValue()) {
                            this.compiler.initVariable(ctrl.getFormulaValue());
                        }
                    }
                }
                if (this.notPendingFooters()) {
                    this.iRowFormula = this.iRow;
                    this.iRow2 = this.iRow;
                }
            }
            evalPost() {
                this.evalFunctions(this.IDX_GROUP_DETAIL, csRptWhenEval.CS_RPT_EVAL_POST);
            }
            evalPreGroupHeader() {
                if (this.idxGroupHeader !== this.NO_GROUP_INDEX) {
                    this.evalFunctions(this.idxGroupHeader, csRptWhenEval.CS_RPT_EVAL_PRE);
                }
            }
            evalPreGroupFooter() {
                if (this.idxGroupHeader !== this.NO_GROUP_INDEX) {
                    let idxChildGroupFooter = this.getChildGroupFooterToClose(this.idxGroupHeader);
                    while (idxChildGroupFooter > this.idxGroupHeader) {
                        this.evalFunctions(idxChildGroupFooter * -1, csRptWhenEval.CS_RPT_EVAL_PRE);
                        idxChildGroupFooter = idxChildGroupFooter - 1;
                    }
                    this.evalFunctions(this.idxGroupHeader * -1, csRptWhenEval.CS_RPT_EVAL_PRE);
                }
            }
            evalPostGroupHeader() {
                if (this.idxGroupHeader === this.NO_GROUP_INDEX) {
                    return;
                }
                this.evalFunctions(this.idxGroupHeader, csRptWhenEval.CS_RPT_EVAL_POST);
            }
            evalPostGroupFooter() {
                if (this.idxGroupHeader !== this.NO_GROUP_INDEX) {
                    let idxChildGroupFooter = 0;
                    idxChildGroupFooter = this.getChildGroupFooterToClose(this.idxGroupHeader);
                    while (idxChildGroupFooter > this.idxGroupHeader) {
                        this.evalFunctions(idxChildGroupFooter * -1, csRptWhenEval.CS_RPT_EVAL_POST);
                        idxChildGroupFooter = idxChildGroupFooter - 1;
                    }
                    this.evalFunctions(this.idxGroupHeader * -1, csRptWhenEval.CS_RPT_EVAL_POST);
                }
            }
            getChildGroupFooterToClose(idxGroupFather) {
                let groupIndex = 0;
                for (let j = idxGroupFather - 1; j < this.groupCount; j++) {
                    if (this.vGroups[j].footerMustBeClosed) {
                        groupIndex = j + 1;
                    }
                }
                return groupIndex;
            }
            evalPre() {
                this.evalFunctions(this.IDX_GROUP_DETAIL, csRptWhenEval.CS_RPT_EVAL_PRE);
            }
            moveToNext() {
                this.iRow = this.iRow + 1;
                this.iRow2 = this.iRow;
                this.iRowFormula = this.iRow;
                for (let indexRows = 0; indexRows < this.tables.length; indexRows++) {
                    let indexRow = this.vRowsIndexAux[indexRows] + 1;
                    if (this.tables[indexRows] !== null) {
                        if (indexRow < this.tables[indexRows].rows.length) {
                            this.vRowsIndexAux[indexRows] = indexRow;
                        }
                    }
                }
            }
            existsGroupToReprintInNP() {
                this.bExistsGrpToRePrintInNP = false;
                for (let i = 0; i < this.groupCount; i++) {
                    if (this.groups.item(i).getRePrintInNewPage()) {
                        this.bExistsGrpToRePrintInNP = true;
                        return;
                    }
                }
            }
            notPendingFooters() {
                for (let i = 0; i < this.groupCount; i++) {
                    if (this.vGroups[i].footerMustBeClosed) {
                        return false;
                    }
                }
                return true;
            }
            getLineType() {
                if (this.idxGroupFooter !== this.NO_GROUP_INDEX) {
                    if (this.vGroups[this.idxGroupFooter - 1].footerMustBeClosed) {
                        return csRptGetLineResult.CS_RPT_GL_GROUP_FOOTER;
                    }
                }
                if (this.idxGroupHeader !== this.NO_GROUP_INDEX) {
                    if (this.vGroups[this.idxGroupHeader - 1].changed) {
                        return csRptGetLineResult.CS_RPT_GL_GROUP_HEADER;
                    }
                }
                if (this.reportIsDone()) {
                    return csRptGetLineResult.CS_RPT_GL_END;
                }
                if (this.idxGroupToPrintNP > 0 || this.bHaveToRePrintGroup) {
                    return csRptGetLineResult.CS_RPT_GL_VIRTUAL_H;
                }
                if (this.evalFooterToClose2()) {
                    return csRptGetLineResult.CS_RPT_GL_VIRTUAL_F;
                }
                if (this.iRow > this.lastRowIndex && this.notPendingFooters()) {
                    return csRptGetLineResult.CS_RPT_GL_END;
                }
                if (this.getLineAuxPrintHeader()) {
                    return csRptGetLineResult.CS_RPT_GL_VIRTUAL_H;
                }
                return csRptGetLineResult.CS_RPT_GL_DETAIL;
            }
            getLine(fields) {
                let bGetNewPage = false;
                if (fields.get() !== null) {
                    fields.get().clear();
                }
                if (!(this.bCloseFooter || this.bOpenHeader)) {
                    if (!this.existsGroupHeadersToReprint()) {
                        let rslt = this.getLineWork(fields, bGetNewPage);
                        if (bGetNewPage) {
                            return csRptGetLineResult.CS_RPT_GL_NEW_PAGE;
                        }
                        else {
                            if (rslt === csRptGetLineResult.CS_RPT_GL_END || rslt === csRptGetLineResult.CS_RPT_GL_VIRTUAL_F) {
                                return rslt;
                            }
                        }
                    }
                }
                if (this.bCloseFooter) {
                    return this.getLineAuxGroupFooter(fields);
                }
                else if (this.bOpenHeader) {
                    return this.getLineAuxGroupHeader(bGetNewPage, fields);
                }
                else {
                    return this.getLineAuxDetail(fields);
                }
            }
            getLineWork(fields, bGetNewPage) {
                bGetNewPage = false;
                if (this.getLineAuxReportCancel() === csRptGetLineResult.CS_RPT_GL_END) {
                    return csRptGetLineResult.CS_RPT_GL_END;
                }
                let rslt = this.getLineWorkAuxReportEnd();
                if (rslt === csRptGetLineResult.CS_RPT_GL_END || rslt === csRptGetLineResult.CS_RPT_GL_VIRTUAL_F) {
                    return rslt;
                }
                fields.set(new CSReportEngine.cReportPageFields());
                if (this.idxGroupToPrintNP > 0) {
                    this.getLineAuxPrintGroupInNP();
                }
                else {
                    if (this.groupCount > 0) {
                        if (!this.bHaveToRePrintGroup) {
                            this.evalFooterToClose();
                        }
                        if (!this.bCloseFooter) {
                            if (this.getLineAuxReportIsDone() === csRptGetLineResult.CS_RPT_GL_END) {
                                return csRptGetLineResult.CS_RPT_GL_END;
                            }
                            this.getLineAuxDoGroups(bGetNewPage);
                        }
                    }
                }
                return csRptGetLineResult.CS_RPT_GL_NONE;
            }
            getLineAuxPrintGroupInNP() {
                this.idxGroupHeader = this.idxGroupToPrintNP;
                this.idxGroupToPrintNP = this.NO_GROUP_INDEX;
                this.bOpenHeader = true;
            }
            reportIsDone() {
                if (this.table === null || this.iRow > this.recordCount - 1) {
                    if (!this.bPrintFooter) {
                        return true;
                    }
                }
                return false;
            }
            getLineWorkAuxReportEnd() {
                if (this.table === null || this.iRow > this.recordCount - 1) {
                    if (this.iRow > this.recordCount - 1) {
                        this.iRow2 = this.recordCount - 1;
                    }
                    if (this.bPrintFooter) {
                        if (this.bEvalPreGroups) {
                            this.bEvalPreGroups = false;
                            return csRptGetLineResult.CS_RPT_GL_VIRTUAL_F;
                        }
                        else {
                            if (!this.bLastFootersWasPrinted) {
                                this.bLastFootersWasPrinted = true;
                                this.groupIndexChange = 1;
                                this.vGroups[this.vGroups.length - 1].footerMustBeClosed = true;
                            }
                        }
                    }
                    else {
                        this.reportDone();
                        return csRptGetLineResult.CS_RPT_GL_END;
                    }
                }
                return csRptGetLineResult.CS_RPT_GL_NONE;
            }
            getLineAuxReportCancel() {
                if (!this.progress("", 0, this.iRow, this.recordCount)) {
                    this.reportDone();
                    return csRptGetLineResult.CS_RPT_GL_END;
                }
                else {
                    return csRptGetLineResult.CS_RPT_GL_NONE;
                }
            }
            getLineAuxReportIsDone() {
                if (this.iRow > this.lastRowIndex && this.notPendingFooters()) {
                    this.reportDone();
                    this.bPrintFooter = false;
                    return csRptGetLineResult.CS_RPT_GL_END;
                }
                return csRptGetLineResult.CS_RPT_GL_NONE;
            }
            evalFooterToClose2() {
                for (let i = this.groupCount - 1; i > -1; i--) {
                    if (this.vGroups[i].footerMustBeClosed) {
                        return true;
                    }
                }
                return false;
            }
            evalFooterToClose() {
                for (let i = this.groupCount - 1; i > -1; i--) {
                    if (this.vGroups[i].footerMustBeClosed) {
                        this.idxGroupFooter = i + 1;
                        if (this.idxGroupFooter > this.groupIndexChange) {
                            this.vGroups[i - 1].footerMustBeClosed = true;
                        }
                        this.bCloseFooter = true;
                        break;
                    }
                }
                return this.bCloseFooter;
            }
            getLineAuxPrintHeader() {
                for (let i = 0; i < this.groupCount; i++) {
                    if (!this.vGroups[i].grandTotalGroup) {
                        if (this.vGroups[i].value === null) {
                            return true;
                        }
                        let col = this.vGroups[i].indexField;
                        let row = this.vRowsIndex[this.iRow2];
                        switch (this.vGroups[i].comparisonType) {
                            case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                let text = ReportGlobals.valVariant(this.table.rows[row][col]).toString().toLowerCase();
                                if (this.vGroups[i].value.toString() !== text) {
                                    return true;
                                }
                                break;
                            case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                let number = U.val(ReportGlobals.valVariant(this.table.rows[row][col]));
                                if (this.vGroups[i].value !== number) {
                                    return true;
                                }
                                break;
                            case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                let date = ReportGlobals.dateValue(ReportGlobals.valVariant(this.table.rows[row][col]));
                                if (this.vGroups[i].value !== date) {
                                    return true;
                                }
                                break;
                        }
                    }
                }
                return false;
            }
            orderDateAsc(first, last, orderBy) {
                let t = 0;
                let q = 0;
                let bChanged = false;
                t = this.estimateLoops(last - first);
                for (let i = first + 1; i <= last; i++) {
                    bChanged = false;
                    for (let j = last; j >= i; j--) {
                        q = q + 1;
                        let row1 = this.vRowsIndex[j];
                        let row2 = this.vRowsIndex[j - 1];
                        let date1 = ReportGlobals.dateValue(ReportGlobals.valVariant(this.table.rows[row1][orderBy]));
                        let date2 = ReportGlobals.dateValue(ReportGlobals.valVariant(this.table.rows[row2][orderBy]));
                        if (date1 < date2) {
                            if (!this.progress("", 0, q, t)) {
                                return false;
                            }
                            this.changeRow(j, j - 1);
                            bChanged = true;
                        }
                    }
                    if (!this.progress("", 0, q, t)) {
                        return false;
                    }
                    if (!bChanged) {
                        break;
                    }
                }
                return true;
            }
            orderDateDesc(first, last, orderBy) {
                let t = 0;
                let q = 0;
                let bChanged = false;
                t = this.estimateLoops(last - first);
                for (let i = first + 1; i <= last; i++) {
                    bChanged = false;
                    for (let j = last; j >= i; j--) {
                        q = q + 1;
                        let row1 = this.vRowsIndex[j];
                        let row2 = this.vRowsIndex[j - 1];
                        let date1 = ReportGlobals.dateValue(ReportGlobals.valVariant(this.table.rows[row1][orderBy]));
                        let date2 = ReportGlobals.dateValue(ReportGlobals.valVariant(this.table.rows[row2][orderBy]));
                        if (date1 > date2) {
                            if (!this.progress("", 0, q, t)) {
                                return false;
                            }
                            this.changeRow(j, j - 1);
                            bChanged = true;
                        }
                    }
                    if (!this.progress("", 0, q, t)) {
                        return false;
                    }
                    if (!bChanged) {
                        break;
                    }
                }
                return true;
            }
            getLineAuxDoGroups(bGetNewPage) {
                for (let i = 0; i < this.groupCount; i++) {
                    if (this.vGroups[i].changed) {
                        this.groupChanged(i, bGetNewPage);
                        break;
                    }
                    else {
                        this.evalGroupChange(i);
                        if (this.vGroups[i].changed) {
                            this.idxGroupHeader = i + 1;
                            if (this.firstGroup) {
                                this.openGroupHeader(i);
                            }
                            else {
                                this.closeGroupFooters(i);
                            }
                            break;
                        }
                    }
                }
            }
            closeGroupFooters(i) {
                this.groupIndexChange = i + 1;
                this.bCloseFooter = true;
                this.idxGroupFooter = this.groupCount;
                for (let j = this.groupIndexChange - 1; j < this.idxGroupFooter; j++) {
                    this.vGroups[j].footerMustBeClosed = true;
                }
            }
            openGroupHeader(i) {
                this.bLastFootersWasPrinted = false;
                this.vGroups[i].changed = false;
                this.idxGroupHeader = i + 1;
                if (i < this.groupCount - 1) {
                    this.vGroups[i + 1].changed = true;
                }
                this.bOpenHeader = true;
            }
            changeGroup(i, value) {
                this.vGroups[i].value = value;
                this.vGroups[i].changed = true;
                if (!this.firstGroup) {
                    this.vGroups[i].footerMustBeClosed = true;
                }
                this.evalGroupChangedAux(i + 1);
            }
            evalGroupChange(i) {
                if (this.vGroups[i].grandTotalGroup) {
                    if (this.vGroups[i].value === null) {
                        this.changeGroup(i, "1");
                    }
                }
                else {
                    let col = this.vGroups[i].indexField;
                    let row = this.vRowsIndex[this.iRow2];
                    switch (this.vGroups[i].comparisonType) {
                        case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                            let text = ReportGlobals.valVariant(this.table.rows[row][col]).toString().toLowerCase();
                            if (this.vGroups[i].value === null) {
                                this.changeGroup(i, text);
                            }
                            else if (this.vGroups[i].value.toString() !== text) {
                                this.changeGroup(i, text);
                            }
                            break;
                        case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                            let num = U.val(ReportGlobals.valVariant(this.table.rows[row][col]));
                            if (this.vGroups[i].value === null) {
                                this.changeGroup(i, num);
                            }
                            else if (this.vGroups[i].value !== num) {
                                this.changeGroup(i, num);
                            }
                            break;
                        case RptGrpComparisonType.CS_RPT_GRP_DATE:
                            let date = ReportGlobals.dateValue(ReportGlobals.valVariant(this.table.rows[row][col]));
                            if (this.vGroups[i].value === null) {
                                this.changeGroup(i, date);
                            }
                            else if (this.vGroups[i].value !== date) {
                                this.changeGroup(i, date);
                            }
                            break;
                    }
                }
            }
            evalGroupChangedAux(i) {
                for (; i < this.groupCount; i++) {
                    this.groupChangedAux(i);
                }
            }
            groupChangedAux(i) {
                let col = this.vGroups[i].indexField;
                let row = this.vRowsIndex[this.iRow2];
                switch (this.vGroups[i].comparisonType) {
                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                        this.vGroups[i].value = ReportGlobals.valVariant(this.table.rows[row][col]).toString().toLowerCase();
                        break;
                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                        this.vGroups[i].value = U.val(ReportGlobals.valVariant(this.table.rows[row][col]));
                        break;
                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                        this.vGroups[i].value = ReportGlobals.dateValue(ReportGlobals.valVariant(this.table.rows[row][col]));
                        break;
                }
            }
            groupChanged(i, bGetNewPage) {
                this.idxGroupHeader = i + 1;
                this.groupChangedAux(i);
                bGetNewPage = this.groups.item(i).getPrintInNewPage() && !this.firstGroup;
                if (bGetNewPage) {
                    this.idxGroupToPrintNP = i + 1;
                }
                else {
                    this.idxGroupToPrintNP = this.NO_GROUP_INDEX;
                }
                if (i < this.groupCount - 1) {
                    this.vGroups[i + 1].changed = true;
                }
                this.bOpenHeader = true;
            }
            getLineAuxGroupFooter(fields) {
                if (this.bEvalPreGroups) {
                    this.iRowFormula = this.iRow - 1;
                    this.iRow2 = this.iRow - 1;
                    this.bEvalPreGroups = false;
                    return csRptGetLineResult.CS_RPT_GL_VIRTUAL_F;
                }
                else {
                    this.bCloseFooter = false;
                    this.bEvalPreGroups = true;
                    let footerSec = this.groups.item(this.idxGroupFooter - 1).getFooter();
                    this.getLineAux(footerSec, fields);
                    return csRptGetLineResult.CS_RPT_GL_GROUP_FOOTER;
                }
            }
            getLineAuxGroupHeader(bGetNewPage, fields) {
                let headerSec = null;
                if (bGetNewPage && !this.firstGroup) {
                    this.iRowFormula = this.iRow;
                    return csRptGetLineResult.CS_RPT_GL_NEW_PAGE;
                }
                else {
                    if (this.bEvalPreGroups) {
                        if (!this.bHaveToRePrintGroup) {
                            this.iRowFormula = this.iRow;
                        }
                        this.bEvalPreGroups = false;
                        return csRptGetLineResult.CS_RPT_GL_VIRTUAL_H;
                    }
                    else {
                        this.bOpenHeader = false;
                        this.bEvalPreGroups = true;
                        headerSec = this.groups.item(this.idxGroupHeader - 1).getHeader();
                        this.getLineAux(headerSec, fields);
                        this.bPrintFooter = true;
                        return csRptGetLineResult.CS_RPT_GL_GROUP_HEADER;
                    }
                }
            }
            getLineAuxDetail(fields) {
                this.firstGroup = false;
                this.getLineAux(this.details.item(0), fields);
                return csRptGetLineResult.CS_RPT_GL_DETAIL;
            }
            getLineAux(sec, wfields) {
                let field = null;
                let secLn = null;
                let ctrl = null;
                let isVisible;
                let indexCtrl = 0;
                let fields = wfields.get();
                let indexRows = 0;
                let indexRow = 0;
                let indexField = 0;
                if (sec.getHasFormulaHide()) {
                    isVisible = U.valEx(this.compiler.resultFunction(sec.getFormulaHide())) !== 0;
                }
                else {
                    isVisible = true;
                }
                if (isVisible) {
                    for (let _i = 0; _i < sec.getSectionLines().count(); _i++) {
                        secLn = sec.getSectionLines().item(_i);
                        this.lineIndex++;
                        if (secLn.getHasFormulaHide()) {
                            this.compiler.evalFunction(secLn.getFormulaHide());
                            isVisible = U.valEx(this.compiler.resultFunction(secLn.getFormulaHide())) !== 0;
                        }
                        else {
                            isVisible = true;
                        }
                        if (isVisible) {
                            let collByLeft = secLn.getControls().getCollByLeft();
                            for (indexCtrl = 0; indexCtrl < collByLeft.length; indexCtrl++) {
                                ctrl = secLn.getControls().item(collByLeft[indexCtrl]);
                                field = fields.add(null, "");
                                field.setIndexLine(this.lineIndex);
                                if (ctrl.getHasFormulaValue()) {
                                    field.setValue(ReportGlobals.format(this.compiler.resultFunction(ctrl.getFormulaValue()), ctrl.getLabel().getAspect().getFormat()));
                                }
                                else {
                                    let label = null;
                                    switch (ctrl.getControlType()) {
                                        case csRptControlType.RPT_CT_FIELD:
                                            ({ indexRows, indexRow, indexField } = this.getIndexRows(indexRows, indexRow, indexField, ctrl));
                                            if (this.tables[indexRows] !== null) {
                                                let value = this.tables[indexRows].rows[indexRow][indexField];
                                                field.setValue(ReportGlobals.format(ReportGlobals.valVariant(value), ctrl.getLabel().getAspect().getFormat()));
                                            }
                                            break;
                                        case csRptControlType.RPT_CT_LABEL:
                                            label = ctrl.getLabel();
                                            field.setValue(ReportGlobals.format(label.getText(), label.getAspect().getFormat()));
                                            break;
                                        case csRptControlType.RPT_CT_IMAGE:
                                            label = ctrl.getLabel();
                                            field.setValue(ReportGlobals.format(label.getText(), label.getAspect().getFormat()));
                                            field.setImage(ctrl.getImage().getImage());
                                            break;
                                        case csRptControlType.RPT_CT_DB_IMAGE:
                                            ({ indexRows, indexRow, indexField } = this.getIndexRows(indexRows, indexRow, indexField, ctrl));
                                            if (this.tables[indexRows] !== null) {
                                                field.setImage(this.getImage(indexRows, indexField, indexRow));
                                            }
                                            break;
                                        case csRptControlType.RPT_CT_CHART:
                                            ({ indexRows, indexRow, indexField } = this.getIndexRows(indexRows, indexRow, indexField, ctrl));
                                            field.setImage(this.getChartImage(indexRows, indexField, indexRow, ctrl));
                                            break;
                                    }
                                }
                                if (ctrl.getHasFormulaHide()) {
                                    field.setVisible(U.valEx(this.compiler.resultFunction(ctrl.getFormulaHide())) !== 0);
                                }
                                else {
                                    field.setVisible(true);
                                }
                                field.setInfo(this.pageSetting.item(ctrl.getKey()));
                            }
                        }
                    }
                }
            }
            getIndexRows(indexRows, indexRow, indexField, ctrl) {
                indexRows = Math.floor(ctrl.getField().getIndex() / 1000);
                indexField = ctrl.getField().getIndex() - (indexRows * 1000);
                if (indexRows === 0) {
                    indexRow = this.vRowsIndex[this.iRow2];
                }
                else {
                    indexRow = this.vRowsIndexAux[indexRows];
                }
                return { indexRows, indexRow, indexField };
            }
            init(oLaunchInfo) {
                try {
                    this.setLaunchInfo(oLaunchInfo);
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            launch(oLaunchInfo = null) {
                let recordSets = [];
                let dtr = new RefWrapper(null);
                this.tables = [];
                return P._().then(P.call(this, () => {
                    try {
                        this.compiler.setReport(this);
                        this.compiler.initGlobalObject();
                        if (oLaunchInfo === null) {
                            if (this.launchInfo === null) {
                                throw new CSReportEngine.ReportLaunchInfoNoDefined(csRptErrors.LAUNCH_INFO_UNDEFINED, CSReportEngine.cReportError.errGetDescription(csRptErrors.LAUNCH_INFO_UNDEFINED));
                            }
                        }
                        else {
                            this.setLaunchInfo(oLaunchInfo);
                        }
                        if (this.launchInfo.getPrinter() === null) {
                            throw new CSReportEngine.ReportLaunchInfoNoDefined(csRptErrors.PRINTER_NOT_DEFINED, CSReportEngine.cReportError.errGetDescription(csRptErrors.PRINTER_NOT_DEFINED));
                        }
                        if (!this.progress("Building report ...")) {
                            return false;
                        }
                        this.sortCollection();
                        if (!this.progress("Compiling report ...")) {
                            return false;
                        }
                        if (!this.compileReport()) {
                            return false;
                        }
                        this.sortControlsByLeft();
                        if (!this.progress("Querying database")) {
                            return false;
                        }
                    }
                    catch (ex) {
                        this.processLaunchError(ex);
                    }
                }))
                    .then(P.call(this, () => this.getData(dtr, this.connect, true, recordSets)))
                    .then(P.call(this, (result) => {
                    if (!result) {
                        return false;
                    }
                    try {
                        this.table = dtr.get();
                        this.tables[0] = this.table;
                        if (this.table !== null) {
                            this.recordCount = this.vRowsIndex.length;
                        }
                        else {
                            this.recordCount = 0;
                        }
                        this.initImages();
                        return true;
                    }
                    catch (ex) {
                        this.processLaunchError(ex);
                    }
                }))
                    .then(P.call(this, () => this.getDataAux(recordSets)))
                    .then(P.call(this, (result) => {
                    if (!result) {
                        return false;
                    }
                    try {
                        if (!this.initGroups(dtr.get(), this.getMainDataSource(recordSets))) {
                            return false;
                        }
                        if (!this.progress("Initializing report")) {
                            return false;
                        }
                        if (!this.initControls(recordSets)) {
                            return false;
                        }
                        if (!this.createPageSetting()) {
                            return false;
                        }
                        this.pages.clear();
                        this.lineIndex = 0;
                        this.bPrintFooter = false;
                        this.bLastFootersWasPrinted = false;
                        this.groupIndexChange = this.NO_GROUP_INDEX;
                        this.iRow2 = 0;
                        this.iRowFormula = 0;
                        this.setGroupFormulaHeaders();
                        this.setGroupsInCtrlFormulaHide();
                        this.setIndexColInGroupFormulas(recordSets);
                        this.initRowFormulas();
                        this.existsGroupToReprintInNP();
                        this.bEvalPreGroups = true;
                        this.bCloseFooter = false;
                        this.bOpenHeader = false;
                        let formula = null;
                        for (let _i = 0; _i < this.formulas.count(); _i++) {
                            formula = this.formulas.item(_i);
                            formula.setHaveToEval(true);
                        }
                        this.launchInfo.getReportPrint().setReport(this);
                        if (!this.launchInfo.getReportPrint().makeReport()) {
                            return false;
                        }
                        if (!this.runningInWebWorker) {
                            switch (this.launchInfo.getAction()) {
                                case csRptLaunchAction.CS_RPT_LAUNCH_PRINTER:
                                    if (!this.launchInfo.getReportPrint().printReport()) {
                                        return false;
                                    }
                                    break;
                                case csRptLaunchAction.CS_RPT_LAUNCH_FILE:
                                    if (!this.launchInfo.getReportPrint().makeXml()) {
                                        return false;
                                    }
                                    break;
                                case csRptLaunchAction.CS_RPT_LAUNCH_PREVIEW:
                                    if (!this.launchInfo.getReportPrint().previewReport()) {
                                        return false;
                                    }
                                    break;
                            }
                        }
                        return true;
                    }
                    catch (ex) {
                        this.processLaunchError(ex);
                    }
                }));
            }
            processLaunchError(ex) {
                console.log(ex);
                this.compiler.setReport(null);
                if (this.launchInfo.getAction() !== csRptLaunchAction.CS_RPT_LAUNCH_PREVIEW) {
                    this.launchInfo.getReportPrint().setReport(null);
                    this.launchInfo.setReportPrint(null);
                }
                throw new CSReportEngine.ReportException(csRptErrors.ERROR_WHEN_RUNNING_REPORT, "Error when running report.\n\n"
                    + "Info: " + ex.message + "\n"
                    + "Name: " + ex.name + "\n"
                    + "Stack trace: " + ex.stack);
            }
            loadSilent(fileName) {
                return P._(false);
            }
            copy(report) {
                this.cleanCollections();
                if (!this.copyAux(report.headers, this.headers)) {
                    return false;
                }
                if (!this.copyAux(report.details, this.details)) {
                    return false;
                }
                if (!this.copyAux(report.footers, this.footers)) {
                    return false;
                }
                if (!this.copyGroups(report)) {
                    return false;
                }
                this.fixGroupIndex();
                if (!this.copyConnect(report)) {
                    return false;
                }
                if (!this.copyConnectsAux(report)) {
                    return false;
                }
                if (!this.copyLaunchInfo(report)) {
                    return false;
                }
                this.copyPaperInfo(report);
                this.sortCollection();
                this.originalHeight = this.paperInfo.getCustomHeight();
                return true;
            }
            load() {
                try {
                    let docXml = new cXml();
                    docXml.setFilter(this.FILE_EX);
                    if (this.name !== "") {
                        docXml.setName(this.name);
                    }
                    else {
                        docXml.setPath(this.pathDefault + "\\*." + this.FILE_EX);
                    }
                    docXml.setPath(this.path);
                    return docXml.openXmlWithDialog().then(P.call(this, () => {
                        return this.loadFromDocXml(docXml);
                    }));
                }
                catch (ex) {
                    cError.mngError(ex);
                    return P._(false);
                }
            }
            clone() {
                const report = new cReport();
                const docXml = this.toXml();
                report.loadFromDocXml(docXml);
                return report;
            }
            loadFromDocXml(docXml) {
                this.path = docXml.getPath();
                this.name = docXml.getName();
                let property = docXml.getNodeProperty(docXml.getRootNode(), "ReportDisconnected");
                this.reportDisconnected = property.getValueBool(eTypes.eBoolean);
                return this.nLoad(docXml);
            }
            loadFromXml(xml) {
                let docXml = new cXml();
                if (!docXml.openXml(xml)) {
                    return false;
                }
                this.path = docXml.getPath();
                this.name = docXml.getName();
                let property = docXml.getNodeProperty(docXml.getRootNode(), "ReportDisconnected");
                this.reportDisconnected = property.getValueBool(eTypes.eBoolean);
                return this.nLoad(docXml);
            }
            toXml(docXml = new cXml()) {
                let xProperty = new cXmlProperty();
                xProperty.setName("RptName");
                xProperty.setValue(eTypes.eText, this.name);
                docXml.addProperty(xProperty);
                xProperty.setName("ReportDisconnected");
                xProperty.setValue(eTypes.eBoolean, this.reportDisconnected);
                docXml.addProperty(xProperty);
                let sec = null;
                let nodeObj = null;
                this.connect.save(docXml, null);
                this.connectsAux.save(docXml, null);
                this.launchInfo.save(docXml, null);
                xProperty.setName(this.NODE_RPT_HEADERS);
                xProperty.setValue(eTypes.eText, "");
                nodeObj = docXml.addNode(xProperty);
                for (let _i = 0; _i < this.headers.count(); _i++) {
                    sec = this.headers.item(_i);
                    sec.save(docXml, nodeObj);
                }
                xProperty.setName(this.NODE_RPT_DETAILS);
                xProperty.setValue(eTypes.eText, "");
                nodeObj = docXml.addNode(xProperty);
                for (let _i = 0; _i < this.details.count(); _i++) {
                    sec = this.details.item(_i);
                    sec.save(docXml, nodeObj);
                }
                xProperty.setName(this.NODE_RPT_FOOTERS);
                xProperty.setValue(eTypes.eText, "");
                nodeObj = docXml.addNode(xProperty);
                for (let _i = 0; _i < this.footers.count(); _i++) {
                    sec = this.footers.item(_i);
                    sec.save(docXml, nodeObj);
                }
                xProperty.setName(this.NODE_GROUPS);
                xProperty.setValue(eTypes.eText, "");
                nodeObj = docXml.addNode(xProperty);
                let group = null;
                for (let _i = 0; _i < this.groups.count(); _i++) {
                    group = this.groups.item(_i);
                    group.save(docXml, nodeObj);
                }
                xProperty.setName(this.NODE_RPT_FORMULAS);
                xProperty.setValue(eTypes.eText, "");
                nodeObj = docXml.addNode(xProperty);
                let formula = null;
                for (let _i = 0; _i < this.formulas.count(); _i++) {
                    formula = this.formulas.item(_i);
                    if (!formula.getNotSave()) {
                        formula.save(docXml, nodeObj);
                    }
                }
                xProperty.setName(this.NODE_PAPER_INFO);
                xProperty.setValue(eTypes.eText, "");
                nodeObj = docXml.addNode(xProperty);
                this.paperInfo.save(docXml, nodeObj);
                return docXml;
            }
            save(withDialog, inBrowser = false) {
                let docXml = new cXml();
                docXml.setFilter(this.FILE_EX);
                docXml.setName(this.name);
                docXml.setPath(this.path);
                if (withDialog && !inBrowser) {
                    if (!docXml.newXmlWithDialog()) {
                        return false;
                    }
                }
                else {
                    if (!docXml.newXml()) {
                        return false;
                    }
                }
                this.name = docXml.getName();
                this.path = docXml.getPath();
                docXml = this.toXml(docXml);
                if (inBrowser) {
                    docXml.saveInBrowser();
                }
                else {
                    if (!docXml.save()) {
                        return false;
                    }
                    if (!docXml.openXml()) {
                        return false;
                    }
                    if (!this.nLoad(docXml)) {
                        return false;
                    }
                }
                return true;
            }
            loadSilentData(fileName) {
                let docXml = new cXml();
                this.path = cFile.getPath(fileName);
                this.name = cFile.getFileName(fileName);
                docXml.setFilter(this.FILE_DATA_EX);
                docXml.setName(this.name);
                docXml.setPath(this.path);
                if (!docXml.openXml()) {
                    return false;
                }
                this.path = docXml.getPath();
                this.name = docXml.getName();
                let property = docXml.getNodeProperty(docXml.getRootNode(), "ReportDisconnected");
                this.reportDisconnected = property.getValueBool(eTypes.eBoolean);
                return this.nLoadData(docXml);
            }
            loadData(commDialog) {
                let docXml = new cXml();
                docXml.setFilter(this.FILE_DATA_EX);
                docXml.setName(this.name);
                docXml.setPath(this.path);
                if (!docXml.openXmlWithDialog()) {
                    return false;
                }
                this.path = docXml.getPath();
                this.name = docXml.getName();
                let property = docXml.getNodeProperty(docXml.getRootNode(), "ReportDisconnected");
                this.reportDisconnected = property.getValueBool(eTypes.eBoolean);
                return this.nLoadData(docXml);
            }
            saveData(commDialog, withDialog) {
                let docXml = new cXml();
                docXml.setFilter(this.FILE_DATA_EX);
                docXml.setName(this.getFileName(this.name) + "-data.csd");
                docXml.setPath(this.path);
                if (withDialog) {
                    if (!docXml.newXmlWithDialog()) {
                        return false;
                    }
                }
                else {
                    if (!docXml.newXml()) {
                        return false;
                    }
                }
                let mouse = new CMouseWait();
                let dataName = docXml.getName();
                let dataPath = docXml.getPath();
                let xProperty = new cXmlProperty();
                xProperty.setName("RptName");
                xProperty.setValue(eTypes.eText, dataName);
                docXml.addProperty(xProperty);
                xProperty.setName(this.NODE_RPT_PAGES);
                xProperty.setValue(eTypes.eText, "");
                let nodeObj = docXml.addNode(xProperty);
                for (let _i = 0; _i < this.pages.count(); _i++) {
                    let page = this.pages.item(_i);
                    page.save(docXml, nodeObj);
                    if (!this.saveDataForWeb(page, dataName, dataPath)) {
                        return false;
                    }
                }
                if (!docXml.save()) {
                    return false;
                }
                if (!docXml.openXml()) {
                    return false;
                }
                if (!this.nLoadData(docXml)) {
                    return false;
                }
                mouse.dispose();
                return true;
            }
            saveDataForWeb(page, dataName, dataPath) {
                let docXml = new cXml();
                docXml.setFilter("xml");
                docXml.setName(this.getFileName(dataName) + "-1.xml");
                docXml.setPath(dataPath);
                if (!docXml.newXml()) {
                    return false;
                }
                dataName = docXml.getName();
                let xProperty = new cXmlProperty();
                xProperty.setName("Page_" + page.getPageNumber().toString());
                xProperty.setValue(eTypes.eText, dataName);
                docXml.addProperty(xProperty);
                xProperty.setName("Page");
                xProperty.setValue(eTypes.eText, "");
                let nodeObj = docXml.addNode(xProperty);
                page.saveForWeb(docXml, nodeObj);
                return docXml.save();
            }
            getValueFromRs(colIndex) {
                return this.table.rows[this.vRowsIndex[this.iRow2]][colIndex];
            }
            getValueString(controlName) {
                let value = this.getValue(controlName, false);
                if (value === null) {
                    return "";
                }
                else {
                    return value.toString();
                }
            }
            getValue(controlName, notFormat = false) {
                let ctrl = null;
                let found = false;
                let iRow = 0;
                if (this.iRowFormula > this.lastRowIndex) {
                    iRow = this.lastRowIndex;
                }
                else {
                    iRow = this.iRowFormula;
                }
                for (let _i = 0; _i < this.controls.count(); _i++) {
                    ctrl = this.controls.item(_i);
                    if (ctrl.getName().toUpperCase() === controlName.toUpperCase()) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    throw new CSReportEngine.ReportException(csRptErrors.CONTROL_NOT_FOUND, CSReportEngine.cReportError.errGetDescription(csRptErrors.CONTROL_NOT_FOUND, [controlName]));
                }
                switch (ctrl.getControlType()) {
                    case csRptControlType.RPT_CT_FIELD:
                        let indexRows = 0;
                        let indexRow = 0;
                        let indexField = 0;
                        indexRows = Math.floor((ctrl.getField().getIndex() / 1000));
                        indexField = ctrl.getField().getIndex() - (indexRows * 1000);
                        if (indexRows === 0) {
                            indexRow = this.vRowsIndex[iRow];
                        }
                        else {
                            indexRow = this.vRowsIndexAux[indexRows];
                        }
                        if (this.tables[indexRows] !== null) {
                            let value = this.tables[indexRows].rows[indexRow][indexField];
                            if (ctrl.getLabel().getAspect().getFormat() !== "" && notFormat === false) {
                                return ReportGlobals.format(ReportGlobals.valVariant(value), ctrl.getLabel().getAspect().getFormat());
                            }
                            else {
                                return ReportGlobals.valVariant(value);
                            }
                        }
                        else {
                            return null;
                        }
                    case csRptControlType.RPT_CT_LABEL:
                    case csRptControlType.RPT_CT_IMAGE:
                        if (ctrl.getHasFormulaValue()) {
                            if (ctrl.getFormulaValue().getHaveToEval()) {
                                let value = this.compiler.resultFunction(ctrl.getFormulaValue());
                                if (ctrl.getLabel().getAspect().getFormat() !== "" && notFormat === false) {
                                    return ReportGlobals.format(value, ctrl.getLabel().getAspect().getFormat());
                                }
                                else {
                                    return value;
                                }
                            }
                            else {
                                let value = ctrl.getFormulaValue().getLastResult();
                                if (ctrl.getLabel().getAspect().getFormat() !== "" && notFormat === false) {
                                    return ReportGlobals.format(value, ctrl.getLabel().getAspect().getFormat());
                                }
                                else {
                                    return value;
                                }
                            }
                        }
                        else {
                            return ctrl.getLabel().getText();
                        }
                    default:
                        return null;
                }
            }
            initControls(recordSets) {
                let ctrl = null;
                let sequence = null;
                let idx = new RefWrapper(0);
                for (let _i = 0; _i < this.controls.count(); _i++) {
                    ctrl = this.controls.item(_i);
                    if (ctrl.getControlType() === csRptControlType.RPT_CT_FIELD
                        || ctrl.getControlType() === csRptControlType.RPT_CT_DB_IMAGE) {
                        idx.set(ctrl.getField().getIndex());
                        if (!this.initControlAux(ctrl, idx, recordSets, ctrl.getField().getName())) {
                            return false;
                        }
                        ctrl.getField().setIndex(idx.get());
                    }
                    else if (ctrl.getControlType() === csRptControlType.RPT_CT_CHART) {
                        if (ctrl.getChart().getGroupFieldName() !== "") {
                            idx.set(-1);
                            this.initControlAux(ctrl, idx, recordSets, ctrl.getChart().getGroupFieldName());
                            ctrl.getChart().setGroupFieldIndex(idx.get());
                        }
                        else {
                            ctrl.getChart().setGroupFieldIndex(-1);
                        }
                        for (let _j = 0; _j < ctrl.getChart().getSeries().count(); _j++) {
                            sequence = ctrl.getChart().getSeries().item(_j);
                            idx.set(sequence.getValueIndex());
                            if (!this.initControlAux(ctrl, idx, recordSets, sequence.getValueFieldName())) {
                                return false;
                            }
                            sequence.setValueIndex(idx.get());
                            idx.set(sequence.getLabelIndex());
                            if (!this.initControlAux(ctrl, idx, recordSets, sequence.getLabelFieldName())) {
                                return false;
                            }
                            sequence.setLabelIndex(idx.get());
                        }
                        ctrl.getChart().setChartCreated(false);
                    }
                }
                return true;
            }
            compareColumnName(columnName, fieldName) {
                if (columnName === fieldName) {
                    return true;
                }
                else {
                    return columnName === fieldName
                        .replaceAll(" ", "_").replaceAll(".", "");
                }
            }
            initControlAux(ctrl, idx, recordSets, fieldName) {
                let found = false;
                let j = 0;
                let bIsDBImage = false;
                let dataSource = this.getDataSource(fieldName);
                let k = 0;
                for (let _i = 0; _i < recordSets.length; _i++) {
                    let varRs = recordSets[_i];
                    let rsDataSource = varRs[1].toString();
                    if (rsDataSource.toUpperCase() === dataSource.toUpperCase() || dataSource === "") {
                        let rs = varRs[0];
                        for (j = 0; j < rs.columns.length; j++) {
                            if (this.compareColumnName(rs.columns[j].getName().toUpperCase(), ReportGlobals.getRealName(fieldName).toUpperCase())) {
                                let typeCode = rs.columns[j].getDataType();
                                bIsDBImage = typeCode === DataType.dbImage;
                                found = true;
                                break;
                            }
                        }
                    }
                    if (found) {
                        break;
                    }
                    k = k + 1000;
                }
                if (found) {
                    idx.set(j + k);
                    if (bIsDBImage) {
                        ctrl.setControlType(csRptControlType.RPT_CT_DB_IMAGE);
                    }
                }
                else {
                    throw new CSReportEngine.ReportException(csRptErrors.FIELD_NOT_FOUND, CSReportEngine.cReportError.errGetDescription(csRptErrors.FIELD_NOT_FOUND, [ctrl.getName(), fieldName]));
                }
                return true;
            }
            getDataSource(name) {
                let n = name.indexOf("}.", 0);
                if (n === -1) {
                    return "";
                }
                else {
                    return name.substring(1, n);
                }
            }
            initImages() {
                this.destroyImages();
                this.images = new Map();
            }
            destroyImages() {
                if (this.images !== null) {
                    this.images.forEachValue((image) => image.dispose());
                    this.images = null;
                }
            }
            getChartImage(indexRows, indexField, indexRow, ctrl) {
                let key = "k" + indexRows.toString() + indexField.toString() + indexRow.toString();
                if (ctrl.getChart().getChartCreated()) {
                    if (this.images.containsKey(key)) {
                        return this.images.item(key);
                    }
                    else {
                        return null;
                    }
                }
                else {
                    if (ctrl.getChart().make(this.tables[indexRows].rows, ctrl.getLabel().getAspect().getFormat(), false, "")) {
                        const image = new Image(Bitmap.loadImageFromArray(ctrl.getChart().getImage()), key, ctrl.getChart().getWidth(), ctrl.getChart().getHeight());
                        this.images.add(image, key);
                        return image;
                    }
                    else {
                        return null;
                    }
                }
            }
            getImage(indexRows, indexField, indexRow) {
                let key = "k" + indexRows.toString() + indexField.toString() + indexRow.toString();
                if (this.images.containsKey(key)) {
                    return this.images.item(key);
                }
                else {
                    const imgData = this.tables[indexRows].rows[indexRow][indexField];
                    const image = new Image(Bitmap.loadImageFromArray(imgData.image), key, imgData.width, imgData.height);
                    this.images.add(image, key);
                    return image;
                }
            }
            getImages() {
                return this.images;
            }
            setLaunchInfo(oLaunchInfo) {
                this.launchInfo = new CSReportEngine.cReportLaunchInfo();
                this.launchInfo.setAction(oLaunchInfo.getAction());
                this.launchInfo.setStrConnect(oLaunchInfo.getStrConnect());
                this.launchInfo.setCopies(oLaunchInfo.getCopies());
                this.launchInfo.setReportPrint(oLaunchInfo.getReportPrint());
                this.launchInfo.setDataSource(oLaunchInfo.getDataSource());
                this.launchInfo.setFile(oLaunchInfo.getFile());
                this.launchInfo.setFileFormat(oLaunchInfo.getFileFormat());
                this.launchInfo.setInternalPreview(oLaunchInfo.getInternalPreview());
                this.launchInfo.setShowPrintersDialog(oLaunchInfo.getShowPrintersDialog());
                this.launchInfo.setSilent(oLaunchInfo.getSilent());
                this.launchInfo.setSqlstmt(oLaunchInfo.getSqlstmt());
                this.launchInfo.setPrinter(oLaunchInfo.getPrinter());
                if (this.launchInfo.getPrinter() === null) {
                    this.launchInfo.setPrinter(CSReportEngine.cPrintAPI.getcPrinterFromDefaultPrinter(null));
                }
                if (this.launchInfo.getPrinter() !== null) {
                    if (!Object.is(this.paperInfo, this.launchInfo.getPrinter().getPaperInfo())) {
                        this.paperInfo.setHeight(this.launchInfo.getPrinter().getPaperInfo().getHeight());
                        this.paperInfo.setWidth(this.launchInfo.getPrinter().getPaperInfo().getWidth());
                    }
                }
            }
            getGroupTotal(colIndex, indexGroup) {
                let total = 0;
                if (indexGroup === -1) {
                    for (let i = 0; i < this.recordCount; i++) {
                        total = total + ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                    }
                }
                else {
                    if (this.vGroups[indexGroup].grandTotalGroup) {
                        for (let i = 0; i < this.recordCount; i++) {
                            total = total + ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                        }
                    }
                    else {
                        for (let i = this.iRow; i < this.recordCount; i++) {
                            for (let j = 0; j < indexGroup; j++) {
                                switch (this.vGroups[j].comparisonType) {
                                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                        if (this.vGroups[j].value === null) {
                                            return total;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let text = ReportGlobals.valVariant(value);
                                            if (this.vGroups[j].value !== text.toLowerCase()) {
                                                return total;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = this.table.rows[colIndex][this.vRowsIndex[i]];
                                            total = total + ReportGlobals.valVariant(value);
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                        if (this.vGroups[j].value === null) {
                                            return total;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let number = U.val(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== number) {
                                                return total;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = this.table.rows[this.vRowsIndex[i]][colIndex];
                                            total = total + ReportGlobals.valVariant(value);
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                        if (this.vGroups[j].value === null) {
                                            return total;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let date = ReportGlobals.dateValue(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== date) {
                                                return total;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = this.table.rows[this.vRowsIndex[i]][colIndex];
                                            total = total + ReportGlobals.valVariant(value);
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
                return total;
            }
            getGroupMax(colIndex, indexGroup) {
                let max = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[0]][colIndex]);
                if (indexGroup === -1) {
                    for (let i = 0; i < this.recordCount; i++) {
                        let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                        if (max < value) {
                            max = value;
                        }
                    }
                }
                else {
                    if (this.vGroups[indexGroup].grandTotalGroup) {
                        for (let i = 0; i < this.recordCount; i++) {
                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                            if (max < value) {
                                max = value;
                            }
                        }
                    }
                    else {
                        for (let i = this.iRow; i < this.recordCount; i++) {
                            for (let j = 0; j < indexGroup; j++) {
                                switch (this.vGroups[j].comparisonType) {
                                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                        if (this.vGroups[j].value === null) {
                                            return max;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let text = ReportGlobals.valVariant(value);
                                            if (this.vGroups[j].value !== text.toLowerCase()) {
                                                return max;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            if (max < value) {
                                                max = value;
                                            }
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                        if (this.vGroups[j].value === null) {
                                            return max;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let number = U.val(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== number) {
                                                return max;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            if (max < value) {
                                                max = value;
                                            }
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                        if (this.vGroups[j].value === null) {
                                            return max;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let date = ReportGlobals.dateValue(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== date) {
                                                return max;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            if (max < value) {
                                                max = value;
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
                return max;
            }
            getGroupMin(colIndex, indexGroup) {
                let min = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[0]][colIndex]);
                if (indexGroup === -1) {
                    for (let i = 0; i < this.recordCount; i++) {
                        let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                        if (min > value) {
                            min = value;
                        }
                    }
                }
                else {
                    if (this.vGroups[indexGroup].grandTotalGroup) {
                        for (let i = 0; i < this.recordCount; i++) {
                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                            if (min > value) {
                                min = value;
                            }
                        }
                    }
                    else {
                        for (let i = this.iRow; i < this.recordCount; i++) {
                            for (let j = 0; j < indexGroup; j++) {
                                switch (this.vGroups[j].comparisonType) {
                                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                        if (this.vGroups[j].value === null) {
                                            return min;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let text = ReportGlobals.valVariant(value);
                                            if (this.vGroups[j].value !== text.toLowerCase()) {
                                                return min;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            if (min > value) {
                                                min = value;
                                            }
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                        if (this.vGroups[j].value === null) {
                                            return min;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let number = U.val(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== number) {
                                                return min;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            if (min > value) {
                                                min = value;
                                            }
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                        if (this.vGroups[j].value === null) {
                                            return min;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let date = ReportGlobals.dateValue(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== date) {
                                                return min;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            if (min > value) {
                                                min = value;
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
                return min;
            }
            getGroupAverage(colIndex, indexGroup) {
                let total = 0;
                let count = 0;
                if (indexGroup === -1) {
                    for (let i = 0; i < this.recordCount; i++) {
                        total = total + ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                        count = count + 1;
                    }
                }
                else {
                    if (this.vGroups[indexGroup].grandTotalGroup) {
                        for (let i = 0; i < this.recordCount; i++) {
                            total = total + ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                            count = count + 1;
                        }
                    }
                    else {
                        for (let i = this.iRow; i < this.recordCount; i++) {
                            for (let j = 0; j < indexGroup; j++) {
                                switch (this.vGroups[j].comparisonType) {
                                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                        if (this.vGroups[j].value === null) {
                                            return total;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let text = ReportGlobals.valVariant(value);
                                            if (this.vGroups[j].value !== text.toLowerCase()) {
                                                return total;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            total = total + ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            count = count + 1;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                        if (this.vGroups[j].value === null) {
                                            return total;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let number = U.val(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== number) {
                                                return total;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            total = total + ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            count = count + 1;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                        if (this.vGroups[j].value === null) {
                                            return total;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let date = ReportGlobals.dateValue(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== date) {
                                                return total;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            total = total + ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[i]][colIndex]);
                                            count = count + 1;
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
                return U.divideByZero(total, count);
            }
            getGroupLineNumber(indexGroup) {
                if (indexGroup === -1) {
                    return this.lineNumber;
                }
                else {
                    return this.vGroups[indexGroup].lineNumber;
                }
            }
            getGroupCount(colIndex, indexGroup) {
                let count = 0;
                if (indexGroup === -1) {
                    count = this.recordCount;
                }
                else {
                    if (this.vGroups[indexGroup].grandTotalGroup) {
                        count = this.recordCount;
                    }
                    else {
                        for (let i = this.iRow; i < this.recordCount; i++) {
                            for (let j = 0; j < indexGroup; j++) {
                                switch (this.vGroups[j].comparisonType) {
                                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                        if (this.vGroups[j].value === null) {
                                            return count;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let text = ReportGlobals.valVariant(value);
                                            if (this.vGroups[j].value !== text.toLowerCase()) {
                                                return count;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            count = count + 1;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                        if (this.vGroups[j].value === null) {
                                            return count;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let number = U.val(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== number) {
                                                return count;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            count = count + 1;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                        if (this.vGroups[j].value === null) {
                                            return count;
                                        }
                                        else {
                                            let value = this.table.rows[this.vRowsIndex[i]][this.vGroups[j].indexField];
                                            let date = ReportGlobals.dateValue(ReportGlobals.valVariant(value));
                                            if (this.vGroups[j].value !== date) {
                                                return count;
                                            }
                                        }
                                        if (j === indexGroup) {
                                            count = count + 1;
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
                return count;
            }
            addGroup(i, j, value) {
                this.vGroups[i + 1].groups[this.vGroups[i + 1].groups.length - 1].last = j - 1;
                this.vGroups[i + 1].groups.push({ first: j, last: null });
                this.vGroups[i + 1].value = value;
            }
            initGroups(rs, mainDataSource) {
                this.groupCount = this.groups.count();
                this.firstGroup = true;
                if (this.groupCount === 0 || this.table === null) {
                    this.vGroups = null;
                    return true;
                }
                else {
                    this.vGroups = [];
                    for (let t = 0; t < this.groupCount; t++) {
                        this.vGroups[t] = new T_Groups();
                    }
                }
                if (!this.progress("Sorting report", 0, 0, 0)) {
                    return false;
                }
                let k = 0;
                let i = 0;
                let j = 0;
                let found = false;
                let fieldName = "";
                let dataSource = "";
                for (i = 0; i < this.groupCount; i++) {
                    this.vGroups[i].value = null;
                    found = false;
                    fieldName = this.groups.item(i).getFieldName();
                    dataSource = this.getDataSource(fieldName).toUpperCase();
                    fieldName = ReportGlobals.getRealName(fieldName).toUpperCase();
                    if (mainDataSource.toUpperCase() !== dataSource && dataSource !== "") {
                        let w_item = this.groups.item(i);
                        throw new CSReportEngine.ReportException(csRptErrors.GROUP_NOT_FOUND_IN_MAIN_RS, CSReportEngine.cReportError.errGetDescription(csRptErrors.GROUP_NOT_FOUND, [w_item.getName(), w_item.getFieldName()]));
                    }
                    this.vGroups[i].grandTotalGroup = this.groups.item(i).getGrandTotalGroup();
                    if (!this.vGroups[i].grandTotalGroup) {
                        for (j = 0; j < rs.columns.length; j++) {
                            if (this.compareColumnName(rs.columns[j].getName().toUpperCase(), fieldName)) {
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            this.vGroups[i].indexField = j;
                        }
                        else {
                            let w_item = this.groups.item(i);
                            throw new CSReportEngine.ReportException(csRptErrors.GROUP_NOT_FOUND_IN_MAIN_RS, CSReportEngine.cReportError.errGetDescription(csRptErrors.GROUP_NOT_FOUND, [w_item.getName(), w_item.getFieldName()]));
                        }
                    }
                    this.vGroups[i].comparisonType = this.groups.item(i).getComparisonType();
                    this.vGroups[i].oderType = this.groups.item(i).getOderType();
                    this.vGroups[i].groups = [];
                    this.vGroups[i].groups[0] = new T_Group();
                }
                let recordCount;
                let q = 0;
                this.vGroups[0].groups = [];
                this.vGroups[0].groups[0] = new T_Group();
                recordCount = this.vRowsIndex.length;
                this.vGroups[0].groups[0].first = 0;
                this.vGroups[0].groups[0].last = recordCount - 1;
                recordCount = this.groupCount * recordCount;
                for (i = 0; i < this.groupCount; i++) {
                    for (j = 0; j < this.vGroups[i].groups.length; j++) {
                        if (!this.vGroups[i].grandTotalGroup) {
                            if (this.vGroups[i].oderType === RptGrpOrderType.CS_RPT_GRP_ASC) {
                                switch (this.vGroups[i].comparisonType) {
                                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                        if (!this.orderTextAsc(this.vGroups[i].groups[j].first, this.vGroups[i].groups[j].last, this.vGroups[i].indexField)) {
                                            return false;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                        if (!this.orderNumberAsc(this.vGroups[i].groups[j].first, this.vGroups[i].groups[j].last, this.vGroups[i].indexField)) {
                                            return false;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                        if (!this.orderDateAsc(this.vGroups[i].groups[j].first, this.vGroups[i].groups[j].last, this.vGroups[i].indexField)) {
                                            return false;
                                        }
                                        break;
                                }
                            }
                            else {
                                switch (this.vGroups[i].comparisonType) {
                                    case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                        if (!this.orderTextDesc(this.vGroups[i].groups[j].first, this.vGroups[i].groups[j].last, this.vGroups[i].indexField)) {
                                            return false;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                        if (!this.orderNumberDesc(this.vGroups[i].groups[j].first, this.vGroups[i].groups[j].last, this.vGroups[i].indexField)) {
                                            return false;
                                        }
                                        break;
                                    case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                        if (!this.orderDateDesc(this.vGroups[i].groups[j].first, this.vGroups[i].groups[j].last, this.vGroups[i].indexField)) {
                                            return false;
                                        }
                                        break;
                                }
                            }
                        }
                    }
                    if (i < this.groupCount - 1) {
                        for (k = 0; k < this.vGroups[i].groups.length; k++) {
                            if (this.vGroups[i].grandTotalGroup) {
                                let t = i + 1;
                                let r = this.vGroups[t].groups.length - 1;
                                this.vGroups[t].groups[r].last = -1;
                                this.vGroups[t].groups.push({
                                    first: 0,
                                    last: this.vGroups[0].groups[0].last
                                });
                                this.vGroups[t].value = null;
                            }
                            else {
                                for (j = this.vGroups[i].groups[k].first; j <= this.vGroups[i].groups[k].last; j++) {
                                    q = q + 1;
                                    if (!this.progress("", 0, q, recordCount)) {
                                        return false;
                                    }
                                    let value = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[j]][this.vGroups[i].indexField]);
                                    if (this.vGroups[i + 1].value === null) {
                                        this.addGroup(i, j, value);
                                    }
                                    else {
                                        switch (this.vGroups[i].comparisonType) {
                                            case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                                let text1 = this.vGroups[i + 1].value.toString();
                                                let text2 = value.toString();
                                                if (text1.toLowerCase() !== text2.toLowerCase()) {
                                                    this.addGroup(i, j, value);
                                                }
                                                break;
                                            case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                                let number1 = U.val(this.vGroups[i + 1].value);
                                                let number2 = U.val(value);
                                                if (number1 !== number2) {
                                                    this.addGroup(i, j, value);
                                                }
                                                break;
                                            case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                                let date1 = this.vGroups[i + 1].value;
                                                let date2 = value;
                                                if (date1 !== date2) {
                                                    this.addGroup(i, j, value);
                                                }
                                                break;
                                        }
                                    }
                                }
                                this.vGroups[i + 1].groups[this.vGroups[i + 1].groups.length - 1].last = j - 1;
                                this.vGroups[i + 1].value = null;
                            }
                        }
                    }
                }
                return true;
            }
            estimateLoops(n) {
                for (let q = n - 1; q > 0; q--) {
                    n = n + q;
                }
                return n;
            }
            orderNumberAsc(first, last, orderBy) {
                let i = 0;
                let j = 0;
                let t = 0;
                let q = 0;
                let bChanged = false;
                t = this.estimateLoops(last - first);
                for (i = first + 1; i <= last; i++) {
                    bChanged = false;
                    for (j = last; j >= i; j--) {
                        q = q + 1;
                        let value1 = U.val(this.table.rows[this.vRowsIndex[j]][orderBy]);
                        let value2 = U.val(this.table.rows[this.vRowsIndex[j - 1]][orderBy]);
                        if (value1 < value2) {
                            if (!this.progress("", 0, q, t)) {
                                return false;
                            }
                            this.changeRow(j, j - 1);
                            bChanged = true;
                        }
                    }
                    if (!this.progress("", 0, q, t)) {
                        return false;
                    }
                    if (!bChanged) {
                        break;
                    }
                }
                return true;
            }
            orderNumberDesc(first, last, orderBy) {
                let j = 0;
                let q = 0;
                let bChanged = false;
                let t = this.estimateLoops(last - first);
                for (let i = first + 1; i <= last; i++) {
                    bChanged = false;
                    for (j = last; j >= i; j--) {
                        q = q + 1;
                        let number1 = U.val(this.table.rows[this.vRowsIndex[j]][orderBy]);
                        let number2 = U.val(this.table.rows[this.vRowsIndex[j - 1]][orderBy]);
                        if (number1 > number2) {
                            if (!this.progress("", 0, q, t)) {
                                return false;
                            }
                            this.changeRow(j, j - 1);
                            bChanged = true;
                        }
                    }
                    if (!this.progress("", 0, q, t)) {
                        return false;
                    }
                    if (!bChanged) {
                        break;
                    }
                }
                return true;
            }
            orderTextAsc(first, last, orderBy) {
                let j = 0;
                let q = 0;
                let bChanged = false;
                let t = this.estimateLoops(last - first);
                for (let i = first + 1; i <= last; i++) {
                    bChanged = false;
                    for (j = last; j >= i; j--) {
                        q = q + 1;
                        let text1 = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[j]][orderBy]).toString();
                        let text2 = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[j - 1]][orderBy]).toString();
                        if (text1.toLowerCase().localeCompare(text2.toLowerCase()) < 0) {
                            if (!this.progress("", 0, q, t)) {
                                return false;
                            }
                            this.changeRow(j, j - 1);
                            bChanged = true;
                        }
                    }
                    if (!this.progress("", 0, q, t)) {
                        return false;
                    }
                    if (!bChanged) {
                        break;
                    }
                }
                return true;
            }
            orderTextDesc(first, last, orderBy) {
                let j = 0;
                let q = 0;
                let bChanged = false;
                let t = this.estimateLoops(last - first);
                for (let i = first + 1; i <= last; i++) {
                    bChanged = false;
                    for (j = last; j >= i; j--) {
                        q = q + 1;
                        let text1 = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[j]][orderBy]).toString();
                        let text2 = ReportGlobals.valVariant(this.table.rows[this.vRowsIndex[j - 1]][orderBy]).toString();
                        if (text1.toLowerCase().localeCompare(text2.toLowerCase()) > 0) {
                            if (!this.progress("", 0, q, t)) {
                                return false;
                            }
                            this.changeRow(j, j - 1);
                            bChanged = true;
                        }
                    }
                    if (!this.progress("", 0, q, t)) {
                        return false;
                    }
                    if (!bChanged) {
                        break;
                    }
                }
                return true;
            }
            changeRow(i, j) {
                let q = this.vRowsIndex[j];
                this.vRowsIndex[j] = this.vRowsIndex[i];
                this.vRowsIndex[i] = q;
            }
            evalFunctions(idxGroup, whenEval) {
                let formula = null;
                let bHaveToEvalRow = false;
                let idxRowEvaluated = 0;
                let recordCount = 0;
                if (this.table !== null) {
                    recordCount = this.vRowsIndex.length;
                }
                if (this.iRowFormula < recordCount) {
                    switch (idxGroup) {
                        case this.IDX_GROUP_HEADER:
                        case this.IDX_GROUP_REPORT_HEADER:
                            idxRowEvaluated = this.IDX_H_LAST_ROW_EVALUATED;
                            break;
                        case this.IDX_GROUP_DETAIL:
                            idxRowEvaluated = this.IDX_D_LAST_ROW_EVALUATED;
                            break;
                        case this.IDX_GROUP_FOOTER:
                        case this.IDX_GROUP_REPORT_FOOTER:
                            idxRowEvaluated = this.IDX_F_LAST_ROW_EVALUATED;
                            break;
                        default:
                            idxRowEvaluated = this.IDX_G_LAST_ROW_EVALUATED;
                            break;
                    }
                    if (whenEval === csRptWhenEval.CS_RPT_EVAL_PRE) {
                        if (idxRowEvaluated === this.IDX_G_LAST_ROW_EVALUATED) {
                            if (idxGroup < 0) {
                                bHaveToEvalRow = this.vGroups[(idxGroup * -1) - 1].lastFPreRowEvaluated < this.iRowFormula;
                            }
                            else {
                                bHaveToEvalRow = this.vGroups[idxGroup - 1].lastHPreRowEvaluated < this.iRowFormula;
                            }
                        }
                        else {
                            bHaveToEvalRow = this.lastRowPreEvaluated[idxRowEvaluated] < this.iRowFormula;
                        }
                    }
                    else {
                        if (idxRowEvaluated === this.IDX_G_LAST_ROW_EVALUATED) {
                            if (idxGroup < 0) {
                                bHaveToEvalRow = this.vGroups[(idxGroup * -1) - 1].lastFPostRowEvaluated < this.iRowFormula;
                            }
                            else {
                                bHaveToEvalRow = this.vGroups[idxGroup - 1].lastHPostRowEvaluated < this.iRowFormula;
                            }
                        }
                        else {
                            bHaveToEvalRow = this.lastRowPostEvaluated[idxRowEvaluated] < this.iRowFormula;
                        }
                    }
                    if (bHaveToEvalRow) {
                        for (let _i = 0; _i < this.formulas.count(); _i++) {
                            formula = this.formulas.item(_i);
                            if (formula.getWhenEval() === whenEval
                                && (idxGroup === formula.getIdxGroup()
                                    || formula.getIdxGroup2() === idxGroup)) {
                                formula.setHaveToEval(true);
                            }
                        }
                        for (let _i = 0; _i < this.formulas.count(); _i++) {
                            formula = this.formulas.item(_i);
                            if (formula.getWhenEval() === whenEval
                                && (idxGroup === formula.getIdxGroup()
                                    || formula.getIdxGroup2() === idxGroup)) {
                                if (formula.getIdxGroup2() === idxGroup) {
                                    this.compiler.evalFunctionGroup(formula);
                                }
                                else {
                                    this.compiler.evalFunction(formula);
                                }
                            }
                        }
                        if (whenEval === csRptWhenEval.CS_RPT_EVAL_PRE) {
                            if (idxRowEvaluated === this.IDX_G_LAST_ROW_EVALUATED) {
                                if (idxGroup < 0) {
                                    this.vGroups[(idxGroup * -1) - 1].lastFPreRowEvaluated = this.iRowFormula;
                                }
                                else {
                                    this.vGroups[idxGroup - 1].lastHPreRowEvaluated = this.iRowFormula;
                                }
                            }
                            else {
                                this.lastRowPreEvaluated[idxRowEvaluated] = this.iRowFormula;
                            }
                        }
                        else {
                            if (idxRowEvaluated === this.IDX_G_LAST_ROW_EVALUATED) {
                                if (idxGroup < 0) {
                                    this.vGroups[(idxGroup * -1) - 1].lastFPostRowEvaluated = this.iRowFormula;
                                }
                                else {
                                    this.vGroups[idxGroup - 1].lastHPostRowEvaluated = this.iRowFormula;
                                }
                            }
                            else {
                                this.lastRowPostEvaluated[idxRowEvaluated] = this.iRowFormula;
                            }
                        }
                    }
                }
                return true;
            }
            setGroupFormulaHeaders() {
                this.setGroupFormulaHF(this.headers, this.IDX_GROUP_HEADER);
                if (this.headers.item(0).getHasFormulaHide()) {
                    this.headers.item(0).getFormulaHide().setIdxGroup(this.IDX_GROUP_REPORT_HEADER);
                }
                let secLn = null;
                let ctrl = null;
                for (let _i = 0; _i < this.headers.item(0).getSectionLines().count(); _i++) {
                    secLn = this.headers.item(0).getSectionLines().item(_i);
                    for (let _j = 0; _j < secLn.getControls().count(); _j++) {
                        ctrl = secLn.getControls().item(_j);
                        if (ctrl.getHasFormulaHide()) {
                            ctrl.getFormulaHide().setIdxGroup(this.IDX_GROUP_REPORT_HEADER);
                        }
                        if (ctrl.getHasFormulaValue()) {
                            ctrl.getFormulaValue().setIdxGroup(this.IDX_GROUP_REPORT_HEADER);
                        }
                    }
                }
            }
            setGroupsInCtrlFormulaHide() {
                for (let _i = 0; _i < this.groups.count(); _i++) {
                    let group = this.groups.item(_i);
                    this.setGroupsInCtrlFormulaHideAux(group.getHeader().getSectionLines(), group.getIndex());
                    this.setGroupsInCtrlFormulaHideAux(group.getFooter().getSectionLines(), group.getIndex());
                }
            }
            setGroupsInCtrlFormulaHideAux(scls, idxGrop) {
                let scl = null;
                let ctrl = null;
                for (let _i = 0; _i < scls.count(); _i++) {
                    scl = scls.item(_i);
                    for (let _j = 0; _j < scl.getControls().count(); _j++) {
                        ctrl = scl.getControls().item(_j);
                        if (ctrl.getHasFormulaHide()) {
                            if (ctrl.getFormulaHide().getIdxGroup() === 0) {
                                ctrl.getFormulaHide().setIdxGroup(idxGrop);
                            }
                        }
                    }
                }
            }
            setGroupFormulaHF(sections, idxGroup) {
                let sec = null;
                let secLn = null;
                let ctrl = null;
                for (let _i = 0; _i < sections.count(); _i++) {
                    sec = sections.item(_i);
                    for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                        secLn = sec.getSectionLines().item(_j);
                        for (let _k = 0; _k < secLn.getControls().count(); _k++) {
                            ctrl = secLn.getControls().item(_k);
                            if (ctrl.getHasFormulaHide()) {
                                if (ctrl.getFormulaHide().getIdxGroup() === 0) {
                                    ctrl.getFormulaHide().setIdxGroup(idxGroup);
                                }
                            }
                            if (ctrl.getHasFormulaValue()) {
                                if (ctrl.getFormulaValue().getIdxGroup() === 0) {
                                    ctrl.getFormulaValue().setIdxGroup(idxGroup);
                                }
                            }
                        }
                    }
                }
            }
            compileReport() {
                let ctrl = null;
                for (let _i = 0; _i < this.controls.count(); _i++) {
                    ctrl = this.controls.item(_i);
                    if (ctrl.getHasFormulaHide()) {
                        if (!this.compiler.checkSyntax(ctrl.getFormulaHide())) {
                            return false;
                        }
                        ctrl.getFormulaHide().setSectionName(ctrl.getSectionLine().getSectionName());
                        ctrl.getFormulaHide().setSectionLineIndex(ctrl.getSectionLine().getIndex());
                        ctrl.getFormulaHide().setControlName(ctrl.getName());
                        this.addFormula(ctrl.getFormulaHide(), ctrl.getName() + "_" + "H");
                    }
                    if (ctrl.getHasFormulaValue()) {
                        if (!this.compiler.checkSyntax(ctrl.getFormulaValue())) {
                            return false;
                        }
                        ctrl.getFormulaValue().setSectionName(ctrl.getSectionLine().getSectionName());
                        ctrl.getFormulaValue().setSectionLineIndex(ctrl.getSectionLine().getIndex());
                        ctrl.getFormulaValue().setControlName(ctrl.getName());
                        this.addFormula(ctrl.getFormulaValue(), ctrl.getName() + "_" + "V");
                    }
                }
                if (!this.addFormulasInSection(this.headers)) {
                    return false;
                }
                if (!this.addFormulasInSection(this.groupsHeaders)) {
                    return false;
                }
                if (!this.addFormulasInSection(this.groupsFooters)) {
                    return false;
                }
                if (!this.addFormulasInSection(this.details)) {
                    return false;
                }
                if (!this.addFormulasInSection(this.footers)) {
                    return false;
                }
                let formula = null;
                for (let _i = 0; _i < this.formulas.count(); _i++) {
                    formula = this.formulas.item(_i);
                    formula.setCompiledScript(null);
                    this.compiler.initVariable(formula);
                }
                this.setIndexGroupInFormulaGroups(this.headers);
                this.setIndexGroupInFormulaGroups(this.groupsHeaders);
                this.setIndexGroupInFormulaGroups(this.groupsFooters);
                this.setIndexGroupInFormulaGroups(this.details);
                this.setIndexGroupInFormulaGroups(this.footers);
                this.compiler.clearVariables();
                return true;
            }
            setIndexGroupInFormulaGroups(sections) {
                let sec = null;
                let secLn = null;
                let ctrl = null;
                for (let _i = 0; _i < sections.count(); _i++) {
                    sec = sections.item(_i);
                    if (sec.getHasFormulaHide()) {
                        this.setFormulaIndexGroup(sec.getFormulaHide(), sec);
                    }
                    for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                        secLn = sec.getSectionLines().item(_j);
                        if (secLn.getHasFormulaHide()) {
                            this.setFormulaIndexGroup(secLn.getFormulaHide(), sec);
                        }
                        for (let _k = 0; _k < secLn.getControls().count(); _k++) {
                            ctrl = secLn.getControls().item(_k);
                            if (ctrl.getHasFormulaHide()) {
                                this.setFormulaIndexGroup(ctrl.getFormulaHide(), sec);
                            }
                            if (ctrl.getHasFormulaValue()) {
                                this.setFormulaIndexGroup(ctrl.getFormulaValue(), sec);
                            }
                        }
                    }
                }
            }
            setFormulaIndexGroup(formula, sec) {
                let fint = null;
                let indexGroup = 0;
                for (let _i = 0; _i < formula.getFormulasInt().count(); _i++) {
                    fint = formula.getFormulasInt().item(_i);
                    if (this.isGroupFormula(fint.getFormulaType())) {
                        if (fint.getFormulaType() === csRptFormulaType.CSRPTF_GROUP_PERCENT) {
                            formula.setIdxGroup2(0);
                            indexGroup = U.valInt(fint.getParameters().item(2).getValue());
                        }
                        else {
                            indexGroup = U.valInt(fint.getParameters().item(1).getValue());
                        }
                        if (fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP) === null) {
                            fint.getParameters().add2("", ReportGlobals.KEY_INDEX_GROUP);
                        }
                        if (indexGroup === -1) {
                            if (sec.getTypeSection() === csRptSectionType.GROUP_HEADER
                                || sec.getTypeSection() === csRptSectionType.GROUP_FOOTER) {
                                fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).setValue(sec.getIndex().toString());
                                formula.setIdxGroup(sec.getIndex());
                            }
                            else if (sec.getTypeSection() === csRptSectionType.MAIN_DETAIL) {
                                fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).setValue(this.groups.count().toString());
                                formula.setIdxGroup(this.groups.count() - 1);
                            }
                            else {
                                fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).setValue("0");
                                formula.setIdxGroup(0);
                            }
                        }
                        else {
                            fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).setValue(indexGroup.toString());
                            formula.setIdxGroup(indexGroup);
                        }
                    }
                }
            }
            isGroupFormula(formulaType) {
                switch (formulaType) {
                    case csRptFormulaType.CSRPTF_GROUP_TOTAL:
                    case csRptFormulaType.CSRPTF_GROUP_MAX:
                    case csRptFormulaType.CSRPTF_GROUP_MIN:
                    case csRptFormulaType.CSRPTF_GROUP_AVERAGE:
                    case csRptFormulaType.CSRPTF_GROUP_PERCENT:
                    case csRptFormulaType.CSRPTF_GROUP_COUNT:
                    case csRptFormulaType.CSRPTF_GROUP_LINE_NUMBER:
                        return true;
                    default:
                        return false;
                }
            }
            addFormulasInSection(sections) {
                let sec = null;
                let secLn = null;
                for (let _i = 0; _i < sections.count(); _i++) {
                    sec = sections.item(_i);
                    if (sec.getHasFormulaHide()) {
                        if (!this.compiler.checkSyntax(sec.getFormulaHide())) {
                            return false;
                        }
                        sec.getFormulaHide().setSectionName(sec.getName());
                        this.addFormula(sec.getFormulaHide(), sec.getName() + "_" + "H");
                    }
                    for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                        secLn = sec.getSectionLines().item(_j);
                        if (secLn.getHasFormulaHide()) {
                            if (!this.compiler.checkSyntax(secLn.getFormulaHide())) {
                                return false;
                            }
                            secLn.getFormulaHide().setSectionName(secLn.getSectionName());
                            secLn.getFormulaHide().setSectionLineIndex(secLn.getIndex());
                            this.addFormula(secLn.getFormulaHide(), sec.getName()
                                + "_R_" + secLn.getIndex().toString() + "_" + "H");
                        }
                    }
                }
                return true;
            }
            addFormula(formula, name) {
                if (this.formulas.item(name) === null) {
                    this.formulas.add2(formula, name);
                }
            }
            getHeightHeader() {
                let sec = null;
                let height = 0;
                let isVisible = false;
                for (let _i = 0; _i < this.headers.count(); _i++) {
                    sec = this.headers.item(_i);
                    if (sec.getHasFormulaHide()) {
                        isVisible = U.valEx(this.compiler.resultFunction(sec.getFormulaHide())) !== 0;
                    }
                    else {
                        isVisible = true;
                    }
                    if (isVisible) {
                        height = height + sec.getAspect().getHeight();
                    }
                }
                return height;
            }
            getTopFooter() {
                let offset = 0;
                let w_paperInfo = this.launchInfo.getPrinter().getPaperInfo();
                if (w_paperInfo.getPaperSize() === csReportPaperType.CS_RPT_PAPER_USER) {
                    offset = this.paperInfo.getCustomHeight() - w_paperInfo.getCustomHeight();
                }
                let w_aspect = this.footers.item(0).getAspect();
                return w_aspect.getTop() - offset;
            }
            addFieldToNewPage(sections, page, where) {
                let field = null;
                let sec = null;
                let secLine = null;
                let ctrl = null;
                let isVisible = false;
                let indexCtrl = 0;
                let offset = 0;
                let recordCount = 0;
                if (this.table !== null) {
                    recordCount = this.vRowsIndex.length;
                }
                let indexRows = 0;
                let indexRow = 0;
                let indexField = 0;
                for (let _i = 0; _i < sections.count(); _i++) {
                    sec = sections.item(_i);
                    this.lineIndex = this.lineIndex + 1;
                    if (sec.getHasFormulaHide()) {
                        isVisible = U.valEx(this.compiler.resultFunction(sec.getFormulaHide())) !== 0;
                    }
                    else {
                        isVisible = true;
                    }
                    if (isVisible) {
                        for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                            secLine = sec.getSectionLines().item(_j);
                            if (secLine.getHasFormulaHide()) {
                                isVisible = U.valEx(this.compiler.resultFunction(secLine.getFormulaHide())) !== 0;
                            }
                            else {
                                isVisible = true;
                            }
                            if (isVisible) {
                                for (indexCtrl = 0; indexCtrl < secLine.getControls().getCollByLeft().length; indexCtrl++) {
                                    ctrl = secLine.getControls().item(secLine.getControls().getCollByLeft()[indexCtrl]);
                                    if (where === this.HEADERS) {
                                        field = page.getHeader().add(null, "");
                                    }
                                    else if (where === this.FOOTERS) {
                                        field = page.getFooter().add(null, "");
                                    }
                                    field.setIndexLine(this.lineIndex);
                                    if (ctrl.getHasFormulaValue()) {
                                        field.setValue(ReportGlobals.format(this.compiler.resultFunction(ctrl.getFormulaValue()), ctrl.getLabel().getAspect().getFormat()));
                                    }
                                    else {
                                        switch (ctrl.getControlType()) {
                                            case csRptControlType.RPT_CT_FIELD:
                                                ({ indexRows, indexRow, indexField } = this.getIndexRows(indexRows, indexRow, indexField, ctrl));
                                                if (this.tables[indexRows] !== null) {
                                                    let value = this.tables[indexRows].rows[indexRow][indexField];
                                                    field.setValue(ReportGlobals.format(ReportGlobals.valVariant(value), ctrl.getLabel().getAspect().getFormat()));
                                                }
                                                break;
                                            case csRptControlType.RPT_CT_LABEL:
                                                field.setValue(ReportGlobals.format(ctrl.getLabel().getText(), ctrl.getLabel().getAspect().getFormat()));
                                                break;
                                            case csRptControlType.RPT_CT_IMAGE:
                                                field.setValue(ReportGlobals.format(ctrl.getLabel().getText(), ctrl.getLabel().getAspect().getFormat()));
                                                field.setImage(ctrl.getImage().getImage());
                                                break;
                                            case csRptControlType.RPT_CT_DB_IMAGE:
                                                ({ indexRows, indexRow, indexField } = this.getIndexRows(indexRows, indexRow, indexField, ctrl));
                                                if (this.tables[indexRows] !== null) {
                                                    field.setImage(this.getImage(indexRows, indexField, indexRow));
                                                }
                                                break;
                                            case csRptControlType.RPT_CT_CHART:
                                                ({ indexRows, indexRow, indexField } = this.getIndexRows(indexRows, indexRow, indexField, ctrl));
                                                field.setImage(this.getChartImage(indexRows, indexField, indexRow, ctrl));
                                                break;
                                        }
                                    }
                                    field.setInfo(this.pageSetting.item(ctrl.getKey()));
                                    field.setTop(field.getInfo().getAspect().getTop() + offset);
                                    if (ctrl.getHasFormulaHide()) {
                                        field.setVisible(U.valEx(this.compiler.resultFunction(ctrl.getFormulaHide())) !== 0);
                                    }
                                    else {
                                        field.setVisible(true);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if (where === this.HEADERS) {
                            offset = offset - sec.getAspect().getHeight();
                        }
                        else if (where === this.FOOTERS) {
                            offset = offset + sec.getAspect().getHeight();
                        }
                    }
                }
            }
            createPageSetting() {
                this.pageSetting.clear();
                this.pageSetting.setHeight(this.launchInfo.getPrinter().getPaperInfo().getHeight());
                let sec = null;
                let secLine = null;
                let ctrl = null;
                for (let _i = 0; _i < this.headers.count(); _i++) {
                    sec = this.headers.item(_i);
                    for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                        secLine = sec.getSectionLines().item(_j);
                        for (let _k = 0; _k < secLine.getControls().count(); _k++) {
                            ctrl = secLine.getControls().item(_k);
                            let pageInfo = this.pageSetting.add2(secLine, null, ctrl.getKey());
                            pageInfo.setAspect(ctrl.getLabel().getAspect());
                            pageInfo.setName(ctrl.getName());
                            pageInfo.setFieldType(ctrl.getField().getFieldType());
                            pageInfo.setTag(ctrl.getTag());
                        }
                    }
                }
                for (let _i = 0; _i < this.details.count(); _i++) {
                    sec = this.details.item(_i);
                    for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                        secLine = sec.getSectionLines().item(_j);
                        for (let _k = 0; _k < secLine.getControls().count(); _k++) {
                            ctrl = secLine.getControls().item(_k);
                            let pageInfo = this.pageSetting.add2(secLine, null, ctrl.getKey());
                            pageInfo.setAspect(ctrl.getLabel().getAspect());
                            pageInfo.setName(ctrl.getName());
                            pageInfo.setFieldType(ctrl.getField().getFieldType());
                            pageInfo.setTag(ctrl.getTag());
                        }
                    }
                }
                let offset = 0;
                let w_paperInfo = this.launchInfo.getPrinter().getPaperInfo();
                if (w_paperInfo.getPaperSize() === csReportPaperType.CS_RPT_PAPER_USER) {
                    offset = this.originalHeight - w_paperInfo.getCustomHeight();
                }
                for (let _i = 0; _i < this.footers.count(); _i++) {
                    sec = this.footers.item(_i);
                    for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                        secLine = sec.getSectionLines().item(_j);
                        for (let _k = 0; _k < secLine.getControls().count(); _k++) {
                            ctrl = secLine.getControls().item(_k);
                            let pageInfo = this.pageSetting.add2(secLine, null, ctrl.getKey());
                            pageInfo.setAspect(ctrl.getLabel().getAspect());
                            let aspect = pageInfo.getAspect();
                            aspect.setTop(aspect.getTop() - offset);
                            pageInfo.setName(ctrl.getName());
                            pageInfo.setFieldType(ctrl.getField().getFieldType());
                            pageInfo.setTag(ctrl.getTag());
                        }
                    }
                }
                for (let _i = 0; _i < this.groups.count(); _i++) {
                    let grp = this.groups.item(_i);
                    for (let _j = 0; _j < grp.getHeader().getSectionLines().count(); _j++) {
                        secLine = grp.getHeader().getSectionLines().item(_j);
                        for (let _k = 0; _k < secLine.getControls().count(); _k++) {
                            ctrl = secLine.getControls().item(_k);
                            let pageInfo = this.pageSetting.add2(secLine, null, ctrl.getKey());
                            pageInfo.setAspect(ctrl.getLabel().getAspect());
                            pageInfo.setName(ctrl.getName());
                            pageInfo.setFieldType(ctrl.getField().getFieldType());
                            pageInfo.setTag(ctrl.getTag());
                        }
                    }
                    for (let _j = 0; _j < grp.getFooter().getSectionLines().count(); _j++) {
                        secLine = grp.getFooter().getSectionLines().item(_j);
                        for (let _k = 0; _k < secLine.getControls().count(); _k++) {
                            ctrl = secLine.getControls().item(_k);
                            let pageInfo = this.pageSetting.add2(secLine, null, ctrl.getKey());
                            pageInfo.setAspect(ctrl.getLabel().getAspect());
                            pageInfo.setName(ctrl.getName());
                            pageInfo.setFieldType(ctrl.getField().getFieldType());
                            pageInfo.setTag(ctrl.getTag());
                        }
                    }
                }
                return true;
            }
            getDataAux(recordSets) {
                let p = P._(true);
                for (let _i = 0; _i < this.connectsAux.count(); _i++) {
                    p = p.then(P.call(this, (result) => {
                        if (result === false)
                            return false;
                        let connect = this.connectsAux.item(_i);
                        let dtr = new RefWrapper(new DataTable());
                        return this.getData(dtr, connect, false, recordSets)
                            .then(P.call(this, (result) => {
                            if (!result)
                                return false;
                            this.tables.push(dtr.get());
                            return true;
                        }));
                    }));
                }
                return p.then(P.call(this, (result) => {
                    if (!result)
                        return false;
                    this.vRowsIndexAux = U.newArrayOfInts(this.tables.length);
                    return true;
                }));
            }
            getData(dtr, connect, createIndexVector, recordSets) {
                return P._().then(P.call(this, () => {
                    let p = P._();
                    let strConnect;
                    let saveInReport = false;
                    let cn = null;
                    let varRs = null;
                    let rsAux = null;
                    let drr = new RefWrapper(null);
                    if (this.launchInfo.getStrConnect().trim() !== "") {
                        strConnect = this.launchInfo.getStrConnect();
                    }
                    else {
                        strConnect = connect.getStrConnect();
                        saveInReport = true;
                    }
                    if (!this.getReportDisconnected()) {
                        if (strConnect.trim() === "") {
                            cWindow.msgWarning("The connection settings were not defined."
                                + "Both the LaunchInfo and the Connect object have their "
                                + "strConnect property empty. Without this connection string "
                                + "it will be impossible to open the connection to the database.", "CSReportEditor");
                            return false;
                        }
                        cn = new CSReports.CSDatabase.Database(this.databaseEngine);
                        if (this.isForWeb) {
                            cn.setSilent(true);
                        }
                        if (connect.getCommandTimeout() > 0) {
                            cn.setCommandTimeout(connect.getCommandTimeout());
                        }
                        if (connect.getConnectionTimeout() > 0) {
                            cn.setConnectionTimeout(connect.getConnectionTimeout());
                        }
                        if (!cn.initDb(strConnect))
                            return false;
                        let sqlstmt;
                        if (this.launchInfo.getSqlstmt().trim() !== "") {
                            sqlstmt = this.launchInfo.getSqlstmt();
                        }
                        else {
                            if (connect.getDataSourceType() === csDataSourceType.CS_DT_PROCEDURE) {
                                p = p
                                    .then(() => connect.getSqlParameters())
                                    .then(params => sqlstmt = "exec [" + connect.getDataSource() + "] " + params);
                            }
                            else if (connect.getDataSourceType() === csDataSourceType.CS_DT_TABLE) {
                                sqlstmt = "select * from [" + connect.getDataSource() + "]";
                            }
                            else {
                                sqlstmt = connect.getDataSource();
                            }
                        }
                        p = p.then(P.call(this, () => {
                            cn.setOpenRsExDescript(this.userDescription);
                            if (!cn.loadDataTable(sqlstmt, dtr, drr)) {
                                return false;
                            }
                            if (dtr.get().rows.length === 0) {
                                if (createIndexVector) {
                                    this.vRowsIndex = [];
                                    this.lastRowIndex = -1;
                                }
                            }
                            else {
                                if (createIndexVector) {
                                    this.vRowsIndex = [];
                                    this.lastRowIndex = dtr.get().rows.length - 1;
                                    for (let k = 0, count = dtr.get().rows.length; k < count; k++) {
                                        this.vRowsIndex.push(k);
                                    }
                                }
                            }
                            varRs = [];
                            varRs.push(dtr.get());
                            varRs.push(connect.getDataSource());
                            recordSets.push(varRs);
                            while (!drr.get().isClosed() && drr.get().nextResult()) {
                                rsAux = new DataTable();
                                rsAux.load(drr.get());
                                varRs = [];
                                varRs.push(rsAux);
                                varRs.push(connect.getDataSource());
                                recordSets.push(varRs);
                                this.tables.push();
                            }
                            cn.closeDb();
                        }));
                    }
                    else {
                        dtr.set(null);
                        if (createIndexVector) {
                            this.vRowsIndex = [];
                            this.lastRowIndex = -1;
                        }
                    }
                    return p.then(P.call(this, () => {
                        this.iRow = 0;
                        this.idxGroupHeader = this.NO_GROUP_INDEX;
                        this.idxGroupFooter = this.NO_GROUP_INDEX;
                        return true;
                    }));
                }));
            }
            initRowFormulas() {
                this.lastRowPreEvaluated = [];
                this.lastRowPostEvaluated = [];
                for (let i = 0; i < 3; i++) {
                    this.lastRowPreEvaluated[i] = -1;
                    this.lastRowPostEvaluated[i] = -1;
                }
                for (let i = 0; i < this.groupCount; i++) {
                    this.vGroups[i].lastHPreRowEvaluated = -1;
                    this.vGroups[i].lastHPostRowEvaluated = -1;
                    this.vGroups[i].lastFPreRowEvaluated = -1;
                    this.vGroups[i].lastFPostRowEvaluated = -1;
                }
            }
            cleanCollections() {
                this.destroyCrossRef(this.headers);
                this.destroyCrossRef(this.details);
                this.destroyCrossRef(this.footers);
                this.destroyCrossRef(this.groups.getGroupsHeaders());
                this.destroyCrossRef(this.groups.getGroupsFooters());
                this.headers.clear();
                this.groups.clear();
                this.details.clear();
                this.footers.clear();
                this.controls.clear();
                this.formulas.clear();
                this.connect.getColumns().clear();
                this.connect.getParameters().clear();
                this.details.setCopyColl(this.controls);
                this.headers.setCopyColl(this.controls);
                this.footers.setCopyColl(this.controls);
                this.groupsHeaders.setCopyColl(this.controls);
                this.groupsFooters.setCopyColl(this.controls);
            }
            nLoad(docXml) {
                this.cleanCollections();
                if (!this.loadAux(docXml, this.headers, this.NODE_RPT_HEADERS)) {
                    return false;
                }
                if (!this.loadAux(docXml, this.details, this.NODE_RPT_DETAILS)) {
                    return false;
                }
                if (!this.loadAux(docXml, this.footers, this.NODE_RPT_FOOTERS)) {
                    return false;
                }
                if (!this.loadGroups(docXml)) {
                    return false;
                }
                this.fixGroupIndex();
                if (!this.loadConnect(docXml)) {
                    return false;
                }
                if (!this.loadConnectsAux(docXml)) {
                    return false;
                }
                if (!this.loadLaunchInfo(docXml)) {
                    return false;
                }
                this.loadPaperInfo(docXml);
                this.sortCollection();
                this.originalHeight = this.paperInfo.getCustomHeight();
                return true;
            }
            fixGroupIndex() {
                for (let i = 0; i < this.groups.count(); i++) {
                    this.groups.item(i).setIndex(i);
                }
            }
            copyPaperInfo(from) {
                this.paperInfo.copy(from.paperInfo);
            }
            loadPaperInfo(docXml) {
                let nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, this.NODE_PAPER_INFO);
                this.paperInfo.load(docXml, nodeObj);
            }
            sortCollection() {
                this.sortCollectionAux(this.headers);
                this.sortCollectionAux(this.details);
                this.sortCollectionAux(this.footers);
                this.sortCollectionAux(this.groupsFooters);
                this.sortCollectionAux(this.groupsHeaders);
            }
            sortCollectionAux(col) {
                let sec = null;
                let secLn = null;
                for (let i = 0; i < col.count(); i++) {
                    sec = col.item(i);
                    for (let j = 0; j < sec.getSectionLines().count(); j++) {
                        secLn = sec.getSectionLines().item(j);
                        secLn.setControls(this.getControlsInZOrder(secLn.getControls()));
                    }
                }
            }
            copyAux(from, to) {
                for (let i = 0; i < from.values.length; i++) {
                    const secTo = to.add(null, from.keys[i]);
                    const secFrom = from.values[i];
                    if (!secTo.copy(secFrom))
                        return false;
                }
                return true;
            }
            loadAux(docXml, sections, keySection) {
                let nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, keySection);
                if (docXml.nodeHasChild(nodeObj)) {
                    let nodeObjSec = docXml.getNodeChild(nodeObj);
                    while (nodeObjSec !== null) {
                        let nodeObjAux = nodeObjSec;
                        let key = docXml.getNodeProperty(nodeObjAux, "Key").getValueString(eTypes.eText);
                        let sec = sections.add(null, key);
                        if (!sec.load(docXml, nodeObjAux)) {
                            return false;
                        }
                        nodeObjSec = docXml.getNextNode(nodeObjSec);
                    }
                }
                return true;
            }
            loadFormulas(docXml) {
                let nodeObj = null;
                let nodeObjAux = null;
                let nodeObjSec = null;
                nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, this.NODE_RPT_FORMULAS);
                if (docXml.nodeHasChild(nodeObj)) {
                    nodeObjSec = docXml.getNodeChild(nodeObj);
                    while (nodeObjSec !== null) {
                        nodeObjAux = nodeObjSec;
                        let name = docXml.getNodeProperty(nodeObjAux, "Name").getValueString(eTypes.eText);
                        let formula = this.formulas.add(name);
                        if (!formula.load(docXml, nodeObjAux)) {
                            return false;
                        }
                        nodeObjSec = docXml.getNextNode(nodeObjSec);
                    }
                }
                return true;
            }
            copyConnect(from) {
                return this.connect.copy(from.connect);
            }
            loadConnect(docXml) {
                let nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, this.RPT_CONNECT);
                return this.connect.load(docXml, nodeObj);
            }
            copyConnectsAux(report) {
                return this.connectsAux.copy(report.connectsAux);
            }
            loadConnectsAux(docXml) {
                let nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, CSReportEngine.cReportConnectsAux.RPT_CONNECTS_AUX);
                return this.connectsAux.load(docXml, nodeObj);
            }
            copyGroups(report) {
                for (let i = 0; i < report.groups.values.length; i++) {
                    const group = this.getGroups().add(null, report.groups.keys[i]);
                    if (!group.copy(report.groups.values[i])) {
                        return false;
                    }
                }
                return true;
            }
            loadGroups(docXml) {
                let nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, this.NODE_GROUPS);
                if (docXml.nodeHasChild(nodeObj)) {
                    let nodeObjGroup = docXml.getNodeChild(nodeObj);
                    while (nodeObjGroup !== null) {
                        let nodeObjAux = nodeObjGroup;
                        let key = docXml.getNodeProperty(nodeObjAux, "Key").getValueString(eTypes.eText);
                        let group = this.getGroups().add(null, key);
                        if (!group.load(docXml, nodeObjAux)) {
                            return false;
                        }
                        nodeObjGroup = docXml.getNextNode(nodeObjGroup);
                    }
                }
                return true;
            }
            copyLaunchInfo(report) {
                if (this.launchInfo === null)
                    this.launchInfo = new CSReportEngine.cReportLaunchInfo();
                return this.launchInfo.copy(report.launchInfo);
            }
            loadLaunchInfo(docXml) {
                let nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, CSReportEngine.cReportLaunchInfo.LAUNCH_INFO);
                if (this.launchInfo === null)
                    this.launchInfo = new CSReportEngine.cReportLaunchInfo();
                return this.launchInfo.load(docXml, nodeObj);
            }
            getFileName(fileNameWithExt) {
                return cFile.getFileWithoutExt(fileNameWithExt);
            }
            nLoadData(docXml) {
                this.pages.clear();
                let nodeObj = docXml.getRootNode();
                nodeObj = docXml.getNodeFromNode(nodeObj, this.NODE_RPT_PAGES);
                if (docXml.nodeHasChild(nodeObj)) {
                    let nodeObjSec = docXml.getNodeChild(nodeObj);
                    while (nodeObjSec !== null) {
                        let nodeObjAux = nodeObjSec;
                        let page = this.pages.add(null);
                        if (!page.load(docXml, nodeObjAux)) {
                            return false;
                        }
                        nodeObjSec = docXml.getNextNode(nodeObjSec);
                    }
                }
                return true;
            }
            onReportDone(f) {
                this.reportDoneListener = f;
            }
            reportDone() {
                if (this.reportDoneListener !== null) {
                    this.reportDoneListener(this);
                }
            }
            onProgress(f) {
                this.progressListener = f;
            }
            progress(task, page = 0, currRecord = 0, recordCount = 0) {
                let cancel = false;
                if (this.progressListener !== null) {
                    let e = new CSReportEngine.ProgressEventArgs(task, page, currRecord, recordCount);
                    this.progressListener(this, e);
                    cancel = e.cancel;
                }
                return !cancel;
            }
            setRunningInWebWorker(rhs) {
                this.runningInWebWorker = rhs;
            }
            sortControlsByLeft() {
                this.sortControlsByLeftAux1(this.headers);
                this.sortControlsByLeftAux1(this.groupsHeaders);
                this.sortControlsByLeftAux1(this.details);
                this.sortControlsByLeftAux1(this.groupsFooters);
                this.sortControlsByLeftAux1(this.footers);
            }
            sortControlsByLeftAux1(sections) {
                for (let i = 0; i < sections.count(); i++) {
                    let sec = sections.item(i);
                    for (let j = 0; j < sec.getSectionLines().count(); j++) {
                        let secLn = sec.getSectionLines().item(j);
                        secLn.getControls().orderCollByLeft();
                    }
                }
            }
            dispose() {
                this.table = null;
                this.tables = null;
                this.vRowsIndexAux = null;
                this.vGroups = null;
                this.vRowsIndex = null;
                this.lastRowIndex = -1;
                this.lastRowPreEvaluated = null;
                this.lastRowPostEvaluated = null;
                this.controls.clear();
                this.controls = null;
                this.destroyCrossRef(this.headers);
                this.destroyCrossRef(this.details);
                this.destroyCrossRef(this.footers);
                this.destroyCrossRef(this.groups.getGroupsHeaders());
                this.destroyCrossRef(this.groups.getGroupsFooters());
                this.headers.clear();
                this.details.clear();
                this.footers.clear();
                this.groupsHeaders.clear();
                this.groupsFooters.clear();
                this.details.setCopyColl(null);
                this.headers.setCopyColl(null);
                this.footers.setCopyColl(null);
                this.groupsHeaders.setCopyColl(null);
                this.groupsFooters.setCopyColl(null);
                this.headers = null;
                this.details = null;
                this.footers = null;
                this.groupsHeaders = null;
                this.groupsFooters = null;
                this.paperInfo = null;
                this.formulas.clear();
                this.formulas = null;
                this.formulaTypes.clear();
                this.formulaTypes = null;
                this.connect = null;
                this.pages.clear();
                this.pages = null;
                this.pageSetting.clear();
                this.pageSetting = null;
                this.compiler = null;
                this.launchInfo = null;
                this.connectsAux.clear();
                this.connectsAux = null;
                this.destroyImages();
                this.images = null;
            }
            zip() {
                this.table = null;
                this.tables = null;
                this.vRowsIndexAux = null;
                this.vGroups = null;
                this.vRowsIndex = null;
                this.lastRowIndex = -1;
                this.lastRowPreEvaluated = null;
                this.lastRowPostEvaluated = null;
                this.controls.clear();
                this.controls = null;
                this.destroyCrossRef(this.headers, true);
                this.destroyCrossRef(this.details, true);
                this.destroyCrossRef(this.footers, true);
                this.destroyCrossRef(this.groups.getGroupsHeaders(), true);
                this.destroyCrossRef(this.groups.getGroupsFooters(), true);
                this.details.setCopyColl(null);
                this.headers.setCopyColl(null);
                this.footers.setCopyColl(null);
                this.groupsHeaders.setCopyColl(null);
                this.groupsFooters.setCopyColl(null);
                this.formulas.clear();
                this.formulas = null;
                this.formulaTypes.clear();
                this.formulaTypes = null;
                this.pages.clear();
                this.pages = null;
                this.compiler = null;
                this.destroyImages();
                this.images = null;
            }
            destroyCrossRef(secs, isZip = false) {
                for (let i = 0; i < secs.count(); i++) {
                    let sec = secs.item(i);
                    for (let j = 0; j < sec.getSectionLines().count(); j++) {
                        let secl = sec.getSectionLines().item(j);
                        secl.getControls().setSectionLine(null);
                        if (secl.getControls().getCopyColl() !== null) {
                            secl.getControls().getCopyColl().clear();
                        }
                        secl.getControls().setCopyColl(null);
                        if (!isZip) {
                            secl.getControls().clear();
                            secl.setControls(null);
                        }
                        secl.setCopyColl(null);
                    }
                    sec.setCopyColl(null);
                }
                secs.setCopyColl(null);
            }
            getMainDataSource(recordSets) {
                if (recordSets.length > 0) {
                    return recordSets[0][1].toString();
                }
                else {
                    return "";
                }
            }
            setIndexColInGroupFormulas(recordSets) {
                this.setIndexColInGroupFormulasAux(this.headers, recordSets);
                this.setIndexColInGroupFormulasAux(this.groupsHeaders, recordSets);
                this.setIndexColInGroupFormulasAux(this.groupsFooters, recordSets);
                this.setIndexColInGroupFormulasAux(this.details, recordSets);
                this.setIndexColInGroupFormulasAux(this.footers, recordSets);
            }
            setIndexColInGroupFormulasAux(sections, recordSets) {
                for (let i = 0; i < sections.count(); i++) {
                    let sec = sections.item(i);
                    if (sec.getHasFormulaHide()) {
                        this.setIndexColInGroupFormula(sec.getFormulaHide(), recordSets);
                    }
                    for (let j = 0; j < sec.getSectionLines().count(); j++) {
                        let secLn = sec.getSectionLines().item(j);
                        if (secLn.getHasFormulaHide()) {
                            this.setIndexColInGroupFormula(secLn.getFormulaHide(), recordSets);
                        }
                        for (let k = 0; k < secLn.getControls().count(); k++) {
                            let ctrl = secLn.getControls().item(k);
                            if (ctrl.getHasFormulaHide()) {
                                this.setIndexColInGroupFormula(ctrl.getFormulaHide(), recordSets);
                            }
                            if (ctrl.getHasFormulaValue()) {
                                this.setIndexColInGroupFormula(ctrl.getFormulaValue(), recordSets);
                            }
                        }
                    }
                }
            }
            setIndexColInGroupFormula(formula, recordSets) {
                if (!this.reportDisconnected) {
                    let rs = recordSets[0][0];
                    for (let i = 0; i < formula.getFormulasInt().count(); i++) {
                        let fint = formula.getFormulasInt().item(i);
                        if (this.isGroupFormula(fint.getFormulaType())) {
                            let colName = fint.getParameters().item(0).getValue();
                            this.setColIndexInGroupFormulaAux(rs, fint, colName, ReportGlobals.KEY_INDEX_COL);
                            if (fint.getFormulaType() === csRptFormulaType.CSRPTF_GROUP_PERCENT) {
                                colName = fint.getParameters().item(1).getValue();
                                this.setColIndexInGroupFormulaAux(rs, fint, colName, ReportGlobals.KEY_INDEX_COL2);
                            }
                        }
                    }
                }
            }
            setColIndexInGroupFormulaAux(rs, fint, colName, keyParam) {
                for (let i = 0; i < rs.columns.length; i++) {
                    if (colName.toLowerCase() === rs.columns[i].getName().toLowerCase()) {
                        if (fint.getParameters().item(keyParam) === null) {
                            fint.getParameters().add2("", keyParam);
                        }
                        fint.getParameters().item(keyParam).setValue(i.toString());
                        break;
                    }
                }
            }
            getControlsInZOrder(col) {
                let ctrls = new CSReportEngine.cReportControls();
                ctrls.setCopyColl(col.getCopyColl());
                ctrls.setTypeSection(col.getTypeSection());
                ctrls.setSectionLine(col.getSectionLine());
                while (col.count() > 0) {
                    let i = 32767;
                    for (let j = 0; j < col.count(); j++) {
                        let ctrl = col.item(j);
                        if (ctrl.getLabel().getAspect().getNZOrder() < i) {
                            i = ctrl.getLabel().getAspect().getNZOrder();
                        }
                    }
                    for (let j = 0; j < col.count(); j++) {
                        let ctrl = col.item(j);
                        if (ctrl.getLabel().getAspect().getNZOrder() === i) {
                            col.remove(ctrl.getKey());
                            ctrls.add(ctrl, ctrl.getKey());
                            break;
                        }
                    }
                    i = i + 1;
                }
                return ctrls;
            }
            debugGroupKeys() {
                let keys = new Array(this.groups.count() * 2);
                let groupCount = this.groups.count();
                for (let i = 0; i < groupCount; i++) {
                    let h = this.groups.getGroupsHeaders().item(i);
                    let f = this.groups.getGroupsFooters().item(i);
                    keys[i] = "H: " + h.getKey() + " " + h.getKeyPaint() + " " + h.getName() + " " + h.getIndex() + " " + h.getRealIndex();
                    keys[groupCount + i] = "F: " + f.getKey() + " " + h.getKeyPaint() + " " + f.getName() + " " + f.getIndex() + " " + f.getRealIndex();
                }
                return keys;
            }
            debugGroupPanitKeys() {
                let keys = new Array(this.groups.count() * 2);
                let groupCount = this.groups.count();
                for (let i = 0; i < groupCount; i++) {
                    keys[i] = "H: " + this.groups.getGroupsHeaders().item(i).getKeyPaint();
                    keys[groupCount + i] = "F: " + this.groups.getGroupsFooters().item(i).getKeyPaint();
                }
                return keys;
            }
        }
        CSReportEngine.cReport = cReport;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csDataType = CSReports.CSDatabase.csDataType;
        var eTypes = CSReports.CSKernelClient.eTypes;
        var cWindow = CSReports.CSKernelClient.cWindow;
        var P = CSReports.CSKernelClient.Callable;
        var Database = CSReports.CSDatabase.Database;
        class cReportConnect {
            constructor() {
                this.strConnect = "";
                this.dataSource = "";
                this.dataSourceType = null;
                this.parameters = new CSReportEngine.cParameters();
                this.columns = new CSReportEngine.cColumnsInfo();
                this.connectionTimeout = 0;
                this.commandTimeout = 0;
            }
            getConnectionTimeout() {
                return this.connectionTimeout;
            }
            setConnectionTimeout(value) {
                this.connectionTimeout = value;
            }
            getCommandTimeout() {
                return this.commandTimeout;
            }
            setCommandTimeout(value) {
                this.commandTimeout = value;
            }
            getStrConnect() {
                return this.strConnect;
            }
            setStrConnect(value) {
                this.strConnect = value;
            }
            getDataSource() {
                return this.dataSource;
            }
            setDataSource(value) {
                this.dataSource = value;
            }
            getDataSourceType() {
                return this.dataSourceType;
            }
            setDataSourceType(value) {
                this.dataSourceType = value;
            }
            getParameters() {
                return this.parameters;
            }
            setParameters(value) {
                this.parameters = value;
            }
            getColumns() {
                return this.columns;
            }
            setColumns(value) {
                this.columns = value;
            }
            getSqlParameters() {
                let s = "";
                let param = null;
                let p = P._();
                for (let _i = 0; _i < this.parameters.count(); _i++) {
                    p = p.then(P.call(this, () => {
                        param = this.parameters.item(_i);
                        switch (param.getColumnType()) {
                            case csDataType.CS_TD_WCHAR:
                            case csDataType.CS_TD_VARWCHAR:
                            case csDataType.CS_TD_VARCHAR:
                            case csDataType.CS_TD_LONGVARWCHAR:
                            case csDataType.CS_TD_LONGVARCHAR:
                            case csDataType.CS_TD_CHAR:
                                s += Database.sqlString(param.getValue()) + ",";
                                break;
                            case csDataType.CS_TD_TINYINT:
                            case csDataType.CS_TD_UNSIGNEDTINYINT:
                            case csDataType.CS_TD_SMALLINT:
                            case csDataType.CS_TD_SINGLE:
                            case csDataType.CS_TD_NUMERIC:
                            case csDataType.CS_TD_INTEGER:
                            case csDataType.CS_TD_DOUBLE:
                            case csDataType.CS_TD_DECIMAL:
                            case csDataType.CS_TD_CURRENCY:
                            case csDataType.CS_TD_BOOLEAN:
                            case csDataType.CS_TD_BIGINT:
                                s += Database.sqlNumber(param.getValue()) + ",";
                                break;
                            case csDataType.CS_TD_DBTIMESTAMP:
                            case csDataType.CS_TD_DBTIME:
                            case csDataType.CS_TD_DBDATE:
                            case csDataType.CS_TD_DATE:
                                s += Database.sqlDate(param.getValue()) + ",";
                                break;
                            default:
                                return cWindow.msgWarning("This data type is not codified "
                                    + param.getColumnType()
                                    + ". Parameter: " + param.getName()
                                    + ". Function: sqlParameters.", "Report connect");
                        }
                    }));
                }
                return p.then(() => {
                    if (s.length > 0 && s.substring(s.length - 1) === ",") {
                        s = s.substring(0, s.length - 1);
                    }
                    return s;
                });
            }
            copy(from) {
                this.dataSource = from.dataSource;
                this.dataSourceType = from.dataSourceType;
                this.strConnect = from.strConnect;
                this.loadColl(from.columns, this.columns);
                this.loadColl(from.parameters, this.parameters);
                return true;
            }
            loadColl(from, coll) {
                for (let i = 0; i < from.values.length; i++) {
                    let key = from.keys[i];
                    if (!coll.add(null, key).copy(from.values[i])) {
                        return;
                    }
                }
            }
            load(xDoc, nodeObj) {
                this.dataSource = xDoc.getNodeProperty(nodeObj, "DataSource").getValueString(eTypes.eText);
                this.dataSourceType = xDoc.getNodeProperty(nodeObj, "DataSourceType").getValueInt(eTypes.eInteger);
                this.strConnect = xDoc.getNodeProperty(nodeObj, "StrConnect").getValueString(eTypes.eText);
                this.loadNode(xDoc, xDoc.getNodeFromNode(nodeObj, cReportConnect.RPT_COLUMNS), this.columns);
                this.loadNode(xDoc, xDoc.getNodeFromNode(nodeObj, cReportConnect.RPT_PARAMETERS), this.parameters);
                return true;
            }
            loadNode(xDoc, node, coll) {
                if (xDoc.nodeHasChild(node)) {
                    let child = xDoc.getNodeChild(node);
                    while (child !== null) {
                        let key = xDoc.getNodeProperty(child, "Key").getValueString(eTypes.eText);
                        if (!coll.add(null, key).load(xDoc, child)) {
                            return;
                        }
                        child = xDoc.getNextNode(child);
                    }
                }
            }
            save(xDoc, nodeFather) {
                let nodeObj;
                let xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName(cReportConnect.RPT_CONNECT);
                if (nodeFather !== null) {
                    nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                }
                else {
                    nodeObj = xDoc.addNode(xProperty);
                }
                xProperty.setName("DataSource");
                xProperty.setValue(eTypes.eText, this.dataSource);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("DataSourceType");
                xProperty.setValue(eTypes.eInteger, this.dataSourceType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("StrConnect");
                xProperty.setValue(eTypes.eText, this.strConnect);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName(cReportConnect.RPT_COLUMNS);
                this.saveColumnNode(xDoc, xDoc.addNodeToNode(nodeObj, xProperty));
                xProperty.setName(cReportConnect.RPT_PARAMETERS);
                this.saveParamNode(xDoc, xDoc.addNodeToNode(nodeObj, xProperty));
            }
            saveColumnNode(xDoc, node) {
                let col = null;
                for (let _i = 0; _i < this.columns.count(); _i++) {
                    col = this.columns.item(_i);
                    if (!col.save(xDoc, node)) {
                        return false;
                    }
                }
            }
            saveParamNode(xDoc, node) {
                let param = null;
                for (let _i = 0; _i < this.parameters.count(); _i++) {
                    param = this.parameters.item(_i);
                    if (!param.save(xDoc, node)) {
                        return false;
                    }
                }
            }
            getXFromStrConnect(strConnect, x) {
                if (x.substring(x.length - 1) !== "=") {
                    x = x + "=";
                }
                let i = strConnect.indexOf(x, 0);
                if (i > 0) {
                    let p = strConnect.indexOf(";", i);
                    if (p === 0) {
                        p = strConnect.length + 1;
                    }
                    i = i + x.length;
                    debugger;
                    return strConnect.substring(i, p - i);
                }
                else {
                    return "";
                }
            }
        }
        cReportConnect.RPT_CONNECT = "RptConnect";
        cReportConnect.RPT_COLUMNS = "Columns";
        cReportConnect.RPT_PARAMETERS = "Parameters";
        CSReportEngine.cReportConnect = cReportConnect;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportSectionLine {
            constructor() {
                this.NODE_RPT_CONTROLS = "RptControls";
                this.controls = new CSReportEngine.cReportControls();
                this.aspect = new CSReportEngine.cReportAspect();
                this.index = 0;
                this.realIndex = 0;
                this.key = "";
                this.keyPaint = "";
                this.formulaHide = new CSReportEngine.cReportFormula();
                this.hasFormulaHide = null;
                this.idField = "";
                this.sectionName = "";
                this.controls.setSectionLine(this);
                this.formulaHide.setName("H");
            }
            getKeyPaint() {
                return this.keyPaint;
            }
            setKeyPaint(rhs) {
                this.keyPaint = rhs;
            }
            getControls() {
                return this.controls;
            }
            setControls(rhs) {
                this.controls = rhs;
            }
            getIdField() {
                return this.idField;
            }
            setIdField(rhs) {
                this.idField = rhs;
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            getAspect() {
                return this.aspect;
            }
            setAspect(rhs) {
                this.aspect = rhs;
            }
            getName() {
                return "SL: " + this.index.toString();
            }
            setName(name) {
            }
            getIndex() {
                return this.index;
            }
            setIndex(rhs) {
                this.index = rhs;
            }
            getRealIndex() {
                return this.realIndex;
            }
            setRealIndex(rhs) {
                this.realIndex = rhs;
            }
            getHasFormulaHide() {
                return this.hasFormulaHide;
            }
            setHasFormulaHide(rhs) {
                this.hasFormulaHide = rhs;
            }
            getFormulaHide() {
                return this.formulaHide;
            }
            getTypeSection() {
                return this.controls.getTypeSection();
            }
            setTypeSection(rhs) {
                this.controls.setTypeSection(rhs);
            }
            getSectionName() {
                return this.sectionName;
            }
            setSectionName(rhs) {
                this.sectionName = rhs;
            }
            setCopyColl(rhs) {
                if (this.controls !== null) {
                    this.controls.setCopyColl(rhs);
                }
            }
            copy(from) {
                this.index = from.index;
                this.idField = from.idField;
                this.hasFormulaHide = from.hasFormulaHide;
                if (!this.formulaHide.copy(from.formulaHide)) {
                    return false;
                }
                if (!this.aspect.copy(from.aspect)) {
                    return false;
                }
                for (let i = 0; i < from.controls.values.length; i++) {
                    const ctrl = this.controls.add(null, from.controls.keys[i]);
                    if (!ctrl.copy(from.controls.values[i])) {
                        return false;
                    }
                }
                return true;
            }
            load(xDoc, nodeObj) {
                let nodeObjCtrls = null;
                let nodeObjCtrl = null;
                let nodeObjAspect = null;
                let ctrl = null;
                this.index = xDoc.getNodeProperty(nodeObj, "Indice").getValueInt(eTypes.eInteger);
                this.idField = xDoc.getNodeProperty(nodeObj, "IdField").getValueString(eTypes.eText);
                this.hasFormulaHide = xDoc.getNodeProperty(nodeObj, "HasFormulaHide").getValueBool(eTypes.eBoolean);
                nodeObjAspect = nodeObj;
                let nodeObjAux = nodeObj;
                if (!this.formulaHide.load(xDoc, nodeObjAux)) {
                    return false;
                }
                if (!this.aspect.load(xDoc, nodeObjAspect)) {
                    return false;
                }
                nodeObjCtrls = xDoc.getNodeFromNode(nodeObj, this.NODE_RPT_CONTROLS);
                if (xDoc.nodeHasChild(nodeObjCtrls)) {
                    nodeObjCtrl = xDoc.getNodeChild(nodeObjCtrls);
                    while (nodeObjCtrl !== null) {
                        let key = xDoc.getNodeProperty(nodeObjCtrl, "Key").getValueString(eTypes.eText);
                        ctrl = this.controls.add(null, key);
                        if (!ctrl.load(xDoc, nodeObjCtrl)) {
                            return false;
                        }
                        nodeObjCtrl = xDoc.getNextNode(nodeObjCtrl);
                    }
                }
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName(this.key);
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Key");
                xProperty.setValue(eTypes.eText, this.key);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Indice");
                xProperty.setValue(eTypes.eInteger, this.index);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("IdField");
                xProperty.setValue(eTypes.eText, this.idField);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("HasFormulaHide");
                xProperty.setValue(eTypes.eBoolean, this.hasFormulaHide);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                if (!this.aspect.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.formulaHide.save(xDoc, nodeObj)) {
                    return false;
                }
                xProperty.setName(this.NODE_RPT_CONTROLS);
                nodeObj = xDoc.addNodeToNode(nodeObj, xProperty);
                let ctrl = null;
                for (let _i = 0; _i < this.controls.count(); _i++) {
                    ctrl = this.controls.item(_i);
                    ctrl.save(xDoc, nodeObj);
                }
                return true;
            }
        }
        CSReportEngine.cReportSectionLine = cReportSectionLine;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportSection {
            constructor() {
                this.NODE_RPT_SECTION_LINES = "RptSectionLines";
                this.sectionLines = new CSReportEngine.cReportSectionLines();
                this.aspect = new CSReportEngine.cReportAspect();
                this.index = 0;
                this.realIndex = 0;
                this.key = "";
                this.name = "";
                this.keyPaint = "";
                this.formulaHide = new CSReportEngine.cReportFormula();
                this.hasFormulaHide = null;
                this.typeSection = null;
                this.formulaHide.setName("H");
                this.sectionLines.add(null, "", -1);
            }
            getSectionLines() {
                return this.sectionLines;
            }
            setSectionLines(rhs) {
                this.sectionLines = rhs;
            }
            getAspect() {
                return this.aspect;
            }
            setAspect(rhs) {
                this.aspect = rhs;
            }
            getIndex() {
                return this.index;
            }
            setIndex(rhs) {
                this.index = rhs;
            }
            getRealIndex() {
                return this.realIndex;
            }
            setRealIndex(rhs) {
                this.realIndex = rhs;
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            getTypeSection() {
                return this.sectionLines.getTypeSection();
            }
            setTypeSection(rhs) {
                this.typeSection = rhs;
                this.sectionLines.setTypeSection(rhs);
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            setCopyColl(rhs) {
                if (this.sectionLines !== null) {
                    this.sectionLines.setCopyColl(rhs);
                }
            }
            getKeyPaint() {
                return this.keyPaint;
            }
            setKeyPaint(rhs) {
                this.keyPaint = rhs;
            }
            getHasFormulaHide() {
                return this.hasFormulaHide;
            }
            setHasFormulaHide(rhs) {
                this.hasFormulaHide = rhs;
            }
            getFormulaHide() {
                return this.formulaHide;
            }
            copy(from) {
                this.name = from.name;
                this.index = from.index;
                this.setTypeSection(from.typeSection);
                this.hasFormulaHide = from.hasFormulaHide;
                if (!this.aspect.copy(from.aspect)) {
                    return false;
                }
                if (!this.formulaHide.copy(from.formulaHide)) {
                    return false;
                }
                this.sectionLines.clear();
                for (let i = 0; i < from.sectionLines.values.length; i++) {
                    const seclTo = this.sectionLines.add(null, from.sectionLines.keys[i], -1);
                    if (!seclTo.copy(from.sectionLines.values[i])) {
                        return false;
                    }
                    seclTo.setSectionName(this.name);
                }
                return true;
            }
            load(xDoc, nodeObj) {
                let nodeObjSecLn = null;
                let nodeObjAspect = null;
                let secLn = null;
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                this.index = xDoc.getNodeProperty(nodeObj, "Indice").getValueInt(eTypes.eInteger);
                this.setTypeSection(xDoc.getNodeProperty(nodeObj, "TypeSection").getValueInt(eTypes.eInteger));
                this.hasFormulaHide = xDoc.getNodeProperty(nodeObj, "HasFormulaHide").getValueBool(eTypes.eBoolean);
                nodeObjAspect = nodeObj;
                if (!this.aspect.load(xDoc, nodeObjAspect)) {
                    return false;
                }
                let nodeObjAux = nodeObj;
                if (!this.formulaHide.load(xDoc, nodeObjAux)) {
                    return false;
                }
                this.sectionLines.clear();
                nodeObj = xDoc.getNodeFromNode(nodeObj, this.NODE_RPT_SECTION_LINES);
                if (xDoc.nodeHasChild(nodeObj)) {
                    nodeObjSecLn = xDoc.getNodeChild(nodeObj);
                    while (nodeObjSecLn !== null) {
                        let key = xDoc.getNodeProperty(nodeObjSecLn, "Key").getValueString(eTypes.eText);
                        secLn = this.sectionLines.add(null, key, -1);
                        if (!secLn.load(xDoc, nodeObjSecLn)) {
                            return false;
                        }
                        secLn.setSectionName(this.name);
                        nodeObjSecLn = xDoc.getNextNode(nodeObjSecLn);
                    }
                }
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName(this.key);
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Key");
                xProperty.setValue(eTypes.eText, this.key);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Indice");
                xProperty.setValue(eTypes.eInteger, this.index);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("TypeSection");
                xProperty.setValue(eTypes.eInteger, this.getTypeSection());
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("HasFormulaHide");
                xProperty.setValue(eTypes.eBoolean, this.hasFormulaHide);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                if (!this.aspect.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.formulaHide.save(xDoc, nodeObj)) {
                    return false;
                }
                xProperty.setName(this.NODE_RPT_SECTION_LINES);
                xProperty.setValue(eTypes.eText, "");
                nodeObj = xDoc.addNodeToNode(nodeObj, xProperty);
                let seccLn = null;
                for (let _i = 0; _i < this.sectionLines.count(); _i++) {
                    seccLn = this.sectionLines.item(_i);
                    seccLn.save(xDoc, nodeObj);
                }
                return true;
            }
        }
        CSReportEngine.cReportSection = cReportSection;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportFormula {
            constructor() {
                this.name = "";
                this.text = "";
                this.formulasInt = new CSReportEngine.cReportFormulasInt();
                this.notSave = null;
                this.textC = "";
                this.idxGroup = 0;
                this.idxGroup2 = -9999;
                this.whenEval = null;
                this.haveToEval = null;
                this.lastResult = null;
                this.controlName = "";
                this.sectionLineIndex = 0;
                this.sectionName = "";
                this.compiledScript = null;
            }
            getCompiledScript() {
                return this.compiledScript;
            }
            setCompiledScript(value) {
                this.compiledScript = value;
            }
            getIdxGroup() {
                return this.idxGroup;
            }
            setIdxGroup(rhs) {
                this.idxGroup = rhs;
            }
            getIdxGroup2() {
                return this.idxGroup2;
            }
            setIdxGroup2(rhs) {
                this.idxGroup2 = rhs;
            }
            getWhenEval() {
                return this.whenEval;
            }
            setWhenEval(rhs) {
                this.whenEval = rhs;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getText() {
                return this.text;
            }
            setText(rhs) {
                this.text = rhs;
            }
            getControlName() {
                return this.controlName;
            }
            setControlName(rhs) {
                this.controlName = rhs;
            }
            getSectionName() {
                return this.sectionName;
            }
            setSectionName(rhs) {
                this.sectionName = rhs;
            }
            getSectionLineIndex() {
                return this.sectionLineIndex;
            }
            setSectionLineIndex(rhs) {
                this.sectionLineIndex = rhs;
            }
            getFormulasInt() {
                return this.formulasInt;
            }
            getTextC() {
                return this.textC;
            }
            setTextC(rhs) {
                this.textC = rhs;
            }
            getNotSave() {
                return this.notSave;
            }
            setNotSave(rhs) {
                this.notSave = rhs;
            }
            getHaveToEval() {
                return this.haveToEval;
            }
            setHaveToEval(rhs) {
                this.haveToEval = rhs;
            }
            getLastResult() {
                return this.lastResult;
            }
            setLastResult(rhs) {
                this.lastResult = rhs;
            }
            copy(from) {
                if (from !== null) {
                    this.name = from.name;
                    this.text = from.text;
                    this.idxGroup = from.idxGroup;
                    this.whenEval = from.whenEval;
                }
                return true;
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, this.name);
                if (nodeObj !== null) {
                    this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                    this.text = xDoc.getNodeProperty(nodeObj, "Text").getValueString(eTypes.eText);
                    this.idxGroup = xDoc.getNodeProperty(nodeObj, "idxGroup").getValueInt(eTypes.eLong);
                    this.whenEval = xDoc.getNodeProperty(nodeObj, "WhenEval").getValueInt(eTypes.eInteger);
                }
                return true;
            }
            save(xDoc, nodeFather) {
                const xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName(this.name);
                const nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Text");
                xProperty.setValue(eTypes.eText, this.text);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("idxGroup");
                xProperty.setValue(eTypes.eLong, this.idxGroup);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("WhenEval");
                xProperty.setValue(eTypes.eInteger, this.whenEval);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
            toString() {
                return "name: " + this.name + ",whenEval: " + this.whenEval;
            }
        }
        CSReportEngine.cReportFormula = cReportFormula;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csColors = CSReports.CSDrawing.csColors;
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportChartSequence {
            constructor() {
                this.valueFieldName = "";
                this.labelFieldName = "";
                this.color = csColors.ALICEBLUE;
                this.valueIndex = 0;
                this.labelIndex = 0;
            }
            getValueFieldName() {
                return this.valueFieldName;
            }
            setValueFieldName(rhs) {
                this.valueFieldName = rhs;
            }
            getLabelFieldName() {
                return this.labelFieldName;
            }
            setLabelFieldName(rhs) {
                this.labelFieldName = rhs;
            }
            getColor() {
                return this.color;
            }
            setColor(value) {
                this.color = value;
            }
            getValueIndex() {
                return this.valueIndex;
            }
            setValueIndex(rhs) {
                this.valueIndex = rhs;
            }
            getLabelIndex() {
                return this.labelIndex;
            }
            setLabelIndex(rhs) {
                this.labelIndex = rhs;
            }
            copy(from) {
                this.valueFieldName = from.valueFieldName;
                this.labelFieldName = from.labelFieldName;
                this.color = from.color;
                return true;
            }
            load(xDoc, nodeObj, index) {
                try {
                    this.valueFieldName = xDoc.getNodeProperty(nodeObj, "ValueFieldName").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.labelFieldName = xDoc.getNodeProperty(nodeObj, "LabelFieldName").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.color = xDoc.getNodeProperty(nodeObj, "Color").getValueString(eTypes.eLong);
                }
                catch (ex) { }
                return true;
            }
            save(xDoc, nodeFather, index) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Serie_" + index.toString());
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("ValueFieldName");
                xProperty.setValue(eTypes.eText, this.valueFieldName);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("LabelFieldName");
                xProperty.setValue(eTypes.eText, this.labelFieldName);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Color");
                xProperty.setValue(eTypes.eLong, this.color);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
        }
        CSReportEngine.cReportChartSequence = cReportChartSequence;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csReportPaperType = CSReports.CSReportGlobals.csReportPaperType;
        var csRptPageOrientation = CSReports.CSReportGlobals.csRptPageOrientation;
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        var Utils = CSReports.CSOAPI.Utils;
        var RefWrapper = CSReports.CSKernelClient.RefWrapper;
        class cPrintAPI {
            static showPrintDialog(printDialog, deviceName, driverName, port, paperSize, orientation, fromPage, toPage, copies, paperBin) {
                let settings = printDialog.getPrinterSettings();
                settings.setPrinterName(deviceName);
                settings.setFromPage(fromPage);
                settings.setToPage(toPage);
                settings.setCopies(copies);
                if (printDialog.showDialog() === DialogResult.OK) {
                    deviceName = settings.getPrinterName();
                    fromPage = settings.getFromPage();
                    toPage = settings.getToPage();
                    copies = settings.getCopies();
                    return true;
                }
                else {
                    return false;
                }
            }
            printerSetPaperBin(deviceName, oldPaperBin) {
                throw new NotImplementedException();
            }
            endDoc(hDC) {
                throw new NotImplementedException();
            }
            static getcPrint(printDialog, deviceName, driverName, port, orientation = 1, paperSize = 1, width = new RefWrapper(1), height = new RefWrapper(1)) {
                let o = new CSReportEngine.cPrinter(printDialog);
                o.setDeviceName(deviceName);
                o.setDriverName(driverName);
                o.setPort(port);
                let paperInfo = o.getPaperInfo();
                paperInfo.setOrientation(orientation);
                paperInfo.setPaperSize(paperSize);
                if (width.get() === 0 || height.get() === 0) {
                    this.getSizeFromPaperSize(paperSize, orientation, width, height);
                }
                paperInfo.setWidth(width.get());
                paperInfo.setHeight(height.get());
                return o;
            }
            getcPrint2(printDialog, deviceName, driverName, port) {
                let printerConfigInfo = CSReportEngine.cPrintWMI.getPrinterConfigInfoFromWMI(deviceName);
                let paperSize = cPrintAPI.getPaperSizeFromSizeName(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("PaperSize", printerConfigInfo, "A4"));
                let orientation = Utils.valInt(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("Orientation", printerConfigInfo, 1));
                let width = new RefWrapper(Utils.valInt(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("PaperWidth", printerConfigInfo, 210)));
                let height = new RefWrapper(Utils.valInt(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("PaperLength", printerConfigInfo, 297)));
                return cPrintAPI.getcPrint(printDialog, deviceName, driverName, port, orientation, paperSize, width, height);
            }
            static getcPrinterFromDefaultPrinter(printDialog) {
                let deviceName = new RefWrapper("");
                let driverName = new RefWrapper("");
                let port = new RefWrapper("");
                let paperSize = new RefWrapper(0);
                let orientation = new RefWrapper(0);
                let width = new RefWrapper(0);
                let height = new RefWrapper(0);
                this.getDefaultPrinter(deviceName, driverName, port, paperSize, orientation, width, height);
                if (deviceName.get() !== "") {
                    return this.getcPrint(printDialog, deviceName.get(), driverName.get(), port.get(), orientation.get(), paperSize.get(), width, height);
                }
                else {
                    return null;
                }
            }
            static printerPaperBinNameToId(p, p_2, paperBin) {
                throw new NotImplementedException();
            }
            static getDefaultPrinter(deviceName, driverName, port, paperSize, orientation, width, height) {
                let settings = new PrinterSettings();
                deviceName.set(settings.getPrinterName());
                let printerInfo = CSReportEngine.cPrintWMI.getPrinterInfoFromWMI(deviceName.get());
                driverName.set(CSReportEngine.cPrintWMI.getPrinterInfoValueFromWMI("DriverName", printerInfo, ""));
                port.set(CSReportEngine.cPrintWMI.getPrinterInfoValueFromWMI("PortName", printerInfo, ""));
                let printerConfigInfo = CSReportEngine.cPrintWMI.getPrinterConfigInfoFromWMI(settings.getPrinterName());
                paperSize.set(this.getPaperSizeFromSizeName(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("PaperSize", printerConfigInfo, "A4").toString()));
                orientation.set(Math.trunc(Utils.valInt(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("Orientation", printerConfigInfo, 1))));
                width.set(Utils.valInt(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("PaperWidth", printerConfigInfo, 210)));
                height.set(Utils.valInt(CSReportEngine.cPrintWMI.getPrinterConfigInfoValueFromWMI("PaperLength", printerConfigInfo, 297)));
                if (width.get() === 0 || height.get() === 0 || paperSize.get() === 99) {
                    if (paperSize.get() === 99)
                        paperSize.set(1);
                    this.getSizeFromPaperSize(paperSize.get(), orientation.get(), width, height);
                }
            }
            static getPaperSize(paperSize, orientation) {
                const width = new RefWrapper(0);
                const height = new RefWrapper(0);
                this.getSizeFromPaperSize(paperSize, orientation, width, height);
                return { height: height.get(), width: width.get() };
            }
            static getSizeFromPaperSize(paperSize, orientation, width, height) {
                switch (paperSize) {
                    case csReportPaperType.CS_RPT_PAPER_TYPE_LETTER:
                        height.set(279);
                        width.set(216);
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_LEGAL:
                        height.set(356);
                        width.set(216);
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_A4:
                        height.set(297);
                        width.set(210);
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_A3:
                        height.set(420);
                        width.set(297);
                        break;
                    default:
                        height.set(0);
                        width.set(0);
                        break;
                }
                if (orientation === csRptPageOrientation.LANDSCAPE) {
                    const tmp = height.get();
                    height.set(width.get());
                    width.set(tmp);
                }
            }
            static getPaperSizeFromSizeName(sizeName) {
                let size;
                switch (sizeName.toLowerCase()) {
                    case "a4":
                        size = csReportPaperType.CS_RPT_PAPER_TYPE_A4;
                        break;
                    case "letter":
                        size = csReportPaperType.CS_RPT_PAPER_TYPE_LETTER;
                        break;
                    case "legal":
                        size = csReportPaperType.CS_RPT_PAPER_TYPE_LEGAL;
                        break;
                    default:
                        size = csReportPaperType.CS_RPT_PAPER_USER;
                        break;
                }
                return size;
            }
        }
        CSReportEngine.cPrintAPI = cPrintAPI;
        class PrintDialog {
            getPrinterSettings() {
                return null;
            }
            showDialog() {
                return DialogResult.OK;
            }
        }
        CSReportEngine.PrintDialog = PrintDialog;
        class PrinterSettings {
            setPrinterName(deviceName) {
                this.deviceName = deviceName;
            }
            setFromPage(fromPage) {
                this.fromPage = fromPage;
            }
            setToPage(toPage) {
                this.toPage = toPage;
            }
            setCopies(copies) {
                this.copies = copies;
            }
            getPrinterName() {
                return this.printerName;
            }
            getFromPage() {
                return this.fromPage;
            }
            getToPage() {
                return this.getToPage();
            }
            getCopies() {
                return this.getCopies();
            }
        }
        CSReportEngine.PrinterSettings = PrinterSettings;
        let DialogResult;
        (function (DialogResult) {
            DialogResult[DialogResult["OK"] = 0] = "OK";
        })(DialogResult = CSReportEngine.DialogResult || (CSReportEngine.DialogResult = {}));
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportLaunchInfo {
            constructor() {
                this.file = "";
                this.dataSource = null;
                this.sqlstmt = "";
                this.strConnect = "";
                this.printer = null;
                this.showPrintersDialog = null;
                this.internalPreview = null;
                this.action = null;
                this.copies = 0;
                this.silent = null;
                this.fileFormat = null;
                this.reportPrint = null;
            }
            getFile() {
                return this.file;
            }
            setFile(rhs) {
                this.file = rhs;
            }
            getDataSource() {
                return this.dataSource;
            }
            setDataSource(rhs) {
                this.dataSource = rhs;
            }
            getSqlstmt() {
                return this.sqlstmt;
            }
            setSqlstmt(rhs) {
                this.sqlstmt = rhs;
            }
            getStrConnect() {
                return this.strConnect;
            }
            setStrConnect(rhs) {
                this.strConnect = rhs;
            }
            getPrinter() {
                return this.printer;
            }
            setPrinter(rhs) {
                this.printer = rhs;
            }
            getFileFormat() {
                return this.fileFormat;
            }
            setFileFormat(rhs) {
                this.fileFormat = rhs;
            }
            getReportPrint() {
                return this.reportPrint;
            }
            setReportPrint(rhs) {
                this.reportPrint = rhs;
            }
            getAction() {
                return this.action;
            }
            setAction(rhs) {
                this.action = rhs;
            }
            getShowPrintersDialog() {
                return this.showPrintersDialog;
            }
            setShowPrintersDialog(rhs) {
                this.showPrintersDialog = rhs;
            }
            getInternalPreview() {
                return this.internalPreview;
            }
            setInternalPreview(rhs) {
                this.internalPreview = rhs;
            }
            getCopies() {
                return this.copies;
            }
            setCopies(rhs) {
                this.copies = rhs;
            }
            getSilent() {
                return this.silent;
            }
            setSilent(rhs) {
                this.silent = rhs;
            }
            initPrinter(printDialog, deviceName, driverName, port) {
                this.printer = CSReportEngine.cPrintAPI.getcPrint(printDialog, deviceName, driverName, port);
            }
            setPaperBin(paperBin) {
                if (this.printer === null) {
                    return;
                }
                if (paperBin.length === 0) {
                    let idPaperBin = CSReportEngine.cPrintAPI.printerPaperBinNameToId(this.printer.getDeviceName(), this.printer.getPort(), paperBin);
                    this.printer.getPaperInfo().setPaperBin(idPaperBin);
                }
            }
            copy(from) {
                var _a, _b, _c, _d;
                this.strConnect = from.strConnect;
                this.action = from.action;
                this.copies = from.copies;
                this.file = from.file;
                this.fileFormat = from.fileFormat;
                this.internalPreview = from.internalPreview;
                this.showPrintersDialog = from.showPrintersDialog;
                this.silent = from.silent;
                this.sqlstmt = from.sqlstmt;
                this.printer = new CSReportEngine.cPrinter(null);
                this.printer.setCopies((_a = from.printer) === null || _a === void 0 ? void 0 : _a.copies);
                this.printer.setDeviceName((_b = from.printer) === null || _b === void 0 ? void 0 : _b.deviceName);
                this.printer.setDriverName((_c = from.printer) === null || _c === void 0 ? void 0 : _c.driverName);
                this.printer.setPort((_d = from.printer) === null || _d === void 0 ? void 0 : _d.port);
                return true;
            }
            load(xDoc, nodeObj) {
                this.strConnect = xDoc.getNodeProperty(nodeObj, "StrConnect").getValueString(eTypes.eText);
                this.action = xDoc.getNodeProperty(nodeObj, "Action").getValueInt(eTypes.eInteger);
                this.copies = xDoc.getNodeProperty(nodeObj, "Copies").getValueInt(eTypes.eInteger);
                this.file = xDoc.getNodeProperty(nodeObj, "File").getValueString(eTypes.eText);
                this.fileFormat = xDoc.getNodeProperty(nodeObj, "FileFormat").getValueInt(eTypes.eInteger);
                this.internalPreview = xDoc.getNodeProperty(nodeObj, "InternalPreview").getValueBool(eTypes.eBoolean);
                this.showPrintersDialog = xDoc.getNodeProperty(nodeObj, "ShowPrintersDialog").getValueBool(eTypes.eBoolean);
                this.silent = xDoc.getNodeProperty(nodeObj, "Silent").getValueBool(eTypes.eBoolean);
                this.sqlstmt = xDoc.getNodeProperty(nodeObj, "Sqlstmt").getValueString(eTypes.eText);
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = new CSReports.CSXml.cXmlProperty();
                let nodeObj;
                xProperty.setName(cReportLaunchInfo.LAUNCH_INFO);
                if (nodeFather !== null) {
                    nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                }
                else {
                    nodeObj = xDoc.addNode(xProperty);
                }
                xProperty.setName("Action");
                xProperty.setValue(eTypes.eInteger, this.action);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Copies");
                xProperty.setValue(eTypes.eInteger, this.copies);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("File");
                xProperty.setValue(eTypes.eText, this.file);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("FileFormat");
                xProperty.setValue(eTypes.eInteger, this.fileFormat);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("InternalPreview");
                xProperty.setValue(eTypes.eBoolean, this.internalPreview);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ShowPrintersDialog");
                xProperty.setValue(eTypes.eBoolean, this.showPrintersDialog);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Silent");
                xProperty.setValue(eTypes.eBoolean, this.silent);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Sqlstmt");
                xProperty.setValue(eTypes.eText, this.sqlstmt);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("StrConnect");
                xProperty.setValue(eTypes.eText, this.strConnect);
                xDoc.addPropertyToNode(nodeObj, xProperty);
            }
        }
        cReportLaunchInfo.LAUNCH_INFO = "RptLaunchInfo";
        CSReportEngine.cReportLaunchInfo = cReportLaunchInfo;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csColors = CSReports.CSDrawing.csColors;
        var HorizontalAlignment = CSReports.CSReportGlobals.HorizontalAlignment;
        var csReportBorderType = CSReports.CSReportGlobals.csReportBorderType;
        var eTypes = CSReports.CSKernelClient.eTypes;
        var Utils = CSReports.CSOAPI.Utils;
        class cReportAspect {
            constructor() {
                this.left = 0;
                this.top = 0;
                this.height = 0;
                this.width = 0;
                this.backColor = csColors.WHITE;
                this.borderWidth = 0;
                this.borderType = csReportBorderType.CS_RPT_BS_NONE;
                this.borderColor = csColors.BLACK;
                this.borderColor3d = csColors.BLACK;
                this.borderColor3dShadow = csColors.BLACK;
                this.selectColor = csColors.BLACK;
                this.font = new CSReportEngine.cReportFont();
                this.canGrow = null;
                this.nZOrder = 0;
                this.align = HorizontalAlignment.Left;
                this.transparent = null;
                this.format = "";
                this.symbol = "";
                this.isAccounting = null;
                this.wordWrap = null;
                this.borderRounded = null;
                this.offset = 0;
            }
            setOffset(rhs) {
                this.offset = rhs;
            }
            getOffset() {
                return this.offset;
            }
            getLeft() {
                return this.left;
            }
            setLeft(rhs) {
                this.left = rhs;
            }
            getTop() {
                return this.top;
            }
            setTop(rhs) {
                this.top = rhs;
            }
            getWidth() {
                return this.width;
            }
            setWidth(rhs) {
                this.width = rhs;
            }
            getHeight() {
                return this.height;
            }
            setHeight(rhs) {
                if (rhs < 1) {
                    rhs = 1;
                }
                this.height = rhs;
            }
            getBackColor() {
                return this.backColor;
            }
            setBackColor(rhs) {
                this.backColor = rhs;
            }
            getBorderWidth() {
                return this.borderWidth;
            }
            setBorderWidth(rhs) {
                this.borderWidth = rhs;
            }
            getBorderType() {
                return this.borderType;
            }
            setBorderType(rhs) {
                this.borderType = rhs;
            }
            getBorderColor() {
                return this.borderColor;
            }
            setBorderColor(rhs) {
                this.borderColor = rhs;
            }
            getBorderColor3d() {
                return this.borderColor3d;
            }
            setBorderColor3d(rhs) {
                this.borderColor3d = rhs;
            }
            getBorderColor3dShadow() {
                return this.borderColor3dShadow;
            }
            setBorderColor3dShadow(rhs) {
                this.borderColor3dShadow = rhs;
            }
            getSelectColor() {
                return this.selectColor;
            }
            setSelectColor(rhs) {
                this.selectColor = rhs;
            }
            getFont() {
                return this.font;
            }
            setFont(rhs) {
                this.font = rhs;
            }
            getCanGrow() {
                return this.canGrow;
            }
            setCanGrow(rhs) {
                this.canGrow = rhs;
            }
            getNZOrder() {
                return this.nZOrder;
            }
            setNZOrder(rhs) {
                this.nZOrder = rhs;
            }
            getAlign() {
                return this.align;
            }
            setAlign(rhs) {
                this.align = rhs;
            }
            getTransparent() {
                return this.transparent;
            }
            setTransparent(rhs) {
                this.transparent = rhs;
            }
            getFormat() {
                return this.format;
            }
            setFormat(rhs) {
                this.format = rhs;
            }
            getSymbol() {
                return this.symbol;
            }
            setSymbol(rhs) {
                this.symbol = rhs;
            }
            getIsAccounting() {
                return this.isAccounting;
            }
            setIsAccounting(rhs) {
                this.isAccounting = rhs;
            }
            getWordWrap() {
                return this.wordWrap;
            }
            setWordWrap(rhs) {
                this.wordWrap = rhs;
            }
            getBorderRounded() {
                return this.borderRounded;
            }
            setBorderRounded(rhs) {
                this.borderRounded = rhs;
            }
            copy(from) {
                this.align = from.align;
                this.backColor = from.backColor.toString();
                this.borderColor = from.borderColor.toString();
                this.borderColor3d = from.borderColor3d.toString();
                this.borderColor3dShadow = from.borderColor3dShadow.toString();
                this.borderType = from.borderType;
                this.borderWidth = from.borderWidth;
                this.height = from.height;
                this.canGrow = from.canGrow;
                this.left = from.left;
                this.nZOrder = from.nZOrder;
                this.selectColor = from.selectColor.toString();
                this.top = from.top;
                this.width = from.width;
                this.transparent = from.transparent;
                this.format = from.format;
                this.symbol = from.symbol;
                this.isAccounting = from.isAccounting;
                this.wordWrap = from.wordWrap;
                this.borderRounded = from.borderRounded;
                return this.font.copy(from.font);
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, "Aspect");
                try {
                    this.align = xDoc.getNodeProperty(nodeObj, "Align").getValueInt(eTypes.eInteger);
                }
                catch (ex) { }
                try {
                    this.backColor = xDoc.getNodeProperty(nodeObj, "BackColor").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.borderColor = xDoc.getNodeProperty(nodeObj, "BorderColor").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.borderColor3d = xDoc.getNodeProperty(nodeObj, "BorderColor3D").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.borderColor3dShadow = xDoc.getNodeProperty(nodeObj, "BorderColor3DShadow").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.borderType = xDoc.getNodeProperty(nodeObj, "BorderType").getValueInt(eTypes.eInteger);
                }
                catch (ex) { }
                try {
                    this.borderWidth = xDoc.getNodeProperty(nodeObj, "BorderWidth").getValueInt(eTypes.eLong);
                }
                catch (ex) { }
                try {
                    this.height = xDoc.getNodeProperty(nodeObj, "Height").getValueInt(eTypes.eLong);
                }
                catch (ex) { }
                try {
                    this.canGrow = xDoc.getNodeProperty(nodeObj, "CanGrow").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                try {
                    this.left = xDoc.getNodeProperty(nodeObj, "Left").getValueInt(eTypes.eLong);
                }
                catch (ex) { }
                try {
                    this.nZOrder = xDoc.getNodeProperty(nodeObj, "nZOrder").getValueInt(eTypes.eInteger);
                }
                catch (ex) { }
                try {
                    this.selectColor = xDoc.getNodeProperty(nodeObj, "SelectColor").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.top = xDoc.getNodeProperty(nodeObj, "Top").getValueInt(eTypes.eLong);
                }
                catch (ex) { }
                try {
                    this.width = xDoc.getNodeProperty(nodeObj, "Width").getValueInt(eTypes.eLong);
                }
                catch (ex) { }
                try {
                    this.transparent = xDoc.getNodeProperty(nodeObj, "Transparent").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                try {
                    this.format = xDoc.getNodeProperty(nodeObj, "Format").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.symbol = xDoc.getNodeProperty(nodeObj, "Symbol").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.isAccounting = xDoc.getNodeProperty(nodeObj, "IsAccounting").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                try {
                    this.wordWrap = xDoc.getNodeProperty(nodeObj, "WordWrap").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                try {
                    this.borderRounded = xDoc.getNodeProperty(nodeObj, "BorderRounded").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                this.twipsToPixels();
                return this.font.load(xDoc, nodeObj);
            }
            save(xDoc, nodeFather) {
                this.pixelsToTwips();
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Aspect");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Align");
                xProperty.setValue(eTypes.eInteger, this.align);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BackColor");
                xProperty.setValue(eTypes.eText, this.backColor);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BorderColor");
                xProperty.setValue(eTypes.eText, this.borderColor);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BorderColor3D");
                xProperty.setValue(eTypes.eText, this.borderColor3d);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BorderColor3DShadow");
                xProperty.setValue(eTypes.eText, this.borderColor3dShadow);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BorderType");
                xProperty.setValue(eTypes.eInteger, this.borderType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BorderWidth");
                xProperty.setValue(eTypes.eLong, this.borderWidth);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("CanGrow");
                xProperty.setValue(eTypes.eBoolean, this.canGrow);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Height");
                xProperty.setValue(eTypes.eLong, this.height);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Format");
                xProperty.setValue(eTypes.eText, this.format);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Left");
                xProperty.setValue(eTypes.eLong, this.left);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("nZOrder");
                xProperty.setValue(eTypes.eInteger, this.nZOrder);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("SelectColor");
                xProperty.setValue(eTypes.eText, this.selectColor);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Top");
                xProperty.setValue(eTypes.eLong, this.top);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Width");
                xProperty.setValue(eTypes.eLong, this.width);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Transparent");
                xProperty.setValue(eTypes.eBoolean, this.transparent);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Symbol");
                xProperty.setValue(eTypes.eText, this.symbol);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("IsAccounting");
                xProperty.setValue(eTypes.eBoolean, this.isAccounting);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("WordWrap");
                xProperty.setValue(eTypes.eBoolean, this.wordWrap);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BorderRounded");
                xProperty.setValue(eTypes.eBoolean, this.borderRounded);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                this.twipsToPixels();
                return this.font.save(xDoc, nodeObj);
            }
            twipsToPixels() {
                this.height = Utils.tp(Math.trunc(this.height));
                this.left = Utils.tp(Math.trunc(this.left));
                this.top = Utils.tp(Math.trunc(this.top));
                this.width = Utils.tp(Math.trunc(this.width));
            }
            pixelsToTwips() {
                this.height = Utils.pt(Math.trunc(this.height));
                this.left = Utils.pt(Math.trunc(this.left));
                this.top = Utils.pt(Math.trunc(this.top));
                this.width = Utils.pt(Math.trunc(this.width));
            }
            toString() {
                return "height: " + this.height + ", width: " + this.width + ", foreColor: " + this.getFont().getForeColor();
            }
        }
        CSReportEngine.cReportAspect = cReportAspect;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        var cError = CSReports.CSKernelClient.cError;
        var cReportAspect = CSReports.CSReportEngine.cReportAspect;
        var csColors = CSReports.CSDrawing.csColors;
        var HorizontalAlignment = CSReports.CSReportGlobals.HorizontalAlignment;
        var csReportBorderType = CSReports.CSReportGlobals.csReportBorderType;
        var RefWrapper = CSReports.CSKernelClient.RefWrapper;
        var P = CSReports.CSKernelClient.Callable;
        var HatchBrush = CSReports.CSDrawing.HatchBrush;
        var Bitmap = CSReports.CSDrawing.Bitmap;
        var Graphic = CSReports.CSDrawing.Graphic;
        var Color = CSReports.CSDrawing.Color;
        var StringTrimming = CSReports.CSDrawing.StringTrimming;
        var StringFormat = CSReports.CSDrawing.StringFormat;
        var StringFormatFlags = CSReports.CSDrawing.StringFormatFlags;
        var StringAlignment = CSReports.CSDrawing.StringAlignment;
        var cGraphics = CSReports.CSDrawing.cGraphics;
        var DashStyle = CSReports.CSDrawing.DashStyle;
        var SolidBrush = CSReports.CSDrawing.SolidBrush;
        var HatchStyle = CSReports.CSDrawing.HatchStyle;
        var Pen = CSReports.CSDrawing.Pen;
        class cReportPaint {
            constructor() {
                this.paintObjects = new CSReportPaint.cReportPaintObjects();
                this.paintSections = new CSReportPaint.cReportPaintObjects();
                this.paintGridAreas = new CSReportPaint.cReportPaintObjects();
                this.nextKey = 0;
                this.brushGrid = null;
                this.x1 = 0;
                this.y1 = 0;
                this.y2 = 0;
                this.x2 = 0;
                this.x1Ex = 0;
                this.y1Ex = 0;
                this.y2Ex = 0;
                this.x2Ex = 0;
                this.beginMoveDone = null;
                this.keyFocus = "";
                this.vGridObjs = null;
                this.notBorder = false;
                this.fnt = null;
                this.gridHeight = 0;
                this.vSelectedKeys = null;
                this.zoom = 0;
                this.scaleX = 0;
                this.scaleY = 0;
                this.bitmap = null;
                this.bitmapGraphic = null;
                this.textEvalGraphic = Graphic.createGraphic("textEvalGraphic");
                try {
                    this.scaleX = 1;
                    this.scaleY = 1;
                    this.vGridObjs = [[]];
                    this.fnt = [];
                    this.vSelectedKeys = [];
                    this.zoom = 100;
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            setGridHeight(value) {
                this.gridHeight = value;
            }
            getPaintSections() {
                return this.paintSections;
            }
            getPaintObjects() {
                return this.paintObjects;
            }
            getNotBorder() {
                return this.notBorder;
            }
            setNotBorder(value) {
                this.notBorder = value;
            }
            getZoom() {
                return this.zoom;
            }
            setZoom(value) {
                this.zoom = value;
            }
            setScaleY(value) {
                this.scaleY = value;
            }
            setScaleX(value) {
                this.scaleX = value;
            }
            getScaleY() {
                return this.scaleY;
            }
            getScaleX() {
                return this.scaleX;
            }
            getPaintObject(sKey) {
                if (sKey.substring(0, cReportPaint.KEY_PAINT_OBJ.length) === cReportPaint.KEY_PAINT_OBJ) {
                    return this.paintObjects.item(sKey);
                }
                else {
                    return this.paintSections.item(sKey);
                }
            }
            getPaintObjectForTag(tag) {
                for (let i = 0; i < this.paintObjects.count(); i++) {
                    let paintObj = this.paintObjects.item(i);
                    if (paintObj.getTag() === tag) {
                        return paintObj;
                    }
                }
                return null;
            }
            getPaintSectionForTag(tag) {
                for (let i = 0; i < this.paintSections.count(); i++) {
                    let paintObj = this.paintSections.item(i);
                    if (paintObj.getTag() === tag) {
                        return paintObj;
                    }
                }
                return null;
            }
            getNewObject(paintTypeObject) {
                const key = this.getKeyPaintObj();
                const paintObj = this.paintObjects.add(null, key);
                paintObj.setKey(key);
                paintObj.setPaintType(paintTypeObject);
                return paintObj;
            }
            getNewSection(paintTypeObject) {
                const key = this.getKeyPaintSec();
                const paintObj = this.paintSections.add(null, key);
                paintObj.setKey(key);
                paintObj.setPaintType(paintTypeObject);
                return paintObj;
            }
            paintObjIsSection(sKey) {
                return sKey.substring(0, cReportPaint.KEY_PAINT_SEC.length) === cReportPaint.KEY_PAINT_SEC;
            }
            pointIsInObject(x, y, sKey, regionType = new RefWrapper(CSReportPaint.csRptPaintRegionType.BODY)) {
                if (this.pointIsInObjectAux(this.paintSections, x, y, sKey, regionType)) {
                    return true;
                }
                else if (this.pointIsInObjectAux(this.paintObjects, x, y, sKey, regionType)) {
                    return true;
                }
                return false;
            }
            pointIsInThisObject(x, y, sKey, regionType) {
                if (this.pointIsInThisObjectAux(this.paintObjects.item(sKey.get()), x, y, sKey, regionType)) {
                    return true;
                }
                return false;
            }
            pointIsInObjectAux(paintObjs, x, y, sKey, regionType) {
                for (let i = paintObjs.count() - 1; i > -1; i--) {
                    if (this.pointIsInThisObjectAux(paintObjs.getNextPaintObjForZOrder(i), x, y, sKey, regionType)) {
                        return true;
                    }
                }
                return false;
            }
            pointIsInThisObjectAux(paintObj, x, y, sKey, regionType) {
                const WIDTH_REGION = 3;
                let yY = 0;
                let xX = 0;
                let top = 0;
                let height = 0;
                let width = 0;
                let left = 0;
                if (paintObj === null) {
                    return false;
                }
                else {
                    let w_aspect = paintObj.getAspect();
                    left = w_aspect.getLeft();
                    width = w_aspect.getWidth();
                    top = w_aspect.getTop() - w_aspect.getOffset();
                    height = w_aspect.getHeight();
                    left *= this.scaleX;
                    width *= this.scaleX;
                    top *= this.scaleY;
                    height *= this.scaleY;
                    if (CSReportPaint.cReportPaint.pointIsInRegion(left - WIDTH_REGION, top - WIDTH_REGION, left + width + WIDTH_REGION, top + height + WIDTH_REGION, x, y)) {
                        sKey.set(paintObj.getKey());
                        yY = top + height / 2;
                        yY = yY - WIDTH_REGION;
                        xX = left + width / 2;
                        xX = xX - WIDTH_REGION;
                        if (CSReportPaint.cReportPaint.pointIsInRegion(left + WIDTH_REGION, top + WIDTH_REGION, left + width - WIDTH_REGION, top + height - WIDTH_REGION, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.BODY);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(left - WIDTH_REGION * 2, yY, left + WIDTH_REGION * 2, yY + WIDTH_REGION * 2, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.LEFT);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(left + width - WIDTH_REGION * 2, yY, left + width + WIDTH_REGION * 2, yY + WIDTH_REGION * 2, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.RIGHT);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(xX, top - WIDTH_REGION * 2, xX + WIDTH_REGION * 2, top + WIDTH_REGION * 2, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.UP);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(xX, top + height - WIDTH_REGION * 2, xX + WIDTH_REGION * 2, top + height + WIDTH_REGION * 2, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.DOWN);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(left - WIDTH_REGION, top - WIDTH_REGION, left + WIDTH_REGION, top + WIDTH_REGION, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.LEFT_UP);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(left - WIDTH_REGION, top + height - WIDTH_REGION, left + WIDTH_REGION, top + height + WIDTH_REGION, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.LEFT_DOWN);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(left + width - WIDTH_REGION, top - WIDTH_REGION, left + width + WIDTH_REGION, top + WIDTH_REGION, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.RIGHT_UP);
                        }
                        else if (CSReportPaint.cReportPaint.pointIsInRegion(left + width - WIDTH_REGION, top + height - WIDTH_REGION, left + width + WIDTH_REGION, top + height + WIDTH_REGION, x, y)) {
                            regionType.set(CSReportPaint.csRptPaintRegionType.RIGHT_DOWN);
                        }
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            getKeyPaintObj() {
                this.nextKey = this.nextKey + 1;
                return cReportPaint.KEY_PAINT_OBJ + this.nextKey;
            }
            getKeyPaintSec() {
                this.nextKey = this.nextKey + 1;
                return cReportPaint.KEY_PAINT_SEC + this.nextKey;
            }
            getKey() {
                this.nextKey = this.nextKey + 1;
                return "K" + this.nextKey;
            }
            static pointIsInRegion(x1, y1, x2, y2, x, y) {
                return x >= x1 && x <= x2 && y >= y1 && y <= y2;
            }
            static regionIsInRegion3D(x1, y1, x2, y2, z1, w1, z2, w2) {
                if (x1 <= z1 && x2 >= z1 && w1 <= y1 && w2 >= y1) {
                    return true;
                }
                else if (x1 <= z2 && x2 >= z2 && w1 <= y1 && w2 >= y1) {
                    return true;
                }
                else if (x1 <= z1 && x2 >= z1 && w1 <= y2 && w2 >= y2) {
                    return true;
                }
                else if (x1 <= z2 && x2 >= z2 && w1 <= y2 && w2 >= y2) {
                    return true;
                }
                else if (z1 <= x1 && z2 >= x1 && y1 <= w1 && y2 >= w1) {
                    return true;
                }
                else if (z1 <= x2 && z2 >= x2 && y1 <= w1 && y2 >= w1) {
                    return true;
                }
                else if (z1 <= x1 && z2 >= x1 && y1 <= w2 && y2 >= w2) {
                    return true;
                }
                else if (z1 <= x2 && z2 >= x2 && y1 <= w2 && y2 >= w2) {
                    return true;
                }
                return false;
            }
            initGrid(graphicGrid, typeGrid) {
                let top = 0;
                let left = 0;
                this.createBrushGrid(typeGrid);
                let y = ((graphicGrid.getBoundingClientRect().height * this.scaleY) / cReportPaint.GRID_AREA_HEIGHT);
                let x = ((graphicGrid.getBoundingClientRect().width * this.scaleX) / cReportPaint.GRID_AREA_WIDTH);
                x = x + 1;
                y = y + 1;
                this.vGridObjs = [];
                let l = 0;
                let t = 0;
                for (let i = 0; i < y * x; i++) {
                    const c = this.paintGridAreas.add(null, this.getKey());
                    left = cReportPaint.GRID_AREA_WIDTH * l;
                    top = cReportPaint.GRID_AREA_HEIGHT * t;
                    const aspect = c.getAspect();
                    aspect.setLeft(left);
                    aspect.setTop(top);
                    aspect.setWidth(cReportPaint.GRID_AREA_WIDTH);
                    aspect.setHeight(cReportPaint.GRID_AREA_HEIGHT);
                    if (this.vGridObjs.length < l + 1)
                        this.vGridObjs.push([]);
                    this.vGridObjs[l][t] = c.getKey();
                    l = l + 1;
                    if (l >= x) {
                        l = 0;
                        t = t + 1;
                    }
                }
                return this.refreshBackgroundPicture(graphicGrid, Color.White.toArgb());
            }
            alignObjTopToGrid(sKey) {
                this.alignObjToGrid(sKey, false, true, false, false, true);
            }
            alignObjLeftToGrid(sKey) {
                this.alignObjToGrid(sKey, true, false, false, false, true);
            }
            alignObjBottomToGrid(sKey) {
                this.alignObjToGrid(sKey, false, false, true, false, true);
            }
            alignObjRightToGrid(sKey) {
                this.alignObjToGrid(sKey, false, false, false, true, true);
            }
            alignObjLeftTopToGrid(sKey) {
                this.alignObjToGrid(sKey, true, true, false, false, true);
            }
            alignObjLeftBottomToGrid(sKey) {
                this.alignObjToGrid(sKey, true, false, true, false, true);
            }
            alignObjRightTopToGrid(sKey) {
                this.alignObjToGrid(sKey, false, true, false, true, true);
            }
            alignObjRightBottomToGrid(sKey) {
                this.alignObjToGrid(sKey, false, false, true, true, true);
            }
            alignToGrid(sKey) {
                this.alignObjToGrid(sKey, true, true, false, false, false);
            }
            alignObjToGrid(sKey, toLeft, toTop, toBottom, toRight, resizing) {
                let z1 = 0;
                let q1 = 0;
                let gridObjAspect = null;
                let maxX = this.vGridObjs.length - 1;
                let maxY = this.vGridObjs[0].length - 1;
                let top = 0;
                let left = 0;
                let width = 0;
                let height = 0;
                let offset = 0;
                const pointSeparation = 0.6;
                const offSetPointSep = 0.3;
                let paintObjs;
                if (sKey.substring(0, 1) === cReportPaint.KEY_PAINT_SEC) {
                    paintObjs = this.paintSections;
                }
                else {
                    paintObjs = this.paintObjects;
                }
                let item = paintObjs.item(sKey);
                let aspect = item.getAspect();
                let nLeft = aspect.getLeft() - offSetPointSep;
                let nTop = aspect.getTop() - aspect.getOffset() - offSetPointSep;
                if (nLeft < 0) {
                    nLeft = 0;
                }
                if (nTop < 0) {
                    nTop = 0;
                }
                if (toTop || toLeft) {
                    z1 = Math.trunc(nLeft / cReportPaint.GRID_AREA_WIDTH);
                    q1 = Math.trunc(nTop / cReportPaint.GRID_AREA_HEIGHT);
                    if (nLeft > z1 * cReportPaint.GRID_AREA_WIDTH) {
                        z1 = z1 + 1;
                    }
                    if (nTop > q1 * cReportPaint.GRID_AREA_HEIGHT) {
                        q1 = q1 + 1;
                    }
                    if (z1 < 0) {
                        z1 = 0;
                    }
                    if (q1 < 0) {
                        q1 = 0;
                    }
                    if (z1 > maxX) {
                        z1 = maxX;
                    }
                    if (q1 > maxY) {
                        q1 = maxY;
                    }
                    gridObjAspect = this.paintGridAreas.item(this.vGridObjs[z1][q1]).getAspect();
                    if (toTop) {
                        top = (aspect.getTop() - aspect.getOffset()) - gridObjAspect.getTop();
                        top = Math.trunc(top / pointSeparation) * pointSeparation;
                        offset = gridObjAspect.getTop()
                            + top
                            - offSetPointSep
                            - (aspect.getTop() - aspect.getOffset());
                        aspect.setTop((gridObjAspect.getTop() + top - offSetPointSep) + aspect.getOffset());
                        if (resizing) {
                            aspect.setHeight(aspect.getHeight() - offset);
                        }
                    }
                    if (toLeft) {
                        left = aspect.getLeft() - gridObjAspect.getLeft();
                        left = Math.trunc(left / pointSeparation) * pointSeparation;
                        offset = gridObjAspect.getLeft() + left - offSetPointSep - aspect.getLeft();
                        aspect.setLeft(gridObjAspect.getLeft() + left - offSetPointSep);
                        if (resizing) {
                            aspect.setWidth(aspect.getWidth() - offset);
                        }
                    }
                }
                if (toRight) {
                    z1 = Math.trunc((nLeft + aspect.getWidth()) / cReportPaint.GRID_AREA_WIDTH);
                    if (nLeft + aspect.getWidth() > z1 * cReportPaint.GRID_AREA_WIDTH) {
                        z1 = z1 + 1;
                    }
                    q1 = Math.trunc(nTop / cReportPaint.GRID_AREA_HEIGHT);
                    if (nTop > q1 * cReportPaint.GRID_AREA_HEIGHT) {
                        q1 = q1 + 1;
                    }
                    if (z1 < 1) {
                        z1 = 0;
                    }
                    if (q1 < 1) {
                        q1 = 0;
                    }
                    if (z1 > maxX) {
                        z1 = maxX;
                    }
                    if (q1 > maxY) {
                        q1 = maxY;
                    }
                    gridObjAspect = this.paintGridAreas.item(this.vGridObjs[z1][q1]).getAspect();
                    width = aspect.getLeft() + aspect.getWidth() - gridObjAspect.getLeft();
                    width = Math.trunc(width / pointSeparation) * pointSeparation - offSetPointSep;
                    aspect.setWidth(gridObjAspect.getLeft() + width - aspect.getLeft());
                }
                if (toBottom) {
                    z1 = Math.trunc(nLeft / cReportPaint.GRID_AREA_WIDTH);
                    q1 = Math.trunc((nTop + aspect.getHeight()) / cReportPaint.GRID_AREA_HEIGHT);
                    if (nLeft > z1 * cReportPaint.GRID_AREA_WIDTH) {
                        z1 = z1 + 1;
                    }
                    if (nTop + aspect.getHeight() > q1 * cReportPaint.GRID_AREA_HEIGHT) {
                        q1 = q1 + 1;
                    }
                    if (z1 < 1) {
                        z1 = 0;
                    }
                    if (q1 < 1) {
                        q1 = 0;
                    }
                    if (z1 > maxX) {
                        z1 = maxX;
                    }
                    if (q1 > maxY) {
                        q1 = maxY;
                    }
                    gridObjAspect = this.paintGridAreas.item(this.vGridObjs[z1][q1]).getAspect();
                    height = (aspect.getTop() - aspect.getOffset()) + aspect.getHeight() - gridObjAspect.getTop();
                    height = Math.trunc(height / pointSeparation) * pointSeparation - offSetPointSep;
                    aspect.setHeight(gridObjAspect.getTop() + height - (aspect.getTop() - aspect.getOffset()));
                }
            }
            reDrawPage(graphic) {
                return this.refreshBackgroundPicture(graphic, Color.White.toArgb());
            }
            refreshObject(key, graphic) {
                this.pClearObject(key, graphic);
                return this.drawObject(key, graphic);
            }
            drawObject(key, graphic) {
                return this.draw(this.paintObjects, key, graphic);
            }
            drawSection(key, graphic) {
                let aspect = this.paintSections.item(key).getAspect();
                if (aspect.getWidth() > this.bitmap.getSize().width - 2) {
                    aspect.setWidth(this.bitmap.getSize().width - 2);
                }
                return this.draw(this.paintSections, key, graphic);
            }
            clearRule(graphic) {
                graphic.getContext().clearRect(0, 0, graphic.getContext().canvas.width, graphic.getContext().canvas.height);
            }
            drawRule(key, graphic, ruleWidth) {
                const LINE_COLOR = "#cc6600";
                const aspect = new cReportAspect();
                let secPO = this.paintSections.item(key);
                let heightSec = secPO.getHeightSecLine() * 0.5;
                let secAspect = secPO.getAspect();
                aspect.setTop(secAspect.getTop() + 3 - heightSec);
                aspect.setOffset(secAspect.getOffset());
                aspect.setTransparent(true);
                aspect.setLeft(0);
                aspect.setHeight(20);
                aspect.setAlign(HorizontalAlignment.Right);
                aspect.setWidth(ruleWidth - 1);
                aspect.getFont().setForeColor("#736e6e");
                let top;
                if (secPO.getTextLine() !== "") {
                    top = -Math.trunc(secPO.getHeightSec());
                    secAspect = secPO.getAspect();
                    top += Math.trunc(secAspect.getTop() - secAspect.getOffset() - 6 + secAspect.getHeight() * 2);
                    this.printRectangle(graphic, true, 0, top, aspect.getWidth(), top, LINE_COLOR, cReportPaint.LINE_WIDTH, true, LINE_COLOR, false);
                    this.printText(graphic, secPO.getTextLine(), aspect, secPO.getImage());
                    heightSec = secPO.getHeightSec() * 0.5;
                    secAspect = this.paintSections.item(key).getAspect();
                    aspect.setTop(secAspect.getTop() - heightSec);
                    aspect.setAlign(HorizontalAlignment.Left);
                    this.printText(graphic, secPO.getText(), aspect, secPO.getImage());
                }
                else {
                    top = Math.trunc(aspect.getTop() - aspect.getOffset() - heightSec + secPO.getAspect().getHeight());
                    if (secPO.getIsSection()) {
                        this.printRectangle(graphic, true, 0, top, aspect.getWidth(), top, LINE_COLOR, cReportPaint.LINE_WIDTH, true, LINE_COLOR, false);
                    }
                    this.printText(graphic, secPO.getText(), aspect, secPO.getImage());
                }
                if (secPO === this.paintSections.item(this.paintSections.count() - 1)) {
                    top = Math.trunc(aspect.getTop() + secPO.getHeightSecLine() - heightSec - aspect.getOffset() + 6);
                    if (secPO.getIsSection()) {
                        this.printRectangle(graphic, true, 0, top, aspect.getWidth(), top, LINE_COLOR, cReportPaint.LINE_WIDTH, true, LINE_COLOR, false);
                    }
                }
                return true;
            }
            moveObjToXY(sKey, x, y, graphic) {
                if (sKey.substring(0, 1) === cReportPaint.KEY_PAINT_OBJ) {
                    let aspect = this.paintObjects.item(sKey).getAspect();
                    this.move(x, y, aspect.getWidth(), aspect.getHeight(), graphic);
                }
                else {
                    let aspect = this.paintSections.item(sKey).getAspect();
                    this.move(x, y, aspect.getWidth(), aspect.getHeight(), graphic);
                }
            }
            moveObjToXYEx(sKey, x, y, graphic, clear) {
                if (clear) {
                    this.x1 = this.x1Ex;
                    this.y1 = this.y1Ex;
                    this.x2 = this.x2Ex;
                    this.y2 = this.y2Ex;
                }
                else {
                    this.x1 = 0;
                    this.x2 = 0;
                    this.y1 = 0;
                    this.y2 = 0;
                }
                this.moveObjToXY(sKey, x, y, graphic);
                if (this.x1Ex === 0) {
                    this.x1Ex = this.x1;
                }
                if (this.y1Ex === 0) {
                    this.y1Ex = this.y1;
                }
                if (this.x2Ex === 0) {
                    this.x2Ex = this.x2;
                }
                if (this.y2Ex === 0) {
                    this.y2Ex = this.y2;
                }
                if (this.x1Ex > this.x1 && this.x1 > 0) {
                    this.x1Ex = this.x1;
                }
                if (this.y1Ex > this.y1 && this.y1 > 0) {
                    this.y1Ex = this.y1;
                }
                if (this.x2Ex < this.x2 && this.x2 > 0) {
                    this.x2Ex = this.x2;
                }
                if (this.y2Ex < this.y2 && this.y2 > 0) {
                    this.y2Ex = this.y2;
                }
            }
            moveVertical(sKey, y, graphic) {
                if (sKey.substring(0, 1) === cReportPaint.KEY_PAINT_OBJ) {
                    let aspect = this.paintObjects.item(sKey).getAspect();
                    this.move(aspect.getLeft(), y, aspect.getWidth(), aspect.getHeight(), graphic);
                }
                else {
                    let aspect = this.paintSections.item(sKey).getAspect();
                    this.move(aspect.getLeft(), y, aspect.getWidth(), aspect.getHeight(), graphic);
                }
            }
            moveHorizontal(sKey, x, graphic) {
                if (sKey.substring(0, 1) === cReportPaint.KEY_PAINT_OBJ) {
                    let w_aspect = this.paintObjects.item(sKey).getAspect();
                    this.move(x, w_aspect.getTop(), w_aspect.getWidth(), w_aspect.getHeight(), graphic);
                }
                else {
                    let w_aspect = this.paintSections.item(sKey).getAspect();
                    this.move(x, w_aspect.getTop(), w_aspect.getWidth(), w_aspect.getHeight(), graphic);
                }
            }
            endMove(graphic) {
                this.x1 = 0;
                this.x2 = 0;
                this.y1 = 0;
                this.y2 = 0;
                this.x1Ex = 0;
                this.x2Ex = 0;
                this.y1Ex = 0;
                this.y2Ex = 0;
                return this.refreshBackgroundPicture(graphic, Color.White.toArgb())
                    .then(P.call(this, () => this.beginMoveDone = false));
            }
            draw(collObjs, key, graphic) {
                if (graphic === null) {
                    throw new CSReportPaint.ReportPaintException(CSReportPaint.cReportPaintError.errGetDescription(CSReportPaint.csRptPaintErrors.CSRPT_PAINT_ERR_OBJ_CLIENT));
                }
                try {
                    let x1 = 0;
                    let y1 = 0;
                    let y2 = 0;
                    let x2 = 0;
                    let colorIn;
                    let colorOut;
                    let filled = false;
                    let oPaintObj = collObjs.item(key);
                    if (oPaintObj === null) {
                        return false;
                    }
                    let aspect = oPaintObj.getAspect();
                    x1 = aspect.getLeft();
                    x2 = x1 + aspect.getWidth();
                    y1 = aspect.getTop() - aspect.getOffset();
                    y2 = y1 + aspect.getHeight();
                    if (!aspect.getTransparent()) {
                        colorIn = aspect.getBackColor();
                        filled = true;
                    }
                    colorOut = aspect.getBorderColor();
                    switch (oPaintObj.getPaintType()) {
                        case CSReportPaint.csRptPaintObjType.PAINT_OBJ_BOX:
                            this.drawObjBox(graphic, oPaintObj.getAspect(), x1, y1, x2, y2, filled, colorIn, colorOut);
                            break;
                        case CSReportPaint.csRptPaintObjType.PAINT_OBJ_LINE:
                            this.printRectangle(graphic, filled, x1, y1, x2, y2, colorIn, cReportPaint.LINE_WIDTH, false, colorOut, false);
                            break;
                        case CSReportPaint.csRptPaintObjType.PAINT_OBJ_CIRCLE:
                            break;
                        case CSReportPaint.csRptPaintObjType.PAINT_OBJ_IMAGE:
                            this.drawObjBox(graphic, oPaintObj.getAspect(), x1 - 1, y1 - 1, x2 + 1, y2 + 1, filled, colorIn, "#C0C000");
                            let bmpWidth = 0;
                            let bmpHeight = 0;
                            if (oPaintObj.getImage() !== null) {
                                ({ bmpWidth, bmpHeight } = oPaintObj.getImage().getBitmapSize(true));
                                if (bmpWidth > aspect.getWidth()) {
                                    bmpWidth = aspect.getWidth();
                                }
                                if (bmpHeight > aspect.getHeight()) {
                                    bmpHeight = aspect.getHeight();
                                }
                                this.drawBMP(graphic, oPaintObj.getImage(), x1 * this.scaleX, y1 * this.scaleY, bmpWidth * this.scaleX, bmpHeight * this.scaleY);
                            }
                            break;
                    }
                    if (oPaintObj.getText() !== "") {
                        if (collObjs === this.paintObjects) {
                            this.printText(graphic, oPaintObj.getText(), oPaintObj.getAspect(), oPaintObj.getImage());
                        }
                    }
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            drawBMP(graphic, image, x, y, bmpWidth, bmpHeight) {
                graphic.drawImage2(image.imageBitmap, x, y, bmpWidth, bmpHeight);
            }
            setFocus(sKey, graphic, clearSelected) {
                if (clearSelected) {
                    this.vSelectedKeys = [];
                }
                if (!this.pAllreadySelected(sKey)) {
                    this.vSelectedKeys.push(sKey);
                }
                this.keyFocus = sKey;
                this.paintPicture(graphic, true);
            }
            removeFromSelected(sKey, graphic) {
                let i = 0;
                for (i = 0; i < this.vSelectedKeys.length; i++) {
                    if (this.vSelectedKeys[i] === sKey) {
                        break;
                    }
                }
                if (i >= this.vSelectedKeys.length) {
                    return;
                }
                for (i = i + 1; i < this.vSelectedKeys.length; i++) {
                    this.vSelectedKeys[i - 1] = this.vSelectedKeys[i];
                }
                if (this.vSelectedKeys.length > 0) {
                    this.vSelectedKeys.pop();
                }
                else {
                    this.vSelectedKeys = [];
                }
                if (this.keyFocus === sKey) {
                    this.keyFocus = "";
                }
                this.paintPicture(graphic, true);
            }
            pAllreadySelected(sKey) {
                if (sKey === "") {
                    return true;
                }
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    if (this.vSelectedKeys[i] === sKey) {
                        return true;
                    }
                }
                return false;
            }
            setFocusAux(sKey, graphic) {
                let paintObjAsp;
                let color;
                let bCircle;
                this.keyFocus = sKey;
                if (this.keyFocus.substring(0, 1) === cReportPaint.KEY_PAINT_OBJ) {
                    paintObjAsp = this.paintObjects.item(this.keyFocus);
                    color = 0x80C0FF;
                    bCircle = false;
                }
                else {
                    paintObjAsp = this.paintSections.item(this.keyFocus);
                    color = 0x80C0FF;
                    bCircle = true;
                }
                if (paintObjAsp === null) {
                    return;
                }
                let aspect = paintObjAsp.getAspect();
                this.showHandles(graphic, Math.trunc(aspect.getLeft() * this.scaleX), Math.trunc((aspect.getTop() - aspect.getOffset()) * this.scaleY), Math.trunc((aspect.getLeft() + aspect.getWidth()) * this.scaleX), Math.trunc((aspect.getTop() - aspect.getOffset() + aspect.getHeight()) * this.scaleY), color, bCircle);
            }
            move(left, top, width, height, graphic) {
                let p = P._();
                if (this.x1 > 0 || this.x2 > 0 || this.y1 > 0 || this.y2 > 0) {
                    p = this.paintPictureMove(graphic, CSReportPaint.cGlobals.newRectangleF(this.x1, this.y1, this.x2, this.y2));
                }
                this.x1 = left;
                this.y1 = top;
                this.x2 = left + width;
                this.y2 = top + height;
                p.then(P.call(this, () => {
                    this.printRectangle(graphic, false, this.x1, this.y1, this.x2, this.y2, csColors.WHITE, cReportPaint.LINE_WIDTH_FAT, true, csColors.BLACK, false);
                    if (this.x1 > 1) {
                        this.x1 = this.x1 - 2;
                    }
                    if (this.y1 > 1) {
                        this.y1 = this.y1 - 2;
                    }
                    this.x2 = this.x2 + 2;
                    this.y2 = this.y2 + 2;
                }));
            }
            resize(graphic, sKey, left, top, x2, y2) {
                const MIN_WIDTH = 1;
                const MIN_HEIGHT = 1;
                let paintObjAsp;
                if (sKey.substring(0, 1) === cReportPaint.KEY_PAINT_OBJ) {
                    paintObjAsp = this.paintObjects.item(sKey).getAspect();
                }
                else {
                    paintObjAsp = this.paintSections.item(sKey).getAspect();
                }
                if (left === CSReportPaint.cGlobals.NO_CHANGE) {
                    this.x1 = paintObjAsp.getLeft();
                }
                else {
                    this.x1 = left;
                }
                if (top === CSReportPaint.cGlobals.NO_CHANGE) {
                    this.y1 = paintObjAsp.getTop() - paintObjAsp.getOffset();
                }
                else {
                    this.y1 = top;
                }
                this.x2 = paintObjAsp.getLeft();
                if (x2 === CSReportPaint.cGlobals.NO_CHANGE) {
                    this.x2 = this.x2 + paintObjAsp.getWidth();
                }
                else {
                    this.x2 = x2;
                }
                this.y2 = paintObjAsp.getTop() - paintObjAsp.getOffset();
                if (y2 === CSReportPaint.cGlobals.NO_CHANGE) {
                    this.y2 = this.y2 + paintObjAsp.getHeight();
                }
                else {
                    this.y2 = y2;
                }
                if (this.x2 < paintObjAsp.getLeft() + MIN_WIDTH) {
                    this.x2 = paintObjAsp.getLeft() + MIN_WIDTH;
                }
                if (this.y2 < paintObjAsp.getTop() - paintObjAsp.getOffset() + MIN_HEIGHT) {
                    this.y2 = paintObjAsp.getTop() - paintObjAsp.getOffset() + MIN_HEIGHT;
                }
                this.paintPicture(graphic, false).then(P.call(this, () => {
                    this.printRectangle(graphic, false, this.x1, this.y1, this.x2, this.y2, csColors.WHITE, cReportPaint.LINE_WIDTH_FAT, true, csColors.BLACK, false);
                    graphic.dispose();
                }));
            }
            createPicture(graphic) {
                return this.refreshBackgroundPicture(graphic, "#000000");
            }
            createBackgroundBitmap(graphic) {
                this.bitmap = new Bitmap(graphic.getBoundingClientRect().width + 1, graphic.getBoundingClientRect().height + 3, "backgroundBitmap");
            }
            refreshBackgroundPicture(graphic, rgbColor) {
                if (this.bitmap !== null) {
                    this.bitmap.dispose();
                }
                const bitmapGraphic = Graphic.createGraphic("backgroundGraphic", graphic.getContext().canvas.width, graphic.getContext().canvas.height);
                const rect = CSReportPaint.cGlobals
                    .newRectangle(0, 0, bitmapGraphic.getWidth(), bitmapGraphic.getHeight() + 3);
                let pen;
                if (this.brushGrid !== null) {
                    pen = new Pen(this.brushGrid.foreground.toArgb(), 0.2);
                }
                else {
                    pen = new Pen(rgbColor, 0.2);
                }
                const gridSize = 15;
                const w = Math.floor(rect.getWidth() / gridSize);
                const h = Math.floor(rect.getHeight() / gridSize);
                for (let x = 0; x < w; x++) {
                    for (let y = 0; y < h; y++) {
                        bitmapGraphic.drawRectangle4(pen, x * gridSize, y * gridSize, gridSize, gridSize);
                    }
                }
                const p = new Promise((resolve) => { setTimeout(resolve, 50); });
                return p.then(P.call(this, () => {
                    for (let i = 0; i < this.getPaintObjects().count(); i++) {
                        this.drawObject(this.getPaintObjects().getNextKeyForZOrder(i), bitmapGraphic);
                    }
                    for (let i = 0; i < this.getPaintSections().count(); i++) {
                        this.drawSection(this.getPaintSections().getNextKeyForZOrder(i), bitmapGraphic);
                    }
                    this.bitmap = Bitmap.fromContext2d(bitmapGraphic.getContext(), bitmapGraphic.name);
                    this.bitmapGraphic = bitmapGraphic;
                    return this.bitmap.whenLoaded()
                        .then(P.call(this, () => {
                        return this.paintPicture(graphic, true);
                    }));
                }));
            }
            printRectangle(graphic, filled, x1, y1, x2, y2, colorInside, width, dash, colorOut, rounded) {
                let pen = new Pen(colorOut, width);
                if (dash) {
                    pen.dashStyle = DashStyle.Dot;
                }
                y1 = y1 * this.scaleY;
                y2 = y2 * this.scaleY;
                x1 = x1 * this.scaleX;
                x2 = x2 * this.scaleX;
                if (rounded) {
                    let extGraph = new cGraphics(graphic);
                    extGraph.drawRoundRectangle(pen, x1, y1, x2 - x1, y2 - y1, 8);
                }
                else {
                    let rect = CSReportPaint.cGlobals.newRectangle(Math.trunc(x1), Math.trunc(y1), Math.trunc(x2), Math.trunc(y2));
                    if (y2 !== y1 && x1 !== x2) {
                        if (filled) {
                            let brush = new SolidBrush(colorInside);
                            graphic.fillRectangle(brush, rect);
                            brush.dispose();
                        }
                        if (!(rect.getHeight() === 1 && filled)) {
                            graphic.drawRectangle(pen, rect);
                        }
                    }
                    else {
                        if (rect.getHeight() === 0 || rect.getBottom() === rect.getTop()) {
                            rect.setHeight(0.1);
                        }
                        if (rect.getWidth() === 0 || rect.getLeft() === rect.getRight()) {
                            rect.setWidth(0.1);
                        }
                        graphic.drawRectangle(pen, rect);
                    }
                }
                pen.dispose();
            }
            printText(graphic, text, aspect, image) {
                const c_Margen_Y = 1;
                const c_Margen_X = 4;
                const c_Margen_Bottom = 4;
                let idx = CSReportPaint.cGlobals.addFontIfRequired(aspect.getFont(), this.fnt);
                let font = this.fnt[idx];
                let format = new StringFormat();
                format.trimming = StringTrimming.EllipsisWord;
                format.alignment = StringAlignment.Near;
                if (!aspect.getWordWrap()) {
                    format.formatFlags = StringFormatFlags.NoWrap;
                }
                let stringWidth = this.evaluateTextWidth(text, font, this.scaleX);
                let stringHeight = this.evaluateTextHeight(text, font, aspect.getWidth(), format, this.scaleY, this.scaleX);
                stringHeight += 25;
                let marginX = c_Margen_X;
                let marginY = c_Margen_Y;
                if (image !== null) {
                    marginX += image.getSize().width;
                    marginY = image.getSize().height - stringHeight - c_Margen_Bottom;
                    if (marginY + stringHeight > aspect.getHeight()) {
                        marginY = Math.trunc(aspect.getHeight() - stringHeight - c_Margen_Bottom);
                    }
                    if (marginY < c_Margen_Y) {
                        marginY = c_Margen_Y;
                    }
                }
                let nWidth = Math.trunc((aspect.getWidth() - marginX * 2) * this.scaleX);
                if (stringWidth > nWidth) {
                    stringWidth = nWidth;
                }
                let x = 0;
                let y = 0;
                switch (aspect.getAlign()) {
                    case HorizontalAlignment.Right:
                        x = Math.trunc(aspect.getLeft() * this.scaleX + aspect.getWidth() * this.scaleX - stringWidth - marginX);
                        break;
                    case HorizontalAlignment.Center:
                        x = Math.trunc(aspect.getLeft() * this.scaleX + (aspect.getWidth() * this.scaleX - stringWidth) * 0.5);
                        break;
                    case HorizontalAlignment.Left:
                        x = Math.trunc(aspect.getLeft() + marginX) * this.scaleX;
                        break;
                }
                y = Math.trunc(aspect.getTop() - aspect.getOffset() + marginY);
                let rect = CSReportPaint.cGlobals.newRectangleF(x, y * this.scaleY, Math.trunc((x + aspect.getWidth() - marginX)) * this.scaleX, (y * this.scaleY) + stringHeight - 25);
                let brush = new SolidBrush(aspect.getFont().getForeColor());
                let scaledFont = font.resize(font.size * this.scaleX);
                graphic.drawString(text, scaledFont, brush, rect, format);
                brush.dispose();
            }
            showHandles(graphic, x1, y1, x2, y2, color, bCircle) {
                const iSize = 7;
                if (x1 - iSize < 0) {
                    x1 = iSize;
                }
                if (y1 - iSize < 0) {
                    y1 = iSize;
                }
                if (x1 - iSize < 0) {
                    x1 = iSize;
                }
                if (y1 - iSize < 0) {
                    y1 = iSize;
                }
                let brush = new SolidBrush(color);
                let rect = CSReportPaint.cGlobals.newRectangle(x1 - iSize, y1 - iSize - 1, x1, y1);
                this.showHandle(graphic, brush, rect, bCircle);
                rect = CSReportPaint.cGlobals.newRectangle(x1 - iSize, y2, x1, y2 + iSize);
                this.showHandle(graphic, brush, rect, bCircle);
                rect = CSReportPaint.cGlobals.newRectangle(x2, y1 - iSize - 1, x2 + iSize, y1);
                this.showHandle(graphic, brush, rect, bCircle);
                rect = CSReportPaint.cGlobals.newRectangle(x2, y2, x2 + iSize, y2 + iSize);
                this.showHandle(graphic, brush, rect, bCircle);
                let x = Math.trunc((x1 + (x2 - x1) / 2) - iSize / 2);
                rect = CSReportPaint.cGlobals.newRectangle(x, y2, x + iSize, y2 + iSize);
                this.showHandle(graphic, brush, rect, bCircle);
                rect = CSReportPaint.cGlobals.newRectangle(x, y1 - iSize - 1, x + iSize, y1);
                this.showHandle(graphic, brush, rect, bCircle);
                let y = Math.trunc((y1 + (y2 - y1) / 2) - iSize / 2);
                rect = CSReportPaint.cGlobals.newRectangle(x1 - iSize, y, x1, y + iSize);
                this.showHandle(graphic, brush, rect, bCircle);
                rect = CSReportPaint.cGlobals.newRectangle(x2, y, x2 + iSize, y + iSize);
                this.showHandle(graphic, brush, rect, bCircle);
                brush.dispose();
            }
            showHandle(graphic, brush, rect, circle) {
                if (circle) {
                    graphic.fillEllipse(brush, rect);
                }
                else {
                    graphic.fillRectangle(brush, rect);
                }
            }
            paintPicture(graphic, disposeGraphicObject) {
                return this.bitmap.getBitmap().then(P.call(this, (bitmap) => {
                    if (this.zoom === 100) {
                        let rect = CSReportPaint.cGlobals.newRectangle(0, 0, this.bitmap.getSize().width, this.bitmap.getSize().height);
                        graphic.drawImage(bitmap, rect.getLeft(), rect.getTop());
                    }
                    for (let i = 0; i < this.vSelectedKeys.length; i++) {
                        this.setFocusAux(this.vSelectedKeys[i], graphic);
                    }
                    if (disposeGraphicObject) {
                        graphic.dispose();
                    }
                }));
            }
            beginMove() {
                if (this.beginMoveDone) {
                    return;
                }
                this.beginMoveDone = true;
                Graphic.fromImage(this.bitmap).then(P.call(this, (graphic) => {
                    for (let i = 0; i < this.vSelectedKeys.length; i++) {
                        this.setFocusAux(this.vSelectedKeys[i], graphic);
                    }
                    graphic.dispose();
                }));
            }
            paintPictureMove(graphic, tR) {
                if (this.zoom === 100) {
                    const bitmap = Bitmap.fromContext2d(this.bitmapGraphic.getContext(), this.bitmapGraphic.name);
                    return bitmap.getBitmap()
                        .then(P.call(this, (bitmap) => {
                        if (this.zoom === 100) {
                            let rect = CSReportPaint.cGlobals.newRectangle(0, 0, this.bitmap.getSize().width, this.bitmap.getSize().height);
                            graphic.drawImage(bitmap, rect.getLeft(), rect.getTop());
                        }
                        for (let i = 0; i < this.vSelectedKeys.length; i++) {
                            this.setFocusAux(this.vSelectedKeys[i], graphic);
                        }
                    }));
                }
                return P._();
            }
            createBrushGrid(typeGrid) {
                switch (typeGrid) {
                    case CSReportPaint.csETypeGrid.CSEGRIDLINES:
                        this.brushGrid = new HatchBrush(HatchStyle.Cross, Color.colorFromRGB("C0C0C0"), Color.White);
                        break;
                    case CSReportPaint.csETypeGrid.CSEGRIDPOINTS:
                        this.brushGrid = new HatchBrush(HatchStyle.DottedGrid, Color.colorFromRGB("C0C0C0"), Color.White);
                        break;
                    case CSReportPaint.csETypeGrid.CSEGRIDLINESHORIZONTAL:
                        this.brushGrid = new HatchBrush(HatchStyle.Horizontal, Color.colorFromRGB("C0C0C0"), Color.White);
                        break;
                    case CSReportPaint.csETypeGrid.CSEGRIDLINESVERTICAL:
                        this.brushGrid = new HatchBrush(HatchStyle.Vertical, Color.colorFromRGB("C0C0C0"), Color.White);
                        break;
                    case CSReportPaint.csETypeGrid.CSEGRIDNONE:
                        this.brushGrid = new HatchBrush(HatchStyle.DottedGrid, Color.colorFromRGB("CCCCCC"), Color.White);
                        break;
                }
            }
            evaluateTextWidth(text, font, scaleX) {
                let stringSize = this.textEvalGraphic.measureString(text, font);
                return Math.trunc(stringSize.width * scaleX);
            }
            evaluateTextHeight(text, font, width, format, scaleY, scaleX) {
                let stringSize = this.textEvalGraphic.measureString(text, font, Math.trunc(width * scaleX), format);
                return Math.trunc(stringSize.height * scaleY);
            }
            pClearObject(key, graphic) {
                let oPaintObj = null;
                oPaintObj = this.paintObjects.item(key);
                if (oPaintObj === null) {
                    return;
                }
                let aspect = oPaintObj.getAspect();
                let tR = CSReportPaint.cGlobals.newRectangleF(aspect.getLeft(), aspect.getTop(), aspect.getLeft() + aspect.getWidth(), aspect.getTop() + aspect.getHeight());
                if (tR.getRight() > graphic.getBoundingClientRect().width) {
                    tR.setWidth(CSReportPaint.cGlobals.setRectangleWidth(graphic.getBoundingClientRect().width - tR.getLeft()));
                }
                if (tR.getBottom() > graphic.getBoundingClientRect().height) {
                    tR.setHeight(CSReportPaint.cGlobals.setRectangleHeight(graphic.getBoundingClientRect().height - tR.getTop()));
                }
            }
            drawObjBox(graphic, aspect, x1, y1, x2, y2, filled, colorIn, colorOut) {
                if (this.notBorder === false || filled || aspect.getBorderType() !== csReportBorderType.CS_RPT_BS_NONE) {
                    if (aspect.getBorderType() === csReportBorderType.CS_RPT_BS_3D) {
                        this.printRectangle(graphic, filled, x1, y1, x2, y2, colorIn, 0, false, csColors.WHITE, false);
                        this.printRectangle(graphic, false, x1, y1, x2, y1, csColors.WHITE, cReportPaint.LINE_WIDTH, false, aspect.getBorderColor3d(), false);
                        this.printRectangle(graphic, false, x1, y2 - 1, x2, y2 - 1, csColors.WHITE, cReportPaint.LINE_WIDTH, false, aspect.getBorderColor3dShadow(), false);
                        this.printRectangle(graphic, false, x1 + 1, y1, x1 + 1, y2, csColors.WHITE, cReportPaint.LINE_WIDTH, false, aspect.getBorderColor3d(), false);
                        this.printRectangle(graphic, false, x2 - 1, y1, x2 - 1, y2, csColors.WHITE, cReportPaint.LINE_WIDTH, false, aspect.getBorderColor3dShadow(), false);
                    }
                    else if (aspect.getBorderRounded()) {
                        this.printRectangle(graphic, filled, x1, y1, x2, y2, colorIn, aspect.getBorderWidth(), false, colorOut, true);
                    }
                    else {
                        let dash = false;
                        let borderWidth = cReportPaint.LINE_WIDTH_THIN * this.scaleX;
                        if (this.notBorder === false
                            && ((aspect.getBorderType() === csReportBorderType.CS_RPT_BS_FIXED
                                && !aspect.getBorderRounded()
                                && aspect.getBorderWidth() === 0)
                                || aspect.getBorderType() === csReportBorderType.CS_RPT_BS_NONE)) {
                            colorOut = Color.OrangeRed.toString();
                            dash = true;
                            borderWidth = cReportPaint.LINE_WIDTH_FAT * this.scaleX;
                        }
                        if (!this.notBorder
                            || (filled && colorIn !== '16777215')
                            || (aspect.getBorderType() === csReportBorderType.CS_RPT_BS_FIXED && aspect.getBorderWidth() > 0)) {
                            this.printRectangle(graphic, filled, x1, y1, x2, y2, colorIn, borderWidth, dash, colorOut, false);
                        }
                    }
                }
            }
            getBitmap() {
                return this.bitmap;
            }
        }
        cReportPaint.GRID_AREA_WIDTH = 200;
        cReportPaint.GRID_AREA_HEIGHT = 67;
        cReportPaint.KEY_PAINT_OBJ = "P";
        cReportPaint.KEY_PAINT_SEC = "S";
        cReportPaint.LINE_WIDTH = 0.2;
        cReportPaint.LINE_WIDTH_FAT = 0.7;
        cReportPaint.LINE_WIDTH_THIN = 0.1;
        CSReportPaint.cReportPaint = cReportPaint;
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportExport;
    (function (CSReportExport) {
        class cReportPdf {
            setExportEmailAddress(emailAddress) {
            }
            sendMail(files) {
                return false;
            }
            setFileName(fileName) {
            }
            exportEx(report, caller, outputFile, showPDFWindow) {
                return false;
            }
        }
        CSReportExport.cReportPdf = cReportPdf;
    })(CSReportExport = CSReports.CSReportExport || (CSReports.CSReportExport = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csRptPageOrientation = CSReports.CSReportGlobals.csRptPageOrientation;
        var csReportPaperType = CSReports.CSReportGlobals.csReportPaperType;
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        class cPrinter {
            constructor(printDialog) {
                this.deviceName = "";
                this.driverName = "";
                this.port = "";
                this.paperInfo = new CSReportEngine.cReportPaperInfo();
                this.copies = 0;
                this.graphic = null;
                this.printDialog = null;
                this.printDialog = printDialog;
            }
            getCopies() {
                return this.copies;
            }
            setCopies(rhs) {
                this.copies = rhs;
            }
            getGraph() {
                return this.graphic;
            }
            setGraph(rhs) {
                this.graphic = rhs;
            }
            getDeviceName() {
                return this.deviceName;
            }
            setDeviceName(rhs) {
                this.deviceName = rhs;
            }
            getDriverName() {
                return this.driverName;
            }
            setDriverName(rhs) {
                this.driverName = rhs;
            }
            getPort() {
                return this.port;
            }
            setPort(rhs) {
                this.port = rhs;
            }
            getPaperInfo() {
                return this.paperInfo;
            }
            setPaperInfo(rhs) {
                this.paperInfo = rhs;
            }
            showDialog(pages) {
                let paperSize = 0;
                let orientation = 0;
                let fromPage = 0;
                let toPage = 0;
                let paperBin = 0;
                paperSize = this.paperInfo.getPaperSize();
                orientation = this.paperInfo.getOrientation();
                fromPage = 1;
                toPage = pages;
                if (CSReportEngine.cPrintAPI.showPrintDialog(this.printDialog, this.deviceName, this.driverName, this.port, paperSize, orientation, fromPage, toPage, this.copies, paperBin)) {
                    this.paperInfo.setPaperSize(paperSize);
                    this.paperInfo.setOrientation(orientation);
                    this.paperInfo.setPagesToPrint(fromPage.toString() + "-" + toPage.toString());
                    this.paperInfo.setPaperBin(paperBin);
                    return true;
                }
                else {
                    return false;
                }
            }
            getPaperSize(paperSize) {
                let size = new PaperSize();
                switch (paperSize) {
                    case csReportPaperType.CS_RPT_PAPER_TYPE_A4:
                        size.RawKind = PaperKind.A4;
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_A3:
                        size.RawKind = PaperKind.A3;
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_LETTER:
                        size.RawKind = PaperKind.Letter;
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_LEGAL:
                        size.RawKind = PaperKind.Legal;
                        break;
                }
                return size;
            }
            starDoc(printDoc, title, paperSize, orientation) {
                printDoc.getDefaultPageSettings().Landscape = (orientation === csRptPageOrientation.LANDSCAPE);
                printDoc.getDefaultPageSettings().PaperSize = this.getPaperSize(paperSize);
                return true;
            }
        }
        CSReportEngine.cPrinter = cPrinter;
        class PageSettings {
        }
        CSReportEngine.PageSettings = PageSettings;
        class PDFGraphic {
            constructor(doc, height, width) {
                this.doc = doc;
                this.height = height;
                this.width = width;
            }
            getBoundingClientRect() {
                return { height: this.height, width: this.width };
            }
            fillRectangle(brush, rect) {
                this.doc.setFillColor(brush.toString());
                this.doc.setDrawColor(brush.toString());
                this.doc.rect(rect.getLeft(), rect.getTop(), rect.getWidth(), rect.getHeight(), 'F');
            }
            drawRectangle(pen, rect) {
                this.doc.setDrawColor(pen.color());
                this.doc.rect(rect.getLeft(), rect.getTop(), rect.getWidth(), rect.getHeight());
            }
            drawImage2(bitmap, x, y, width, height) {
                this.drawImage(bitmap, x, y);
            }
            drawString(text, font, brush, rect, format) {
                this.doc.setTextColor(brush.foreground.color);
                this.doc.setFont(font.name, font.italic ? 'italic' : 'normal', font.bold ? 'bold' : 'normal');
                this.doc.setFontSize(font.size);
                this.doc.text(text, rect.getLeft(), rect.getTop(), { baseline: 'top' });
            }
            fillPath(brush, path) {
            }
            drawPath(pen, path) {
            }
            fillEllipse(brush, rect) {
                throw new NotImplementedException();
            }
            drawImage(bitmap, x, y) {
                const canvas = this.imageBitmapToCanvas(bitmap);
                this.doc.addImage(canvas, 'PNG', x, y, canvas.width, canvas.height);
            }
            dispose() {
            }
            imageBitmapToCanvas(bitmap) {
                const canvas = document.createElement("canvas");
                const context = canvas.getContext("2d");
                canvas.width = bitmap.width * 0.75;
                canvas.height = bitmap.height * 0.75;
                context.mozImageSmoothingEnabled = true;
                context.webkitImageSmoothingEnabled = true;
                context.msImageSmoothingEnabled = true;
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = "high";
                context.clearRect(0, 0, bitmap.width, bitmap.height);
                context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
                return canvas;
            }
        }
        CSReportEngine.PDFGraphic = PDFGraphic;
        class PDFPageEvent {
            constructor(graphic) {
                this.graphic = graphic;
            }
        }
        CSReportEngine.PDFPageEvent = PDFPageEvent;
        class PDFDocument {
            constructor(size, orientation, unit, format, compressPdf) {
                this.defaultPageSettings = new PageSettings();
                this.printerSettings = new CSReportEngine.PrinterSettings();
                this.printPage = null;
                this.size = size;
                const jsPDFref = window.jspdf;
                this.doc = new jsPDFref.jsPDF(orientation, unit, format, compressPdf);
            }
            setPrintPage(printPage) {
                this.printPage = printPage;
            }
            getPrinterSettings() {
                return this.printerSettings;
            }
            getDefaultPageSettings() {
                return this.defaultPageSettings;
            }
            print(fileName) {
                const g = new PDFGraphic(this.doc, this.size.height, this.size.width);
                while (true) {
                    const e = new PDFPageEvent(g);
                    this.printPage(e);
                    if (!e.hasMorePages)
                        break;
                    this.doc.addPage();
                }
                this.doc.save(fileName);
            }
        }
        CSReportEngine.PDFDocument = PDFDocument;
        class PrinterGraphic {
            getBoundingClientRect() {
                throw new NotImplementedException();
            }
            fillRectangle(brush, rect) {
                throw new NotImplementedException();
            }
            drawRectangle(pen, rect) {
                throw new NotImplementedException();
            }
            drawImage2(bitmap, x, y, width, height) {
                throw new NotImplementedException();
            }
            drawString(text, font, brush, rect, format) {
                throw new NotImplementedException();
            }
            fillPath(brush, path) {
                throw new NotImplementedException();
            }
            drawPath(pen, path) {
                throw new NotImplementedException();
            }
            fillEllipse(brush, rect) {
                throw new NotImplementedException();
            }
            drawImage(bitmap, x, y) {
                throw new NotImplementedException();
            }
            dispose() {
                throw new NotImplementedException();
            }
        }
        CSReportEngine.PrinterGraphic = PrinterGraphic;
        class PrintPageEvent {
        }
        CSReportEngine.PrintPageEvent = PrintPageEvent;
        class PrintDocument {
            constructor() {
                this.defaultPageSettings = new PageSettings();
                this.printerSettings = new CSReportEngine.PrinterSettings();
                this.printPage = null;
            }
            setPrintPage(printPage) {
                this.printPage = printPage;
            }
            getPrinterSettings() {
                return this.printerSettings;
            }
            getDefaultPageSettings() {
                return this.defaultPageSettings;
            }
            print() {
                while (true) {
                    const e = new PrintPageEvent();
                    this.printPage(e);
                    if (!e.hasMorePages)
                        break;
                }
            }
        }
        CSReportEngine.PrintDocument = PrintDocument;
        class PaperSize {
        }
        CSReportEngine.PaperSize = PaperSize;
        let PaperKind;
        (function (PaperKind) {
            PaperKind[PaperKind["A4"] = 0] = "A4";
            PaperKind[PaperKind["A3"] = 1] = "A3";
            PaperKind[PaperKind["Letter"] = 2] = "Letter";
            PaperKind[PaperKind["Legal"] = 3] = "Legal";
        })(PaperKind = CSReportEngine.PaperKind || (CSReportEngine.PaperKind = {}));
        class Graphics {
        }
        CSReportEngine.Graphics = Graphics;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        var cError = CSReports.CSKernelClient.cError;
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var CMouseWait = CSReports.CSKernelClient.CMouseWait;
        var cPrintAPI = CSReports.CSReportEngine.cPrintAPI;
        var csRptGetLineResult = CSReports.CSReportGlobals.csRptGetLineResult;
        var csRptNewPageResult = CSReports.CSReportGlobals.csRptNewPageResult;
        var csRptEndPageResult = CSReports.CSReportGlobals.csRptEndPageResult;
        var RefWrapper = CSReports.CSKernelClient.RefWrapper;
        var PDFDocument = CSReports.CSReportEngine.PDFDocument;
        var PrintDocument = CSReports.CSReportEngine.PrintDocument;
        var csReportPaperType = CSReports.CSReportGlobals.csReportPaperType;
        var cReportPdf = CSReports.CSReportExport.cReportPdf;
        var csEZoom = CSReports.CSReportGlobals.csEZoom;
        var Form = CSReports.CSForms.Form;
        var StringTrimming = CSReports.CSDrawing.StringTrimming;
        var StringFormat = CSReports.CSDrawing.StringFormat;
        var StringFormatFlags = CSReports.CSDrawing.StringFormatFlags;
        var StringAlignment = CSReports.CSDrawing.StringAlignment;
        var Graphic = CSReports.CSDrawing.Graphic;
        var OffscreenGraphic = CSReports.CSDrawing.OffscreenGraphic;
        var Bitmap = CSReports.CSDrawing.Bitmap;
        var csRptPageOrientation = CSReports.CSReportGlobals.csRptPageOrientation;
        var ArgumentException = CSReports.CSOAPI.ArgumentException;
        class cReportPrint {
            constructor() {
                this.report = null;
                this.paint = null;
                this.rpwPrint = null;
                this.fPreview = null;
                this.lastIndexField = 0;
                this.currPage = -1;
                this.fnt = null;
                this.x = 0;
                this.y = 0;
                this.rePaintObject = null;
                this.realWidth = 0;
                this.realHeight = 0;
                this.scaleFont = 1;
                this.scaleY = 1;
                this.scaleX = 1;
                this.bModal = null;
                this.bHidePreviewWindow = null;
                this.fileToSavePDF = "";
                this.pDFQuality = null;
                this.exportFileName = "";
                this.objClientToPrint = null;
                this.pagesToPrint = null;
                this.pageToPrint = -1;
                this.oldZoom = 0;
                this.oldScaleY = 0;
                this.oldScaleX = 0;
                this.oldScaleFont = 0;
                this.textEvalGraphic = OffscreenGraphic.createOffscreenGraphic("textEvalGraphic");
                try {
                    this.scaleX = 1;
                    this.scaleY = 1;
                    this.fnt = [];
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            getFileToSavePDF() {
                return this.fileToSavePDF;
            }
            setFileToSavePDF(rhs) {
                this.fileToSavePDF = rhs;
            }
            getPDFQuality() {
                return this.pDFQuality;
            }
            setPDFQuality(rhs) {
                this.pDFQuality = rhs;
            }
            getExportFileName() {
                return this.exportFileName;
            }
            setExportFileName(rhs) {
                this.exportFileName = rhs;
            }
            getReport() {
                return this.report;
            }
            setPreviewControl(rhs) {
                this.rpwPrint = rhs;
            }
            getCurrPage() {
                return this.currPage;
            }
            setCurrPage(rhs) {
                this.currPage = rhs;
            }
            setModal(rhs) {
                this.bModal = rhs;
            }
            setHidePreviewWindow(rhs) {
                this.bHidePreviewWindow = rhs;
            }
            setReport(rhs) {
                this.report = rhs;
            }
            closePreviewWindow() {
                try {
                    if (this.fPreview !== null) {
                        this.fPreview.close();
                        this.fPreview = null;
                    }
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            getLine(indexField) {
                let fld = this.getField(indexField);
                if (fld === null) {
                    return null;
                }
                else {
                    let item = this.report.getPages().item(this.currPage);
                    if (indexField < cReportPrint.OFFSETDETAIL) {
                        return this.getLineAux(fld.get().getIndexLine(), item.getHeader());
                    }
                    else if (indexField < cReportPrint.OFFSETFOOTER) {
                        return this.getLineAux(fld.get().getIndexLine(), item.getDetail());
                    }
                    else {
                        return this.getLineAux(fld.get().getIndexLine(), item.getFooter());
                    }
                }
            }
            getCtrlFooter(ctrlName) {
                return this.getFieldByCtrlName(ctrlName, this.report.getPages().item(this.currPage).getFooter());
            }
            getIndexFieldByName(ctrlName) {
                return this.paint.getPaintObjects().item(ctrlName).getIndexField();
            }
            refreshCtrl(indexField) {
                let paintObj = null;
                let fld = new RefWrapper(null);
                let page;
                page = this.report.getPages().item(this.currPage);
                if (indexField < cReportPrint.OFFSETDETAIL) {
                    if (!this.getFieldFromIndexAux(page.getHeader(), indexField, fld)) {
                        return;
                    }
                }
                else if (indexField < cReportPrint.OFFSETFOOTER) {
                    if (!this.getFieldFromIndexAux(page.getDetail(), indexField - cReportPrint.OFFSETDETAIL, fld)) {
                        return;
                    }
                }
                else {
                    if (!this.getFieldFromIndexAux(page.getFooter(), indexField - cReportPrint.OFFSETFOOTER, fld)) {
                        return;
                    }
                }
                paintObj = this.pGetPaintObjByIndex(indexField);
                let ctrlFont = fld.get().getInfo().getAspect().getFont();
                let aspect = paintObj.getAspect();
                let font = aspect.getFont();
                font.setForeColor(ctrlFont.getForeColor());
                font.setBold(ctrlFont.getBold());
                font.setItalic(ctrlFont.getItalic());
                font.setName(ctrlFont.getName());
                font.setSize(ctrlFont.getSize());
                font.setStrike(ctrlFont.getStrike());
                font.setUnderline(ctrlFont.getUnderline());
                this.paint.refreshObject(paintObj.getKey(), this.rpwPrint.getGraph());
            }
            refreshCtrlFooter(ctrlName) {
                let paintObj = this.pGetPaintObjByCtrlName(ctrlName, this.report.getPages().item(this.currPage).getFooter(), cReportPrint.OFFSETFOOTER);
                paintObj.setText(this.getCtrlFooter(ctrlName).getValue());
                this.paint.refreshObject(paintObj.getKey(), this.rpwPrint.getGraph());
            }
            getFieldByCtrlName(ctrlName, fields, indexField = 0) {
                let fld = null;
                for (let _i = 0; _i < fields.count(); _i++) {
                    fld = fields.item(_i);
                    if (fld.getInfo().getName() === ctrlName) {
                        if (this.isInThisLine(ctrlName, indexField, fld)) {
                            return fld;
                        }
                    }
                }
                return null;
            }
            getPaintObjByCtrlNameEx(ctrlName, indexField) {
                let offset;
                let item = this.report.getPages().item(this.currPage);
                let fields = item.getHeader();
                offset = cReportPrint.OFFSETHEADER;
                let fld = this.getFieldByCtrlName(ctrlName, fields, indexField);
                if (fld === null) {
                    fields = item.getDetail();
                    offset = cReportPrint.OFFSETDETAIL;
                    fld = this.getFieldByCtrlName(ctrlName, fields, indexField);
                    if (fld === null) {
                        fields = item.getFooter();
                        offset = cReportPrint.OFFSETFOOTER;
                        fld = this.getFieldByCtrlName(ctrlName, fields, indexField);
                        if (fld === null) {
                            return null;
                        }
                    }
                }
                for (let _i = 0; _i < this.paint.getPaintObjects().count(); _i++) {
                    let paintObj = this.paint.getPaintObjects().item(_i);
                    if (fields.item(paintObj.getIndexField() - offset) === fld) {
                        if (this.isInThisLine(ctrlName, indexField, fld)) {
                            return paintObj;
                        }
                    }
                }
                return null;
            }
            isInThisLine(ctrlName, indexField, testFld) {
                let fields = null;
                let fld = null;
                if (indexField === 0) {
                    return true;
                }
                fields = this.getLine(indexField);
                for (let _i = 0; _i < fields.count(); _i++) {
                    fld = fields.item(_i);
                    if (fld.getInfo().getName() === ctrlName) {
                        if (testFld === fld) {
                            return true;
                        }
                    }
                }
                return false;
            }
            getField(indexField) {
                let rtn = new RefWrapper(null);
                let page = this.report.getPages().item(this.currPage);
                if (indexField < cReportPrint.OFFSETDETAIL) {
                    if (!this.getFieldFromIndexAux(page.getHeader(), indexField, rtn)) {
                        return null;
                    }
                }
                else if (indexField < cReportPrint.OFFSETFOOTER) {
                    if (!this.getFieldFromIndexAux(page.getDetail(), indexField - cReportPrint.OFFSETDETAIL, rtn)) {
                        return null;
                    }
                }
                else {
                    if (!this.getFieldFromIndexAux(page.getFooter(), indexField - cReportPrint.OFFSETFOOTER, rtn)) {
                        return null;
                    }
                }
                return rtn;
            }
            fieldIsInDetail(indexField) {
                return indexField >= cReportPrint.OFFSETDETAIL && indexField < cReportPrint.OFFSETFOOTER;
            }
            printPage(nPage, inPrinter = false) {
                let page = null;
                let mouse = new CMouseWait();
                this.rePaintObject = true;
                if (nPage > 1) {
                    this.currPage = nPage - 1;
                }
                else {
                    switch (nPage) {
                        case CSReportPaint.csEMoveTo.FIRSTPAGE:
                            this.currPage = 0;
                            break;
                        case CSReportPaint.csEMoveTo.LASTPAGE:
                            this.currPage = this.report.getPages().count() - 1;
                            break;
                        case CSReportPaint.csEMoveTo.NEXTPAGE:
                            if (this.currPage + 1 < this.report.getPages().count()) {
                                this.currPage = this.currPage + 1;
                            }
                            else {
                                this.currPage = this.report.getPages().count() - 1;
                            }
                            break;
                        case CSReportPaint.csEMoveTo.PREVIOUSPAGE:
                            if (this.currPage - 1 >= 0) {
                                this.currPage = this.currPage - 1;
                            }
                            else {
                                this.currPage = 0;
                            }
                            break;
                    }
                }
                if (this.currPage === -1 || this.currPage > this.report.getPages().count() - 1) {
                    return;
                }
                page = this.report.getPages().item(this.currPage);
                this.paint.getPaintObjects().clear();
                this.createPaintObjects(page.getHeader(), cReportPrint.OFFSETHEADER);
                this.createPaintObjects(page.getDetail(), cReportPrint.OFFSETDETAIL);
                this.createPaintObjects(page.getFooter(), cReportPrint.OFFSETFOOTER);
                if (!inPrinter) {
                    this.rpwPrint.setCurrPage(this.currPage);
                    this.rpwPrint.getBody().refresh();
                }
            }
            makeReport() {
                return this.make();
            }
            makeXml() {
                return false;
            }
            previewReport() {
                this.setPreviewForm();
                this.createPaint();
                this.rpwPrint.setPages(this.report.getPages().count());
                this.printPage(CSReportPaint.csEMoveTo.FIRSTPAGE, false);
                return true;
            }
            createPDF(objClient = null) {
                try {
                    let q = 0;
                    this.createPaint();
                    this.rePaintObject = true;
                    let printer = null;
                    if (this.report.getLaunchInfo().getPrinter() === null) {
                        printer = cPrintAPI.getcPrinterFromDefaultPrinter(null);
                    }
                    else {
                        printer = this.report.getLaunchInfo().getPrinter();
                    }
                    const pagesToPrint = "1-" + this.report.getPages().count().toString();
                    if (!this.printPagesToPDF(pagesToPrint, objClient)) {
                        return false;
                    }
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
                finally {
                    if (this.rpwPrint !== null) {
                        this.printPage(this.currPage, false);
                        this.rpwPrint.getBody().refresh();
                    }
                }
            }
            printReport(objClient = null) {
                try {
                    let copies = 0;
                    let q = 0;
                    this.createPaint();
                    this.rePaintObject = true;
                    let printer = null;
                    if (this.report.getLaunchInfo().getPrinter() === null) {
                        printer = cPrintAPI.getcPrinterFromDefaultPrinter(null);
                    }
                    else {
                        printer = this.report.getLaunchInfo().getPrinter();
                    }
                    let launchInfo = this.report.getLaunchInfo();
                    copies = launchInfo.getCopies();
                    if (launchInfo.getShowPrintersDialog()) {
                        printer.setCopies(copies);
                        if (!printer.showDialog(this.report.getPages().count())) {
                            return false;
                        }
                        copies = printer.getCopies();
                    }
                    else {
                        printer.getPaperInfo().setPagesToPrint("1-" + this.report.getPages().count().toString());
                    }
                    for (q = 0; q < copies; q++) {
                        if (!this.printPagesToPrinter(printer, objClient)) {
                            return false;
                        }
                    }
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
                finally {
                    if (this.rpwPrint !== null) {
                        this.printPage(this.currPage, false);
                        this.rpwPrint.getBody().refresh();
                    }
                }
            }
            pGetPaintObjByIndex(indexField) {
                for (let _i = 0; _i < this.paint.getPaintObjects().count(); _i++) {
                    let po = this.paint.getPaintObjects().item(_i);
                    if (po.getIndexField() === indexField) {
                        return po;
                    }
                }
                return null;
            }
            pGetPaintObjByCtrlName(ctrlName, fields, offset) {
                let fld = this.getFieldByCtrlName(ctrlName, fields);
                for (let _i = 0; _i < this.paint.getPaintObjects().count(); _i++) {
                    let rtn = this.paint.getPaintObjects().item(_i);
                    if (fields.item(rtn.getIndexField() - offset) === fld) {
                        return rtn;
                    }
                }
                return null;
            }
            createPaint() {
                if (this.paint === null) {
                    this.paint = new CSReportPaint.cReportPaint();
                }
                this.paint.setNotBorder(true);
            }
            printPagesToPrinter(printer, objClient) {
                try {
                    let printDoc = new PrintDocument();
                    let paperInfo = this.report.getPaperInfo();
                    if (!printer.starDoc(printDoc, this.report.getName(), paperInfo.getPaperSize(), paperInfo.getOrientation())) {
                        return false;
                    }
                    printDoc.setPrintPage(P.call(this, this.doPrintPage));
                    printDoc.getPrinterSettings().setPrinterName(printer.getDeviceName());
                    this.pageToPrint = -1;
                    this.pagesToPrint = this.getPagesToPrint(printer.getPaperInfo().getPagesToPrint());
                    this.objClientToPrint = objClient;
                    printDoc.print();
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            doPrintPage(e) {
                if (this.pageToPrint === -1) {
                    let dpiX = 0;
                    let dpiY = 0;
                    this.oldScaleX = this.paint.getScaleX();
                    this.oldScaleY = this.paint.getScaleY();
                    this.oldScaleFont = this.scaleFont;
                    this.oldZoom = this.paint.getZoom();
                    let graphic = e.graphic;
                    dpiX = graphic.DpiX;
                    dpiY = graphic.DpiY;
                    this.scaleX = dpiX / 100;
                    this.scaleY = dpiY / 100;
                    let twipsPerPixelX = 1440 / dpiX;
                    let dPI = 0;
                    dPI = (1440 / twipsPerPixelX);
                    if (dPI !== 96 && dPI > 0) {
                        this.scaleX = this.scaleX * (96 / dPI);
                        this.scaleY = this.scaleY * (96 / dPI);
                    }
                    this.scaleX = 1;
                    this.scaleY = 1;
                    this.paint.setScaleX(this.scaleX);
                    this.paint.setScaleY(this.scaleY);
                    this.paint.setZoom(100);
                    this.scaleFont = 1;
                }
                this.pageToPrint += 1;
                while (this.pageToPrint < this.report.getPages().count()) {
                    if (this.haveToPrintThisPage(this.pageToPrint + 1, this.pagesToPrint)) {
                        this.printPage(this.pageToPrint + 1, true);
                        let graphic = e.graphic;
                        if (!this.drawPage(graphic, true)) {
                            throw new CSReportPaint.ReportPaintException("There was an error when printing the report.");
                        }
                        if (!this.refreshObjClient(this.pageToPrint, this.objClientToPrint)) {
                            throw new CSReportPaint.ReportPaintException("There was an error when printing the report.");
                        }
                        e.hasMorePages = (this.pageToPrint + 1 < this.pagesToPrint[this.pagesToPrint.length - 1]);
                        return;
                    }
                    else {
                        this.pageToPrint += 1;
                    }
                }
                this.paint.setZoom(this.oldZoom);
                this.scaleX = this.oldScaleX;
                this.scaleY = this.oldScaleY;
                this.paint.setScaleX(this.oldScaleX);
                this.paint.setScaleY(this.oldScaleY);
                this.scaleFont = this.oldScaleFont;
                e.hasMorePages = false;
            }
            printPagesToPDF(pagesToPrint, objClient) {
                try {
                    let paperInfo = this.report.getPaperInfo();
                    let orientation = csRptPageOrientation.PORTRAIT === paperInfo.getOrientation() ? 'p' : 'l';
                    let paperSize;
                    switch (paperInfo.getPaperSize()) {
                        case csReportPaperType.CS_RPT_PAPER_TYPE_LETTER:
                            paperSize = 'letter';
                            break;
                        case csReportPaperType.CS_RPT_PAPER_TYPE_LEGAL:
                            paperSize = 'legal';
                            break;
                        case csReportPaperType.CS_RPT_PAPER_TYPE_A4:
                            paperSize = 'a4';
                            break;
                        case csReportPaperType.CS_RPT_PAPER_TYPE_A3:
                            paperSize = 'a3';
                            break;
                        case csReportPaperType.CS_RPT_PAPER_USER:
                            paperSize = [paperInfo.getCustomHeight(), paperInfo.getCustomWidth()];
                            break;
                        default:
                            throw new ArgumentException("PaperSize not supported: " + paperInfo.getPaperSize());
                    }
                    let printDoc = new PDFDocument(cPrintAPI.getPaperSize(paperInfo.getPaperSize(), paperInfo.getOrientation()), orientation, 'pt', paperSize);
                    printDoc.setPrintPage(P.call(this, this.createPDFPage));
                    this.pageToPrint = -1;
                    this.pagesToPrint = this.getPagesToPrint(pagesToPrint);
                    this.objClientToPrint = objClient;
                    printDoc.print(this.report.getName() + ".pdf");
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            createPDFPage(e) {
                if (this.pageToPrint === -1) {
                    this.oldScaleX = this.paint.getScaleX();
                    this.oldScaleY = this.paint.getScaleY();
                    this.oldScaleFont = this.scaleFont;
                    this.oldZoom = this.paint.getZoom();
                    const paperInfo = this.report.getPaperInfo();
                    const size = cPrintAPI.getPaperSize(paperInfo.getPaperSize(), paperInfo.getOrientation());
                    const tR = CSReportPaint.cGlobals.getRectFromPaperSize(paperInfo, paperInfo.getPaperSize(), paperInfo.getOrientation());
                    this.scaleX = 0.75;
                    this.scaleY = 0.75;
                    this.paint.setScaleX(this.scaleX);
                    this.paint.setScaleY(this.scaleY);
                    this.paint.setZoom(100);
                    this.scaleFont = 1;
                }
                this.pageToPrint += 1;
                while (this.pageToPrint < this.report.getPages().count()) {
                    if (this.haveToPrintThisPage(this.pageToPrint + 1, this.pagesToPrint)) {
                        this.printPage(this.pageToPrint + 1, true);
                        let graphic = e.graphic;
                        if (!this.drawPage(graphic, true)) {
                            throw new CSReportPaint.ReportPaintException("There was an error when printing the report.");
                        }
                        if (!this.refreshObjClient(this.pageToPrint, this.objClientToPrint)) {
                            throw new CSReportPaint.ReportPaintException("There was an error when printing the report.");
                        }
                        e.hasMorePages = (this.pageToPrint + 1 < this.pagesToPrint[this.pagesToPrint.length - 1]);
                        return;
                    }
                    else {
                        this.pageToPrint += 1;
                    }
                }
                this.paint.setZoom(this.oldZoom);
                this.scaleX = this.oldScaleX;
                this.scaleY = this.oldScaleY;
                this.paint.setScaleX(this.oldScaleX);
                this.paint.setScaleY(this.oldScaleY);
                this.scaleFont = this.oldScaleFont;
                e.hasMorePages = false;
            }
            refreshObjClient(iPage, objClient) {
                if (objClient === null) {
                    return true;
                }
                else {
                    return objClient.printingPage(iPage);
                }
            }
            haveToPrintThisPage(page, v) {
                for (let n = 0; n < v.length; n++) {
                    if (page === v[n]) {
                        return true;
                    }
                }
                return false;
            }
            getPagesToPrint(pagesToPrint) {
                let v;
                let n;
                let v2 = null;
                let t = 0;
                let r = 0;
                let addInterval = false;
                v = pagesToPrint.split(',');
                n = [];
                for (let i = 0; i < v.length; i++) {
                    let k = v[i].indexOf("-", 1);
                    if (k > 0) {
                        v2 = v[i].split('-');
                        addInterval = false;
                        for (t = 0; t < v2.length; t++) {
                            if (U.isNumber(v2[t])) {
                                if (addInterval) {
                                    for (r = n[n.length - 1] + 1; r <= U.parseInt(v2[t]) - 1; r++) {
                                        n.push(r);
                                    }
                                }
                                else {
                                    addInterval = true;
                                }
                                n.push(U.parseInt(v2[t]));
                            }
                        }
                    }
                    else {
                        if (U.isNumber(v[i])) {
                            n.push(U.parseInt(v[i]));
                        }
                    }
                }
                return n;
            }
            getLineAux(indexLine, fields) {
                let newFields = new CSReports.CSReportEngine.cReportPageFields();
                for (let _i = 0; _i < fields.count(); _i++) {
                    let fld = fields.item(_i);
                    if (fld.getIndexLine() === indexLine) {
                        newFields.add(fld);
                    }
                }
                return newFields;
            }
            make() {
                let detailHeight = new RefWrapper(0);
                let lineHeight = 0;
                let fields = new RefWrapper(null);
                let field = null;
                let detail = null;
                let rslt;
                let rsltNewPage;
                let top = new RefWrapper(0);
                let topSection = 0;
                let heightSection = 0;
                let secLnIndex = -1;
                let offsetTopr = new RefWrapper([]);
                let mouse = new CMouseWait();
                this.printerSetSizeAndOrient(this.report.getLaunchInfo().getPrinter().getDeviceName(), this.report.getPaperInfo().getPaperSize(), this.report.getPaperInfo().getOrientation());
                this.currPage = -1;
                rsltNewPage = this.report.newPage();
                if (rsltNewPage === csRptNewPageResult.CS_RPT_NP_ERROR) {
                    return false;
                }
                if (rsltNewPage === csRptNewPageResult.CS_RPT_NP_END) {
                    return this.report.endPage() !== csRptEndPageResult.CS_RPT_EP_ERROR;
                }
                if (this.report.getGroups().count() === 0) {
                    this.report.evalPreGroupHeader();
                    this.report.evalPre();
                }
                this.calculateDetailsDimensions(detailHeight, top);
                do {
                    rslt = this.report.getLine(fields);
                    if (rslt === csRptGetLineResult.CS_RPT_GL_END) {
                        break;
                    }
                    if (rslt === csRptGetLineResult.CS_RPT_GL_VIRTUAL_H) {
                        this.report.evalPreGroupHeader();
                    }
                    else if (rslt === csRptGetLineResult.CS_RPT_GL_VIRTUAL_F) {
                        this.report.evalPreGroupFooter();
                    }
                    else if (rslt === csRptGetLineResult.CS_RPT_GL_NEW_PAGE) {
                        if (!this.newPage(top, detailHeight)) {
                            return false;
                        }
                        this.calculateDetailsDimensions(detailHeight, top);
                        this.updateFooterFieldHeight();
                    }
                    else {
                        lineHeight = this.updateFieldHeight(fields.get(), offsetTopr);
                        if (lineHeight > detailHeight.get()) {
                            if (!this.newPage(top, detailHeight)) {
                                return false;
                            }
                            this.calculateDetailsDimensions(detailHeight, top);
                            this.updateFooterFieldHeight();
                        }
                        else {
                            heightSection = 0;
                            topSection = 0;
                            secLnIndex = -1;
                            detail = this.report.getPages().item(this.report.getPages().count() - 1).getDetail();
                            for (let _i = 0; _i < fields.get().count(); _i++) {
                                field = fields.get().item(_i);
                                let sectionLine = field.getInfo().getSectionLine();
                                if (secLnIndex !== sectionLine.getIndex()) {
                                    secLnIndex = sectionLine.getIndex();
                                    let aspect = sectionLine.getAspect();
                                    topSection = topSection + (aspect.getTop() - (topSection + heightSection));
                                    heightSection = heightSection + aspect.getHeight();
                                }
                                field.setTop(top.get()
                                    + offsetTopr.get()[secLnIndex]
                                    + (field.getInfo().getAspect().getTop()
                                        - topSection));
                                detail.add(field);
                            }
                            top.set(top.get() + lineHeight);
                            detailHeight.set(detailHeight.get() - lineHeight);
                            if (rslt === csRptGetLineResult.CS_RPT_GL_GROUP_HEADER) {
                                this.report.markGroupHeaderPrinted();
                                this.report.evalPostGroupHeader();
                            }
                            else if (rslt === csRptGetLineResult.CS_RPT_GL_GROUP_FOOTER) {
                                this.report.markGroupFooterPrinted();
                                this.report.evalPostGroupFooter();
                            }
                            else if (rslt === csRptGetLineResult.CS_RPT_GL_DETAIL) {
                                this.report.evalPost();
                                this.report.moveToNext();
                            }
                            if (this.report.getLineType() === csRptGetLineResult.CS_RPT_GL_DETAIL) {
                                this.report.evalPre();
                            }
                        }
                    }
                } while (true);
                const endPageRslt = this.report.endPage() !== csRptEndPageResult.CS_RPT_EP_ERROR;
                if (endPageRslt)
                    this.updateFooterFieldHeight(true);
                return endPageRslt;
            }
            calculateDetailsDimensions(detailHeight, top) {
                detailHeight.set(this.getDetailHeight(this.report.getPages().item(this.report.getPages().count() - 1), top));
                this.updateFieldHeight(this.report.getPages().item(this.report.getPages().count() - 1).getHeader());
            }
            updateFooterFieldHeight(isLastPage = false) {
                const count = this.report.getPages().count();
                const idx = count - (isLastPage ? 1 : 2);
                this.updateFieldHeight(this.report.getPages().item(idx).getFooter());
            }
            printerSetSizeAndOrient(p, paperType, p_2) {
            }
            newPage(top, detailHeight) {
                let rsltNewPage;
                let rsltEndPage;
                rsltEndPage = this.report.endPage();
                if (rsltEndPage === csRptEndPageResult.CS_RPT_EP_ERROR) {
                    return false;
                }
                rsltNewPage = this.report.newPage();
                if (rsltNewPage === csRptNewPageResult.CS_RPT_NP_ERROR) {
                    return false;
                }
                detailHeight.set(this.getDetailHeight(this.report.getPages().item(this.report.getPages().count() - 1), top));
                return true;
            }
            getDetailHeight(page, top) {
                top.set(page.getHeaderBottom());
                return page.getFooterTop() - top.get();
            }
            updateFieldHeight(fields, offsetTopr = null) {
                let field = null;
                let offBottom = 0;
                let aspectHeight = 0;
                let aspectWidth = 0;
                let aspect = null;
                let aspectLn = null;
                let lnHeight = 0;
                let lnHeight2 = 0;
                let newLnHeight = 0;
                let font = null;
                let topSection = 0;
                let indexSection = -1;
                let heightSection = 0;
                const offsetTop = [];
                if (fields.count() > 0) {
                    for (let _i = 0; _i < fields.count(); _i++) {
                        field = fields.item(_i);
                        aspect = field.getInfo().getAspect();
                        aspectLn = field.getInfo().getSectionLine().getAspect();
                        if (indexSection !== field.getInfo().getSectionLine().getIndex()) {
                            indexSection = field.getInfo().getSectionLine().getIndex();
                            offsetTop[indexSection] = U.val(offsetTop[indexSection]) + newLnHeight - lnHeight;
                            topSection = topSection + (aspectLn.getTop() - (topSection + heightSection));
                            heightSection = heightSection + aspectLn.getHeight();
                            lnHeight = aspectLn.getHeight();
                            lnHeight2 = lnHeight;
                            newLnHeight = lnHeight;
                        }
                        if (aspect.getCanGrow()) {
                            aspectHeight = aspect.getHeight();
                            aspectWidth = aspect.getWidth();
                            if (field.getImage() !== null) {
                                let width = 0;
                                let height = 0;
                                ({ width, height } = field.getImage().getSize());
                                field.setHeight(height);
                                field.setWidth(width);
                                if (field.getHeight() < aspectHeight) {
                                    field.setHeight(aspectHeight);
                                }
                                if (field.getWidth() < aspectWidth) {
                                    field.setWidth(aspectWidth);
                                }
                            }
                            else {
                                if (field.getValue() !== "") {
                                    let format = new StringFormat();
                                    format.trimming = StringTrimming.EllipsisWord;
                                    format.alignment = StringAlignment.Near;
                                    if (!aspect.getWordWrap()) {
                                        format.formatFlags = StringFormatFlags.NoWrap;
                                    }
                                    let idx = CSReportPaint.cGlobals.addFontIfRequired(aspect.getFont(), this.fnt);
                                    font = this.fnt[idx];
                                    field.setHeight(this.evaluateTextHeight(field.getValue(), font, aspect.getWidth(), format, this.scaleY, this.scaleX));
                                    if (field.getHeight() < aspectHeight) {
                                        field.setHeight(aspectHeight);
                                    }
                                }
                            }
                            if (field.getHeight() + aspect.getTop() > topSection + newLnHeight) {
                                offBottom = (topSection + newLnHeight) - (aspect.getTop() + aspectHeight);
                                if (offBottom < 0) {
                                    offBottom = offBottom + 5;
                                }
                                newLnHeight = aspect.getTop() - topSection + field.getHeight() + offBottom;
                            }
                            if (newLnHeight > lnHeight2) {
                                heightSection = heightSection - lnHeight2 + newLnHeight;
                                lnHeight2 = newLnHeight;
                            }
                        }
                        else {
                            field.setHeight(aspect.getHeight());
                        }
                    }
                }
                if (offsetTopr !== null)
                    offsetTopr.set(offsetTop);
                return heightSection;
            }
            evaluateTextHeight(text, font, width, format, scaleY, scaleX) {
                let stringSize = this.textEvalGraphic.measureString(text, font, Math.trunc(width * scaleX), format);
                return Math.trunc(stringSize.height / scaleY);
            }
            setPreviewForm() {
                if (this.rpwPrint === null) {
                    if (this.fPreview === null) {
                        this.fPreview = new CSReportPaint.fPreview();
                    }
                    this.rpwPrint = this.fPreview.getRpwReport();
                }
                let tR;
                let printer = this.report.getLaunchInfo().getPrinter();
                tR = CSReportPaint.cGlobals.getRectFromPaperSize(printer.getPaperInfo(), printer.getPaperInfo().getPaperSize(), printer.getPaperInfo().getOrientation());
                this.realWidth = tR.getWidth();
                this.realHeight = tR.getHeight();
                this.rpwPrint.getBody().setWidth(this.realWidth);
                this.rpwPrint.getBody().setHeight(this.realHeight);
                if (!this.bModal) {
                    if (!this.bHidePreviewWindow) {
                        let obj = this.rpwPrint.getParent();
                        if (obj instanceof Form) {
                            let f = obj;
                            f.show();
                        }
                    }
                }
                this.rpwPrint.getBody().setPaint(P.call(this, this.rpwPrintBodyPaint));
                this.rpwPrint.setFirstPage(P.call(this, this.rpwPrintMoveFirst));
                this.rpwPrint.setPreviousPage(P.call(this, this.rpwPrintMovePrevious));
                this.rpwPrint.setMoveToPage(P.call(this, this.rpwPrintMoveToPage));
                this.rpwPrint.setNextPage(P.call(this, this.rpwPrintMoveNext));
                this.rpwPrint.setLastPage(P.call(this, this.rpwPrintMoveLast));
            }
            createPaintObjects(fields, offset) {
                let field = null;
                let rptAspect = null;
                let rptFont = null;
                let index = 0;
                for (let _i = 0; _i < fields.count(); _i++) {
                    field = fields.item(_i);
                    index = index + 1;
                    if (field.getVisible()) {
                        rptAspect = field.getInfo().getAspect();
                        let po = this.paint.getPaintObjects().add(null, "");
                        let aspect = po.getAspect();
                        if (field.getTop() > 0) {
                            aspect.setTop(field.getTop());
                        }
                        else {
                            aspect.setTop(rptAspect.getTop());
                        }
                        if (field.getHeight() > 0) {
                            aspect.setHeight(field.getHeight());
                        }
                        else {
                            aspect.setHeight(rptAspect.getHeight());
                        }
                        if (field.getWidth() > 0) {
                            aspect.setWidth(field.getWidth());
                        }
                        else {
                            aspect.setWidth(rptAspect.getWidth());
                        }
                        aspect.setLeft(rptAspect.getLeft());
                        aspect.setBackColor(rptAspect.getBackColor());
                        aspect.setTransparent(rptAspect.getTransparent());
                        aspect.setAlign(rptAspect.getAlign());
                        aspect.setWordWrap(rptAspect.getWordWrap());
                        aspect.setBorderColor(rptAspect.getBorderColor());
                        aspect.setBorderColor3d(rptAspect.getBorderColor3d());
                        aspect.setBorderColor3dShadow(rptAspect.getBorderColor3dShadow());
                        aspect.setBorderRounded(rptAspect.getBorderRounded());
                        aspect.setBorderType(rptAspect.getBorderType());
                        aspect.setBorderWidth(rptAspect.getBorderWidth());
                        rptFont = rptAspect.getFont();
                        let font = aspect.getFont();
                        font.setBold(rptFont.getBold());
                        font.setForeColor(rptFont.getForeColor());
                        font.setItalic(rptFont.getItalic());
                        font.setName(rptFont.getName());
                        font.setSize(rptFont.getSize() * this.scaleFont);
                        font.setStrike(rptFont.getStrike());
                        font.setUnderline(rptFont.getUnderline());
                        po.setText(field.getValue());
                        po.setImage(field.getImage());
                        if (po.getImage() !== null) {
                            po.setPaintType(CSReportPaint.csRptPaintObjType.PAINT_OBJ_IMAGE);
                        }
                        po.setIndexField(index + offset);
                        if (field.getObjectID() !== null) {
                            po.setTag(field.getObjectID().getValue());
                        }
                    }
                }
            }
            fPreview_FormUnload() {
                this.rpwPrint = null;
                this.report.getLaunchInfo().getReportPrint().setReport(null);
                this.report.getLaunchInfo().setReportPrint(null);
            }
            rpwPrint_BodyDblClick() {
            }
            getFieldFromIndexAux(fields, index, rtn) {
                try {
                    rtn.set(fields.item(index));
                    return true;
                }
                catch (ignore) {
                    return false;
                }
            }
            rpwPrint_BodyMouseDown(button, shift, x, y) {
            }
            rpwPrint_BodyMouseMove(button, shift, x, y) {
            }
            rpwPrintBodyPaint(sender, e) {
                if (this.paint !== null) {
                    this.drawPage(e.graphics, false);
                }
            }
            rpwPrint_ChangeZoom(zoom) {
                let nZoom = 0;
                let width = 0;
                let height = 0;
                switch (zoom) {
                    case csEZoom.csEZoomAllPage:
                        width = this.rpwPrint.getWidth() / this.realWidth;
                        height = this.rpwPrint.getHeight() / this.realHeight;
                        if (width < height) {
                            nZoom = this.rpwPrint.getWidth() / this.realWidth;
                        }
                        else {
                            nZoom = this.rpwPrint.getHeight() / this.realHeight;
                        }
                        break;
                    case csEZoom.csEZoomCustom:
                        nZoom = 1;
                        break;
                    case csEZoom.csEZoomWidth:
                        nZoom = this.rpwPrint.getWidth() / this.realWidth;
                        break;
                    default:
                        nZoom = zoom / 100;
                        break;
                }
                if (nZoom < 0.01) {
                    nZoom = 0.01;
                }
                let pic = this.rpwPrint.getBody();
                pic.setWidth(this.realWidth * nZoom);
                pic.setHeight(this.realHeight * nZoom);
                if (nZoom > 0.5) {
                    this.paint.setZoom(100);
                    this.paint.setScaleX(nZoom);
                    this.paint.setScaleY(nZoom);
                    this.scaleFont = nZoom;
                    this.printPage(this.currPage);
                }
                else {
                    this.paint.setZoom(zoom);
                    this.rpwPrint.getBody().refresh();
                }
            }
            sendMail(files, emailAddress) {
                let expPDF = null;
                expPDF = new cReportPdf();
                expPDF.setExportEmailAddress(emailAddress);
                return expPDF.sendMail(files);
            }
            exportPDFEx(outputFile, bShowPDFWindow) {
                return this.pExportPDF(outputFile, bShowPDFWindow);
            }
            exportPDF() {
                let dummy = "";
                return this.pExportPDF(dummy, true);
            }
            pGetExportFileName() {
                if (this.exportFileName !== "") {
                    return this.exportFileName;
                }
                else {
                    return this.report.getName();
                }
            }
            pExportPDF(outputFile, bShowPDFWindow) {
                try {
                    let mouse = new CMouseWait();
                    let expPDF = null;
                    expPDF = new CSReports.CSReportExport.cReportPdf();
                    expPDF.setFileName(U.getValidPath("") + this.pGetExportFileName());
                    expPDF.setExportEmailAddress(this.report.getExportEmailAddress());
                    return expPDF.exportEx(this.report, this, outputFile, bShowPDFWindow);
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
            }
            rpwPrintMoveFirst(sender, e) {
                this.printPage(CSReportPaint.csEMoveTo.FIRSTPAGE);
            }
            rpwPrintMoveLast(sender, e) {
                this.printPage(CSReportPaint.csEMoveTo.LASTPAGE);
            }
            rpwPrintMoveNext(sender, e) {
                this.printPage(CSReportPaint.csEMoveTo.NEXTPAGE);
            }
            rpwPrintMovePrevious(sender, e) {
                this.printPage(CSReportPaint.csEMoveTo.PREVIOUSPAGE);
            }
            rpwPrintMoveToPage(sender, e) {
                this.printPage(e.getPage());
            }
            rpwPrint_SaveDocument() {
            }
            drawPage(graphic, isPrinter) {
                let i = 0;
                if (this.rePaintObject) {
                    if (isPrinter) {
                        this.paint.createBackgroundBitmap(graphic);
                        for (i = 0; i < this.paint.getPaintObjects().count(); i++) {
                            if (!this.paint.drawObject(this.paint.getPaintObjects().getNextKeyForZOrder(i), graphic)) {
                                return false;
                            }
                        }
                        for (i = 0; i < this.paint.getPaintSections().count(); i++) {
                            if (!this.paint.drawSection(this.paint.getPaintSections().getNextKeyForZOrder(i), graphic)) {
                                return false;
                            }
                        }
                    }
                    else {
                        this.paint.reDrawPage(this.rpwPrint.getBody().getGraphics());
                        this.rePaintObject = false;
                        this.paint.paintPicture(graphic, false);
                    }
                }
                else {
                    this.paint.paintPicture(graphic, false);
                }
                return true;
            }
            dispose() {
                this.report = null;
                this.paint = null;
                if (this.fPreview !== null) {
                    this.fPreview.close();
                }
                this.rpwPrint = null;
            }
            getPageImageAsBase64(page, pageIndex) {
                if (this.paint !== null) {
                    if (this.currPage !== page - 1)
                        this.printPage(page, true);
                    pageIndex.set(this.currPage + 1);
                    let bmp = new Bitmap(this.realWidth, this.realHeight, "pageImageAsBase64");
                    Graphic.fromImage(bmp).then((bmpGraphics) => {
                        this.drawPage(bmpGraphics, false);
                        let image = "";
                        return "data:image/png;base64," + image;
                    });
                }
                else {
                    pageIndex.set(-1);
                    return "";
                }
            }
        }
        cReportPrint.OFFSETHEADER = 0;
        cReportPrint.OFFSETDETAIL = 100000;
        cReportPrint.OFFSETFOOTER = 1000000;
        CSReportPaint.cReportPrint = cReportPrint;
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        var csReportPaperType = CSReports.CSReportGlobals.csReportPaperType;
        var csRptPageOrientation = CSReports.CSReportGlobals.csRptPageOrientation;
        var RectangleF = CSReports.CSDrawing.RectangleF;
        var Font = CSReports.CSDrawing.Font;
        class cGlobals {
            constructor() {
                this._flag = {};
            }
            static getNextKey() {
                this.nextKey++;
                return this.nextKey;
            }
            static getKey(value) {
                if (value.length > 0) {
                    if ("0123456789".contains(value.substring(0, 1))) {
                        value = "K" + value;
                    }
                }
                return value;
            }
            static setRectangleWidth(width) {
                if (width < 0)
                    width = 0;
                return width;
            }
            static setRectangleHeight(height) {
                if (height < 0)
                    height = 0;
                return height;
            }
            static newRectangleF(left, top, right, bottom) {
                if (left < 0)
                    left = 0;
                if (top < 0)
                    top = 0;
                if (right < left)
                    right = left;
                if (bottom < top)
                    bottom = top;
                return RectangleF.new4(left, top, right, bottom);
            }
            static newRectangle(left, top, right, bottom) {
                if (left < 0)
                    left = 0;
                if (top < 0)
                    top = 0;
                if (right < left)
                    right = left;
                if (bottom < top)
                    bottom = top;
                return RectangleF.new4(left, top, right, bottom);
            }
            static getPixelsFromCmX(cm) {
                return cm * this._g.DpiX / 2.54;
            }
            static getPixelsFromCmY(cm) {
                return cm * this._g.DpiY / 2.54;
            }
            static getRectFromPaperSize(info, paperSize, orientation) {
                let rtn = new RectangleF();
                switch (paperSize) {
                    case csReportPaperType.CS_RPT_PAPER_TYPE_LETTER:
                        rtn.setHeight(this.getPixelsFromCmY(27.94));
                        rtn.setWidth(this.getPixelsFromCmX(21.59));
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_LEGAL:
                        rtn.setHeight(this.getPixelsFromCmY(35.56));
                        rtn.setWidth(this.getPixelsFromCmX(21.59));
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_A4:
                        rtn.setHeight(this.getPixelsFromCmY(29.7));
                        rtn.setWidth(this.getPixelsFromCmX(21));
                        break;
                    case csReportPaperType.CS_RPT_PAPER_TYPE_A3:
                        rtn.setHeight(this.getPixelsFromCmY(42));
                        rtn.setWidth(this.getPixelsFromCmX(29.7));
                        break;
                    case csReportPaperType.CS_RPT_PAPER_USER:
                        if (info === null) {
                            throw new CSReportPaint.ReportPaintException("The settings for the custome user paper size is not defined");
                        }
                        else {
                            rtn.setWidth(this.getPixelsFromCmY(info.getCustomWidth()));
                            rtn.setHeight(this.getPixelsFromCmX(info.getCustomHeight()));
                        }
                        break;
                }
                if (orientation === csRptPageOrientation.LANDSCAPE) {
                    let tmp = 0;
                    tmp = rtn.getHeight();
                    rtn.setHeight(rtn.getWidth());
                    rtn.setWidth(tmp);
                }
                return rtn;
            }
            static addFontIfRequired(font, fnt) {
                for (let i = 0; i < fnt.length; i++) {
                    if (font.getName() === fnt[i].name
                        && font.getBold() === fnt[i].bold
                        && font.getItalic() === fnt[i].italic
                        && font.getUnderline() === fnt[i]._underline
                        && font.getSize() === fnt[i].size
                        && font.getStrike() === fnt[i].strike) {
                        return i;
                    }
                }
                let afont = new Font(font.getName(), ((font.getSize() > 0) ? font.getSize() : 3), font.getBold(), font.getItalic(), font.getStrike(), font.getUnderline());
                fnt[fnt.length] = afont;
                return fnt.length - 1;
            }
        }
        cGlobals.NO_CHANGE = -32768;
        cGlobals.nextKey = 1000;
        cGlobals._g = { DpiX: 96, DpiY: 96 };
        CSReportPaint.cGlobals = cGlobals;
        let csETypeGrid;
        (function (csETypeGrid) {
            csETypeGrid[csETypeGrid["CSEGRIDNONE"] = 0] = "CSEGRIDNONE";
            csETypeGrid[csETypeGrid["CSEGRIDPOINTS"] = 1] = "CSEGRIDPOINTS";
            csETypeGrid[csETypeGrid["CSEGRIDLINES"] = 2] = "CSEGRIDLINES";
            csETypeGrid[csETypeGrid["CSEGRIDLINESVERTICAL"] = 3] = "CSEGRIDLINESVERTICAL";
            csETypeGrid[csETypeGrid["CSEGRIDLINESHORIZONTAL"] = 4] = "CSEGRIDLINESHORIZONTAL";
        })(csETypeGrid = CSReportPaint.csETypeGrid || (CSReportPaint.csETypeGrid = {}));
        let csRptPaintObjType;
        (function (csRptPaintObjType) {
            csRptPaintObjType[csRptPaintObjType["PAINT_OBJ_BOX"] = 0] = "PAINT_OBJ_BOX";
            csRptPaintObjType[csRptPaintObjType["PAINT_OBJ_LINE"] = 1] = "PAINT_OBJ_LINE";
            csRptPaintObjType[csRptPaintObjType["PAINT_OBJ_CIRCLE"] = 2] = "PAINT_OBJ_CIRCLE";
            csRptPaintObjType[csRptPaintObjType["PAINT_OBJ_IMAGE"] = 3] = "PAINT_OBJ_IMAGE";
        })(csRptPaintObjType = CSReportPaint.csRptPaintObjType || (CSReportPaint.csRptPaintObjType = {}));
        let csRptPaintRegionType;
        (function (csRptPaintRegionType) {
            csRptPaintRegionType[csRptPaintRegionType["BODY"] = 0] = "BODY";
            csRptPaintRegionType[csRptPaintRegionType["LEFT_UP"] = 1] = "LEFT_UP";
            csRptPaintRegionType[csRptPaintRegionType["LEFT_DOWN"] = 2] = "LEFT_DOWN";
            csRptPaintRegionType[csRptPaintRegionType["RIGHT_UP"] = 3] = "RIGHT_UP";
            csRptPaintRegionType[csRptPaintRegionType["RIGHT_DOWN"] = 4] = "RIGHT_DOWN";
            csRptPaintRegionType[csRptPaintRegionType["UP"] = 5] = "UP";
            csRptPaintRegionType[csRptPaintRegionType["DOWN"] = 6] = "DOWN";
            csRptPaintRegionType[csRptPaintRegionType["LEFT"] = 7] = "LEFT";
            csRptPaintRegionType[csRptPaintRegionType["RIGHT"] = 8] = "RIGHT";
        })(csRptPaintRegionType = CSReportPaint.csRptPaintRegionType || (CSReportPaint.csRptPaintRegionType = {}));
        let csEMoveTo;
        (function (csEMoveTo) {
            csEMoveTo[csEMoveTo["FIRSTPAGE"] = 1] = "FIRSTPAGE";
            csEMoveTo[csEMoveTo["NEXTPAGE"] = -1] = "NEXTPAGE";
            csEMoveTo[csEMoveTo["PREVIOUSPAGE"] = -2] = "PREVIOUSPAGE";
            csEMoveTo[csEMoveTo["LASTPAGE"] = -3] = "LASTPAGE";
        })(csEMoveTo = CSReportPaint.csEMoveTo || (CSReportPaint.csEMoveTo = {}));
        let csPDFQuality;
        (function (csPDFQuality) {
            csPDFQuality[csPDFQuality["PDFQUALITYFULL"] = 1] = "PDFQUALITYFULL";
            csPDFQuality[csPDFQuality["PDFQUALITYSMALL"] = 2] = "PDFQUALITYSMALL";
            csPDFQuality[csPDFQuality["PDFQUALITYMEDIUM"] = 3] = "PDFQUALITYMEDIUM";
        })(csPDFQuality = CSReportPaint.csPDFQuality || (CSReportPaint.csPDFQuality = {}));
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var cReport = CSReports.CSReportEngine.cReport;
        var cError = CSReports.CSKernelClient.cError;
        var RefWrapper = CSReports.CSKernelClient.RefWrapper;
        var cReportSectionLine = CSReports.CSReportEngine.cReportSectionLine;
        var cReportFormula = CSReports.CSReportEngine.cReportFormula;
        var csRptSectionType = CSReports.CSReportGlobals.csRptSectionType;
        var csRptControlType = CSReports.CSReportGlobals.csRptControlType;
        var csECtlAlignConst = CSReports.CSReportGlobals.csECtlAlignConst;
        var U = CSReports.CSOAPI.Utils;
        var cReportChartSequence = CSReports.CSReportEngine.cReportChartSequence;
        var RptGrpComparisonType = CSReports.CSReportGlobals.RptGrpComparisonType;
        var RptGrpOrderType = CSReports.CSReportGlobals.RptGrpOrderType;
        var CMouseWait = CSReports.CSKernelClient.CMouseWait;
        var DatabaseGlobals = CSReports.CSDatabase.DatabaseGlobals;
        var csRptWhenEval = CSReports.CSReportGlobals.csRptWhenEval;
        var csReportBorderType = CSReports.CSReportGlobals.csReportBorderType;
        var cPrintAPI = CSReports.CSReportEngine.cPrintAPI;
        var cReportLaunchInfo = CSReports.CSReportEngine.cReportLaunchInfo;
        var csETypeGrid = CSReports.CSReportPaint.csETypeGrid;
        var csRptPaintObjType = CSReports.CSReportPaint.csRptPaintObjType;
        var csRptPaintRegionType = CSReports.CSReportPaint.csRptPaintRegionType;
        var cReportPaint = CSReports.CSReportPaint.cReportPaint;
        var cReportPrint = CSReports.CSReportPaint.cReportPrint;
        var cWindow = CSReports.CSKernelClient.cWindow;
        var MessageBoxDefaultButton = CSReports.CSKernelClient.MessageBoxDefaultButton;
        var csAskEditResult = CSReports.CSKernelClient.csAskEditResult;
        var Exception = CSReports.CSOAPI.Exception;
        var Color = CSReports.CSDrawing.Color;
        var csRptLaunchAction = CSReports.CSReportGlobals.csRptLaunchAction;
        var Point = CSReports.CSDrawing.Point;
        var HorizontalAlignment = CSReports.CSReportGlobals.HorizontalAlignment;
        var P = CSReports.CSKernelClient.Callable;
        var csDataSourceType = CSReports.CSReportGlobals.csDataSourceType;
        var Cursor = CSReports.CSForms.Cursor;
        var MouseEventArgs = CSReports.CSForms.MouseEventArgs;
        var MouseButtons = CSReports.CSForms.MouseButtons;
        class cEditor {
            getId() {
                return this.getFileName() + "__" + this.__id;
            }
            constructor(fMain, editor, rule, report, editorTab) {
                this.fMain = null;
                this.editor = null;
                this.picRule = null;
                this.picReport = null;
                this.editorTab = null;
                this.reportFullPath = "";
                this.name = "";
                this.isNew = false;
                this.TOP_BODY = 10;
                this.LEFT_BODY = 0;
                this.MIN_HEIGHT_SECTION = 3;
                this.SECTION_LINE = "L ";
                this.RULE_WIDTH = 70;
                this.NO_MOVE = -1111111;
                this.report = null;
                this.paint = null;
                this.keyMoving = "";
                this.moveType = null;
                this.keySizing = "";
                this.offX = 0;
                this.offY = 0;
                this.keyObj = "";
                this.keyFocus = "";
                this.moving = false;
                this.opening = false;
                this.offSet = 0;
                this.indexSecLnMoved = 0;
                this.newSecLineOffSet = 0;
                this.bMoveVertical = false;
                this.bMoveHorizontal = false;
                this.bNoMove = false;
                this.vSelectedKeys = [];
                this.vCopyKeys = [];
                this.fProgress = null;
                this.cancelPrinting = false;
                this.formIndex = 0;
                this.fProperties = null;
                this.fSecProperties = null;
                this.nextNameCtrl = 0;
                this.showingProperties = false;
                this.dataHasChanged = false;
                this.copyControls = false;
                this.copyControlsFromOtherReport = false;
                this.bCopyWithoutMoving = false;
                this.dragging = false;
                this.controlName = "";
                this.controlType = null;
                this.fieldName = "";
                this.fieldType = 0;
                this.fieldIndex = 0;
                this.formulaText = "";
                this.x = 0;
                this.y = 0;
                this.keyboardMove = false;
                this.keyboardMoveStep = 5;
                this.inMouseDown = false;
                this.typeGrid = csETypeGrid.CSEGRIDPOINTS;
                this.zoom = 1;
                this.fMain = fMain;
                this.editor = editor;
                this.picRule = rule;
                this.picReport = report;
                this.editorTab = editorTab;
                this.editorTab.setTag(this);
                this.__id = cEditor.__nextId++;
            }
            close() {
                return this.saveChanges();
            }
            setPreviewTab(previewTab) {
                this.previewTab = previewTab;
            }
            getPreviewTab() {
                return this.previewTab;
            }
            isEditor() {
                return true;
            }
            getEditorTab() {
                return this.editorTab;
            }
            getVCopyKeys(idx) {
                return this.vCopyKeys[idx];
            }
            getVCopyKeysCount() {
                return this.vCopyKeys.length;
            }
            getPaint() {
                return this.paint;
            }
            setKeyboardMoveStep(rhs) {
                this.keyboardMoveStep = rhs;
            }
            moveIsLock() {
                return this.bNoMove;
            }
            getBMoveVertical() {
                return this.bMoveVertical;
            }
            getBMoveHorizontal() {
                return this.bMoveHorizontal;
            }
            getPaperSize() {
                if (this.report === null) {
                    return 0;
                }
                return this.report.getPaperInfo().getPaperSize();
            }
            getOrientation() {
                if (this.report === null) {
                    return 0;
                }
                return this.report.getPaperInfo().getOrientation();
            }
            getCopies() {
                if (this.report === null) {
                    return 0;
                }
                return this.report.getLaunchInfo().getCopies();
            }
            setPaperSize(rhs) {
                if (this.report === null)
                    return;
                this.report.getPaperInfo().setPaperSize(rhs);
            }
            setOrientation(rhs) {
                if (this.report === null)
                    return;
                this.report.getPaperInfo().setOrientation(rhs);
            }
            setCopies(rhs) {
                if (this.report === null)
                    return;
                this.report.getLaunchInfo().setCopies(rhs);
            }
            setCustomHeight(rhs) {
                if (this.report === null)
                    return;
                this.report.getPaperInfo().setCustomHeight(rhs);
            }
            setCustomWidth(rhs) {
                if (this.report === null)
                    return;
                this.report.getPaperInfo().setCustomWidth(rhs);
            }
            getCustomHeight() {
                if (this.report === null) {
                    return 0;
                }
                return this.report.getPaperInfo().getCustomHeight();
            }
            getCustomWidth() {
                if (this.report === null) {
                    return 0;
                }
                return this.report.getPaperInfo().getCustomWidth();
            }
            getFileName() {
                return this.report.getPath() + this.report.getName();
            }
            getShowingProperties() {
                return this.showingProperties;
            }
            setShowingProperties(rhs) {
                this.showingProperties = rhs;
            }
            getReport() {
                return this.report;
            }
            getDataHasChanged() {
                return this.dataHasChanged;
            }
            setDataHasChanged(rhs) {
                this.dataHasChanged = rhs;
            }
            getZoom() {
                return this.zoom;
            }
            setZoom(value) {
                this.zoom = value;
                this.reLoadReport();
            }
            moveVertical() {
                this.formKeyUp(Keys.F11, false);
            }
            moveHorizontal() {
                this.formKeyUp(Keys.F12, false);
            }
            moveNoMove() {
                this.formKeyUp(Keys.F9, false);
            }
            moveAll() {
                this.formKeyUp(Keys.F8, false);
            }
            showGrid(typeGrid) {
                this.typeGrid = typeGrid;
                return this.paint.initGrid(this.picReport.getGraphics(), typeGrid);
            }
            showConnectsAux() {
                try {
                    this.fMain.getConnectAuxDlg().clear();
                    for (let _i = 0; _i < this.report.getConnectsAux().count(); _i++) {
                        this.addConnectAuxToListView(this.report.getConnectsAux().item(_i));
                    }
                    return this.fMain.getConnectAuxDlg().showModal();
                }
                catch (ex) {
                    return cError.mngError(ex);
                }
            }
            addConnectAuxToListView(connect) {
                this.fMain.getConnectAuxDlg().addConnect(connect.getDataSource(), connect.getStrConnect());
            }
            removeConnectAuxFromListView(connect) {
                this.fMain.getConnectAuxDlg().removeConnect(connect.getDataSource());
            }
            keyUp(ev) {
                if (ev.target !== document.body)
                    return;
                this.formKeyUp(this.keyFromKey(ev.key), ev.ctrlKey);
                if (this.keyboardMove) {
                    this.keyboardMove = false;
                    this.picReportMouseUp(new MouseEventArgs(MouseButtons.Left, 0, this.x, this.y, 0), new Point(this.x, this.y));
                    ev.stopPropagation();
                    ev.preventDefault();
                }
            }
            formKeyUp(keyCode, ctrlKey) {
                switch (keyCode) {
                    case Keys.F2:
                        this.editText();
                        break;
                    case Keys.Delete:
                        this.deleteObj(false);
                        break;
                    case Keys.Escape:
                        this.endDragging();
                        break;
                    case Keys.F11:
                        this.bMoveVertical = true;
                        this.bMoveHorizontal = false;
                        CSReportEditor.cGlobals.setStatus();
                        break;
                    case Keys.F12:
                        this.bMoveHorizontal = true;
                        this.bMoveVertical = false;
                        CSReportEditor.cGlobals.setStatus();
                        break;
                    case Keys.F8:
                        this.bMoveHorizontal = false;
                        this.bMoveVertical = false;
                        CSReportEditor.cGlobals.setStatus();
                        break;
                    case Keys.F9:
                        this.bNoMove = !this.bNoMove;
                        CSReportEditor.cGlobals.setStatus();
                        break;
                    case Keys.C:
                        if (ctrlKey) {
                            this.copy();
                        }
                        break;
                    case Keys.V:
                        if (ctrlKey) {
                            this.paste(false);
                        }
                        break;
                    default:
                        return false;
                }
                return true;
            }
            setFocusCtrl(ctrlKey) {
                try {
                    this.selectCtrl(ctrlKey);
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            deleteConnection(rptConnect) {
                try {
                    for (let i = 0; i < this.report.getConnectsAux().size(); i++) {
                        if (this.report.getConnectsAux().item(i).getDataSource() === rptConnect.getDataSource()) {
                            this.report.getConnectsAux().remove(i);
                            break;
                        }
                    }
                    this.removeConnectAuxFromListView(rptConnect);
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            addConnection(rptConnect, serverConnection) {
                try {
                    return this.configConnection(rptConnect, serverConnection).then(P.call(this, (result) => {
                        if (result.success) {
                            this.report.getConnectsAux().add(rptConnect);
                            this.addConnectAuxToListView(rptConnect);
                        }
                        return result;
                    }));
                }
                catch (ex) {
                    return cError.mngError(ex);
                }
            }
            getSectionOrSectionLineFromKey(key) {
                let sec = cEditor.getSectionOrSectionLine(key, this.report.getHeaders());
                if (sec === null) {
                    sec = cEditor.getSectionOrSectionLine(key, this.report.getGroupsHeaders());
                    if (sec === null) {
                        sec = cEditor.getSectionOrSectionLine(key, this.report.getDetails());
                        if (sec === null) {
                            sec = cEditor.getSectionOrSectionLine(key, this.report.getGroupsFooters());
                            if (sec === null) {
                                sec = cEditor.getSectionOrSectionLine(key, this.report.getFooters());
                            }
                        }
                    }
                }
                return sec;
            }
            static getSectionOrSectionLine(key, sections) {
                for (let i = 0; i < sections.count(); i++) {
                    let sec = sections.item(i);
                    if (sec.getKey() === key) {
                        return sec;
                    }
                    else {
                        let secLn = sec.getSectionLines().item(key);
                        if (secLn !== null) {
                            return secLn;
                        }
                    }
                }
                return null;
            }
            selectCtrl(ctrlKey) {
                let bWasRemoved = new RefWrapper(false);
                let sKey = this.getReport().getControls().item(ctrlKey).getKeyPaint();
                this.vSelectedKeys = [];
                this.pAddToSelected(sKey, false, bWasRemoved);
                if (bWasRemoved.get()) {
                    sKey = "";
                }
                this.keyFocus = sKey;
                this.keyObj = sKey;
                this.paint.setFocus(this.keyFocus, this.picReport.getGraphics(), true);
                CSReportEditor.cMainEditor.showProperties(ctrlKey);
            }
            selectSection(secKey, bIsSecLn = new RefWrapper()) {
                try {
                    let bWasRemoved = new RefWrapper(false);
                    let sKey = "";
                    bIsSecLn.set(false);
                    this.vSelectedKeys = [];
                    if (this.report.getHeaders().item(secKey) !== null) {
                        sKey = this.report.getHeaders().item(secKey).getKeyPaint();
                    }
                    else if (this.report.getGroupsHeaders().item(secKey) !== null) {
                        sKey = this.report.getGroupsHeaders().item(secKey).getKeyPaint();
                    }
                    else if (this.report.getDetails().item(secKey) !== null) {
                        sKey = this.report.getDetails().item(secKey).getKeyPaint();
                    }
                    else if (this.report.getGroupsFooters().item(secKey) !== null) {
                        sKey = this.report.getGroupsFooters().item(secKey).getKeyPaint();
                    }
                    else if (this.report.getFooters().item(secKey) !== null) {
                        sKey = this.report.getFooters().item(secKey).getKeyPaint();
                    }
                    else {
                        let sec = new RefWrapper();
                        bIsSecLn.set(true);
                        let secLn = cEditor.getSecLnFromKey(secKey, this.report.getHeaders(), sec);
                        if (secLn !== null) {
                            sKey = secLn.getKeyPaint();
                            if (sKey === "") {
                                sKey = sec.get().getKeyPaint();
                            }
                        }
                        else {
                            secLn = cEditor.getSecLnFromKey(secKey, this.report.getGroupsHeaders(), sec);
                            if (secLn !== null) {
                                sKey = secLn.getKeyPaint();
                                if (sKey === "") {
                                    sKey = sec.get().getKeyPaint();
                                }
                            }
                            else {
                                secLn = cEditor.getSecLnFromKey(secKey, this.report.getDetails(), sec);
                                if (secLn !== null) {
                                    sKey = secLn.getKeyPaint();
                                    if (sKey === "") {
                                        sKey = sec.get().getKeyPaint();
                                    }
                                }
                                else {
                                    secLn = cEditor.getSecLnFromKey(secKey, this.report.getGroupsFooters(), sec);
                                    if (secLn !== null) {
                                        sKey = secLn.getKeyPaint();
                                        if (sKey === "") {
                                            sKey = sec.get().getKeyPaint();
                                        }
                                    }
                                    else {
                                        secLn = cEditor.getSecLnFromKey(secKey, this.report.getFooters(), sec);
                                        if (secLn !== null) {
                                            sKey = secLn.getKeyPaint();
                                            if (sKey === "") {
                                                sKey = sec.get().getKeyPaint();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (sKey === "")
                        return;
                    this.pAddToSelected(sKey, false, bWasRemoved);
                    if (bWasRemoved.get()) {
                        sKey = "";
                    }
                    this.keyFocus = sKey;
                    this.keyObj = sKey;
                    this.paint.setFocus(this.keyFocus, this.picReport.getGraphics(), true);
                    CSReportEditor.cMainEditor.showProperties("S" + secKey, true);
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            static getSecLnFromKey(secKey, sections, rtnSec) {
                let sec = null;
                rtnSec.set(null);
                for (let _i = 0; _i < sections.count(); _i++) {
                    sec = sections.item(_i);
                    if (sec.getSectionLines().item(secKey) !== null) {
                        rtnSec.set(sec);
                        return sec.getSectionLines().item(secKey);
                    }
                }
                return null;
            }
            checkSyntax(code) {
                let f = new cReportFormula();
                if (this.fProperties !== null) {
                    f.setName(this.fProperties.getFormulaName());
                }
                else if (this.fSecProperties !== null) {
                    f.setName(this.fSecProperties.getFormulaName());
                }
                else {
                    f.setName(CSReportEditor.cMainEditor.getCtrlTreeBox().getFormulaName());
                }
                f.setText(code);
                return this.report.getCompiler().checkSyntax(f);
            }
            showHelpChartField(ctrl, idx) {
                this.fMain.showDbFields(ctrl.getText(), this).then(P.call(this, (result) => {
                    if (result.success) {
                        ctrl.setText(result.field);
                        this.fProperties.setChartFieldType(idx, result.fieldType);
                        this.fProperties.setChartIndex(idx, result.fieldIndex);
                        return true;
                    }
                    else {
                        return false;
                    }
                }));
            }
            showHelpChartGroupField() {
                this.fMain.showDbFields(this.fProperties.getDbFieldGroupValue(), this).then(P.call(this, (result) => {
                    if (result.success) {
                        this.fProperties.setDbFieldGroupValue(result.field);
                        this.fProperties.setChartGroupFieldType(result.fieldType);
                        this.fProperties.setChartGroupIndex(result.fieldIndex);
                        return true;
                    }
                    else {
                        return false;
                    }
                }));
            }
            fSecProperties_UnloadForm() {
                this.fSecProperties = null;
            }
            fToolBox_AddControl(controlName, controlType, fieldName, formulaText, fieldType, fieldIndex) {
                this.beginDragging();
                this.controlName = controlName;
                this.controlType = controlType;
                this.fieldName = fieldName;
                this.formulaText = formulaText;
                this.fieldIndex = fieldIndex;
                this.fieldType = fieldType;
            }
            fTreeCtrls_UpdateFormulaHide(ctrlKey, formula) {
                this.report.getControls().item(ctrlKey).getFormulaHide().setText(formula);
            }
            fTreeCtrls_UpdateFormulaValue(ctrlKey, formula) {
                this.report.getControls().item(ctrlKey).getFormulaValue().setText(formula);
            }
            fTreeCtrls_UpdateSectionFormulaHide(secKey, formula) {
                if (this.report.getHeaders().item(secKey) !== null) {
                    this.report.getHeaders().item(secKey).getFormulaHide().setText(formula);
                }
                else if (this.report.getGroupsHeaders().item(secKey) !== null) {
                    this.report.getGroupsHeaders().item(secKey).getFormulaHide().setText(formula);
                }
                else if (this.report.getDetails().item(secKey) !== null) {
                    this.report.getDetails().item(secKey).getFormulaHide().setText(formula);
                }
                else if (this.report.getGroupsFooters().item(secKey) !== null) {
                    this.report.getGroupsFooters().item(secKey).getFormulaHide().setText(formula);
                }
                else if (this.report.getFooters().item(secKey) !== null) {
                    this.report.getFooters().item(secKey).getFormulaHide().setText(formula);
                }
                else {
                    let sec = new RefWrapper(null);
                    let secLn = cEditor.getSecLnFromKey(secKey, this.report.getHeaders(), sec);
                    if (secLn !== null) {
                        secLn.getFormulaHide().setText(formula);
                    }
                    else {
                        secLn = cEditor.getSecLnFromKey(secKey, this.report.getGroupsHeaders(), sec);
                        if (secLn !== null) {
                            secLn.getFormulaHide().setText(formula);
                        }
                        else {
                            secLn = cEditor.getSecLnFromKey(secKey, this.report.getDetails(), sec);
                            if (secLn !== null) {
                                secLn.getFormulaHide().setText(formula);
                            }
                            else {
                                secLn = cEditor.getSecLnFromKey(secKey, this.report.getGroupsFooters(), sec);
                                if (secLn !== null) {
                                    secLn.getFormulaHide().setText(formula);
                                }
                                else {
                                    secLn = cEditor.getSecLnFromKey(secKey, this.report.getFooters(), sec);
                                    if (secLn !== null) {
                                        secLn.getFormulaHide().setText(formula);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            keyDown(ev) {
                let keyCode = this.keyFromKey(ev.key);
                let shift = ev.shiftKey;
                let aspect = null;
                try {
                    switch (keyCode) {
                        case Keys.Up:
                            break;
                        case Keys.Down:
                            break;
                        case Keys.Left:
                            break;
                        case Keys.Right:
                            break;
                        default:
                            return;
                    }
                    ev.stopPropagation();
                    ev.preventDefault();
                    let x = 0;
                    let y = 0;
                    if (this.vSelectedKeys.length < 1)
                        return;
                    if (!this.keyboardMove) {
                        aspect = this.paint.getPaintObject(this.vSelectedKeys[0]).getAspect();
                        y = Math.trunc(aspect.getTop());
                        x = Math.trunc(aspect.getLeft());
                    }
                    else {
                        y = this.y;
                        x = this.x;
                    }
                    if (shift) {
                        if (this.keySizing === "") {
                            this.keySizing = this.paint.getPaintObject(this.vSelectedKeys[0]).getKey();
                        }
                        if (!this.keyboardMove) {
                            aspect = this.paint.getPaintObject(this.vSelectedKeys[0]).getAspect();
                            y += Math.trunc(aspect.getHeight());
                            x += Math.trunc(aspect.getWidth());
                            this.setMovingFromKeyboard(x, y);
                            if (this.keySizing === "") {
                                this.keySizing = this.paint.getPaintObject(this.vSelectedKeys[0]).getKey();
                            }
                            switch (keyCode) {
                                case Keys.Down:
                                case Keys.Up:
                                    this.keyMoving = "";
                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVDOWN;
                                    break;
                                case Keys.Right:
                                case Keys.Left:
                                    this.keyMoving = "";
                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHT;
                                    break;
                            }
                        }
                        switch (keyCode) {
                            case Keys.Up:
                                y = y - this.keyboardMoveStep;
                                break;
                            case Keys.Down:
                                y = y + this.keyboardMoveStep;
                                break;
                            case Keys.Left:
                                x = x - this.keyboardMoveStep;
                                break;
                            case Keys.Right:
                                x = x + this.keyboardMoveStep;
                                break;
                        }
                    }
                    else {
                        if (!this.keyboardMove) {
                            this.setMovingFromKeyboard(x, y);
                        }
                        if (this.keyMoving === "") {
                            this.keyMoving = this.paint.getPaintObject(this.vSelectedKeys[0]).getKey();
                        }
                        switch (keyCode) {
                            case Keys.Up:
                                y = y - this.keyboardMoveStep;
                                break;
                            case Keys.Down:
                                y = y + this.keyboardMoveStep;
                                break;
                            case Keys.Left:
                                x = x - this.keyboardMoveStep;
                                break;
                            case Keys.Right:
                                x = x + this.keyboardMoveStep;
                                break;
                        }
                    }
                    this.picReportMouseMove(new MouseEventArgs(MouseButtons.Left, 0, x, y, 0), new Point(this.x, this.y));
                    this.x = x;
                    this.y = y;
                    this.keyboardMove = true;
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            setMovingFromKeyboard(x, y) {
                this.keyMoving = this.keyFocus;
                let po = this.paint.getPaintObject(this.keyMoving);
                switch (po.getTag()) {
                    case CSReportEditor.cGlobals.KEY_DETAIL:
                    case CSReportEditor.cGlobals.KEY_FOOTER:
                    case CSReportEditor.cGlobals.KEY_HEADER:
                        this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                        this.picReport.setCursor(Cursor.SizeNS);
                        break;
                    default:
                        if (po.getRptType() === csRptSectionType.DETAIL
                            || po.getRptType() === csRptSectionType.HEADER
                            || po.getRptType() === csRptSectionType.GROUP_HEADER
                            || po.getRptType() === csRptSectionType.GROUP_FOOTER
                            || po.getRptType() === csRptSectionType.FOOTER) {
                            this.picReport.setCursor(Cursor.SizeNS);
                            this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                        }
                        else if (po.getRptType() === csRptSectionType.SECLN_HEADER
                            || po.getRptType() === csRptSectionType.SECLN_DETAIL
                            || po.getRptType() === csRptSectionType.SECLN_FOOTER
                            || po.getRptType() === csRptSectionType.SECLN_GROUPH
                            || po.getRptType() === csRptSectionType.SECLN_GROUPF) {
                            this.picReport.setCursor(Cursor.SizeNS);
                            this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                        }
                        else {
                            this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTALL;
                            this.picReport.setCursor(Cursor.SizeNS);
                        }
                        break;
                }
                let aspect = this.paint.getPaintObject(this.keyMoving).getAspect();
                this.offX = x - aspect.getLeft();
                this.offY = y - (aspect.getTop() - aspect.getOffset());
                this.keyObj = this.keyMoving;
                CSReportEditor.cGlobals.setEditAlignTextState(this.vSelectedKeys.length);
                CSReportEditor.cGlobals.setEditAlignCtlState(this.vSelectedKeys.length > 1);
                this.pSetEditAlignValue();
                this.pSetFontBoldValue();
            }
            picReportMouseDown(event, insidePos) {
                if (this.paint === null)
                    return;
                let button = event.buttons !== 0 ? event.button : -1;
                let ctrlKey = event.ctrlKey || event.shiftKey;
                let x = insidePos.x;
                let y = insidePos.y;
                try {
                    let sKey = "";
                    let lastKeyMoving = "";
                    let lastKeyObj = "";
                    if (this.opening)
                        return;
                    this.inMouseDown = true;
                    if (this.dragging) {
                        this.addControlEnd(x, y);
                        this.endDragging();
                    }
                    this.endEditText(false);
                    let bClearSelected = this.clearSelected(button, ctrlKey, x, y);
                    if (button === MouseButtons.Left) {
                        lastKeyObj = this.keyObj;
                        this.keyObj = "";
                        sKey = this.keyMoving !== "" ? this.keyMoving : this.keySizing;
                        if (sKey === "") {
                            const rsKey = new RefWrapper(sKey);
                            this.paint.pointIsInObject(x, y, rsKey);
                            sKey = rsKey.get();
                            if (sKey !== "") {
                                let po = this.paint.getPaintObject(sKey);
                                lastKeyMoving = this.keyMoving;
                                this.keyMoving = sKey;
                                switch (po.getTag()) {
                                    case CSReportEditor.cGlobals.KEY_DETAIL:
                                    case CSReportEditor.cGlobals.KEY_FOOTER:
                                    case CSReportEditor.cGlobals.KEY_HEADER:
                                        if (ctrlKey) {
                                            if (this.vSelectedKeys.length > 0)
                                                return;
                                            if (this.vSelectedKeys[0].length > 0)
                                                return;
                                            this.keyMoving = lastKeyMoving;
                                            this.keyObj = lastKeyObj;
                                            return;
                                        }
                                        this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                                        this.picReport.setCursor(Cursor.SizeNS);
                                        break;
                                    default:
                                        if (po.getRptType() === csRptSectionType.DETAIL
                                            || po.getRptType() === csRptSectionType.HEADER
                                            || po.getRptType() === csRptSectionType.GROUP_HEADER
                                            || po.getRptType() === csRptSectionType.GROUP_FOOTER
                                            || po.getRptType() === csRptSectionType.FOOTER) {
                                            if (ctrlKey) {
                                                if (this.vSelectedKeys.length > 0)
                                                    return;
                                                if (this.vSelectedKeys[0].length > 0)
                                                    return;
                                                this.keyMoving = lastKeyMoving;
                                                this.keyObj = lastKeyObj;
                                                return;
                                            }
                                            this.picReport.setCursor(Cursor.SizeNS);
                                            this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                                        }
                                        else if (po.getRptType() === csRptSectionType.SECLN_HEADER
                                            || po.getRptType() === csRptSectionType.SECLN_DETAIL
                                            || po.getRptType() === csRptSectionType.SECLN_FOOTER
                                            || po.getRptType() === csRptSectionType.SECLN_GROUPH
                                            || po.getRptType() === csRptSectionType.SECLN_GROUPF) {
                                            if (ctrlKey) {
                                                if (this.vSelectedKeys.length > 0)
                                                    return;
                                                if (this.vSelectedKeys[0].length > 0)
                                                    return;
                                                this.keyMoving = lastKeyMoving;
                                                this.keyObj = lastKeyObj;
                                                return;
                                            }
                                            this.picReport.setCursor(Cursor.SizeNS);
                                            this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                                        }
                                        else {
                                            this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTALL;
                                            this.picReport.setCursor(Cursor.MoveAll);
                                        }
                                        break;
                                }
                            }
                            else {
                                CSReportEditor.cMainEditor.clearProperties();
                            }
                        }
                        let bWasRemoved = new RefWrapper(false);
                        this.pAddToSelected(this.keyMoving, ctrlKey, bWasRemoved);
                        if (bWasRemoved.get()) {
                            sKey = "";
                        }
                        if (sKey !== "") {
                            let aspect = this.paint.getPaintObject(sKey).getAspect();
                            this.offX = x - aspect.getLeft();
                            this.offY = y - (aspect.getTop() - aspect.getOffset());
                        }
                        this.keyFocus = sKey;
                        this.keyObj = sKey;
                        this.paint.setFocus(this.keyFocus, this.picReport.getGraphics(), bClearSelected);
                        let poSelected = this.paint.getPaintObject(sKey);
                        if (poSelected !== null) {
                            const propertyKey = poSelected.getIsSection() ? "S" + poSelected.getTag() : poSelected.getTag();
                            CSReportEditor.cMainEditor.showProperties(propertyKey, poSelected.getIsSection() || poSelected.getIsSectionLine());
                        }
                    }
                    else if (button === MouseButtons.Right) {
                        this.keySizing = "";
                        this.keyMoving = "";
                        this.keyObj = "";
                        const rsKey = new RefWrapper(sKey);
                        if (this.paint.pointIsInObject(x, y, rsKey)) {
                            sKey = rsKey.get();
                            this.keyObj = sKey;
                            bClearSelected = this.setSelectForRightButton();
                            this.keyFocus = sKey;
                            this.paint.setFocus(this.keyFocus, this.picReport.getGraphics(), bClearSelected);
                            let po = this.paint.getPaintObject(sKey);
                            if (this.paint.paintObjIsSection(sKey)) {
                                let noDelete = false;
                                switch (po.getTag()) {
                                    case CSReportEditor.cGlobals.KEY_HEADER:
                                    case CSReportEditor.cGlobals.KEY_DETAIL:
                                    case CSReportEditor.cGlobals.KEY_FOOTER:
                                        noDelete = true;
                                        break;
                                    default:
                                        noDelete = false;
                                        break;
                                }
                                let isGroup = new RefWrapper(false);
                                let isSecLn = new RefWrapper(false);
                                this.getSection(isGroup, isSecLn);
                                if (isSecLn.get()) {
                                    noDelete = true;
                                }
                                this.showPopMenuSection(noDelete, isGroup.get(), x, y, event);
                                CSReportEditor.cMainEditor.showProperties("S" + po.getTag(), true);
                            }
                            else {
                                event.preventDefault && event.preventDefault();
                                event.stopPropagation && event.stopPropagation();
                                event.cancelBubble = true;
                                this.showPopMenuControl(true, x, y, event);
                                CSReportEditor.cMainEditor.showProperties(po.getTag());
                            }
                        }
                        else {
                            event.preventDefault && event.preventDefault();
                            event.stopPropagation && event.stopPropagation();
                            event.cancelBubble = true;
                            this.showPopMenuControl(false, x, y, event);
                        }
                    }
                    CSReportEditor.cGlobals.setEditAlignTextState(this.vSelectedKeys.length > 0);
                    CSReportEditor.cGlobals.setEditAlignCtlState(this.vSelectedKeys.length > 1);
                    this.pSetEditAlignValue();
                    this.pSetFontBoldValue();
                }
                catch (ex) {
                    cError.mngError(ex);
                }
                finally {
                    this.inMouseDown = false;
                }
            }
            setFontBold() {
                let bBold = -2;
                let bBoldValue;
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    let font = this.paint.getPaintObject(this.vSelectedKeys[i]).getAspect().getFont();
                    if (bBold === -2) {
                        bBold = font.getBold() ? -1 : 0;
                    }
                    else if (bBold !== (font.getBold() ? -1 : 0)) {
                        bBold = -2;
                        break;
                    }
                }
                if (bBold === -2) {
                    bBoldValue = true;
                }
                else {
                    bBoldValue = bBold === 0;
                }
                let paintObject = null;
                let rptCtrl = null;
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    paintObject = this.paint.getPaintObject(this.vSelectedKeys[i]);
                    rptCtrl = this.report.getControls().item(paintObject.getTag());
                    rptCtrl.getLabel().getAspect().getFont().setBold(bBoldValue);
                    paintObject.getAspect().getFont().setBold(bBoldValue);
                }
                this.dataHasChanged = true;
                this.refreshAll();
                this.pSetFontBoldValue();
            }
            pSetFontBoldValue() {
                let bBold = -2;
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    let font = this.paint.getPaintObject(this.vSelectedKeys[i]).getAspect().getFont();
                    if (bBold === -2) {
                        bBold = font.getBold() ? -1 : 0;
                    }
                    else if (bBold !== (font.getBold() ? -1 : 0)) {
                        bBold = -2;
                        break;
                    }
                }
                CSReportEditor.cGlobals.setEditFontBoldValue(bBold);
            }
            controlsAlign(align) {
                let paintObject = null;
                let rptCtrl = null;
                let aspect = null;
                let top = 0;
                let left = 0;
                let newTop = 0;
                let newLeft = 0;
                let height = 0;
                let width = 0;
                switch (align) {
                    case csECtlAlignConst.csECtlAlignHeight:
                    case csECtlAlignConst.csECtlAlignWidth:
                        aspect = this.paint.getPaintObject(this.vSelectedKeys[0]).getAspect();
                        height = aspect.getHeight();
                        width = aspect.getWidth();
                        break;
                    case csECtlAlignConst.csECtlAlignVertical:
                    case csECtlAlignConst.csECtlAlignHorizontal:
                        aspect = this.paint.getPaintObject(this.vSelectedKeys[0]).getAspect();
                        newTop = aspect.getTop();
                        newLeft = aspect.getLeft();
                        break;
                    default:
                        switch (align) {
                            case csECtlAlignConst.csECtlAlignLeft:
                                newLeft = 100000;
                                break;
                            case csECtlAlignConst.csECtlAlignRight:
                                newLeft = 0;
                                break;
                            case csECtlAlignConst.csECtlAlignTop:
                                newTop = 100000;
                                break;
                            case csECtlAlignConst.csECtlAlignBottom:
                                newTop = 0;
                                break;
                        }
                        for (let i = 0; i < this.vSelectedKeys.length; i++) {
                            aspect = this.paint.getPaintObject(this.vSelectedKeys[i]).getAspect();
                            top = aspect.getTop();
                            left = aspect.getLeft();
                            switch (align) {
                                case csECtlAlignConst.csECtlAlignLeft:
                                    if (left < newLeft) {
                                        newLeft = left;
                                    }
                                    break;
                                case csECtlAlignConst.csECtlAlignRight:
                                    if (left > newLeft) {
                                        newLeft = left;
                                    }
                                    break;
                                case csECtlAlignConst.csECtlAlignTop:
                                    if (top < newTop) {
                                        newTop = top;
                                    }
                                    break;
                                case csECtlAlignConst.csECtlAlignBottom:
                                    if (top > newTop) {
                                        newTop = top;
                                    }
                                    break;
                            }
                        }
                        break;
                }
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    paintObject = this.paint.getPaintObject(this.vSelectedKeys[i]);
                    rptCtrl = this.report.getControls().item(paintObject.getTag());
                    switch (align) {
                        case csECtlAlignConst.csECtlAlignHeight:
                            rptCtrl.getLabel().getAspect().setHeight(height);
                            paintObject.getAspect().setHeight(height);
                            break;
                        case csECtlAlignConst.csECtlAlignWidth:
                            rptCtrl.getLabel().getAspect().setWidth(width);
                            paintObject.getAspect().setWidth(width);
                            break;
                        case csECtlAlignConst.csECtlAlignLeft:
                        case csECtlAlignConst.csECtlAlignRight:
                        case csECtlAlignConst.csECtlAlignHorizontal:
                            rptCtrl.getLabel().getAspect().setLeft(newLeft);
                            paintObject.getAspect().setLeft(newLeft);
                            break;
                        case csECtlAlignConst.csECtlAlignTop:
                        case csECtlAlignConst.csECtlAlignBottom:
                        case csECtlAlignConst.csECtlAlignVertical:
                            rptCtrl.getLabel().getAspect().setTop(newTop);
                            paintObject.getAspect().setTop(newTop);
                            break;
                    }
                }
                this.dataHasChanged = true;
                this.refreshAll();
            }
            textAlign(align) {
                let paintObject = null;
                let rptCtrl = null;
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    paintObject = this.paint.getPaintObject(this.vSelectedKeys[i]);
                    rptCtrl = this.report.getControls().item(paintObject.getTag());
                    rptCtrl.getLabel().getAspect().setAlign(align);
                    paintObject.getAspect().setAlign(align);
                }
                this.dataHasChanged = true;
                this.refreshAll();
                this.pSetEditAlignValue();
            }
            pSetEditAlignValue() {
                let align = -1;
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    let aspect = this.paint.getPaintObject(this.vSelectedKeys[i]).getAspect();
                    if (align === -1) {
                        align = aspect.getAlign();
                    }
                    else if (align !== aspect.getAlign()) {
                        align = -2;
                        break;
                    }
                }
                CSReportEditor.cGlobals.setEditAlignValue(align);
            }
            pAddToSelected(sKey, ctrlKey, bWasRemoved) {
                bWasRemoved.set(false);
                if (sKey === "")
                    return;
                if (ctrlKey) {
                    for (let i = 0; i < this.vSelectedKeys.length; i++) {
                        if (this.vSelectedKeys[i] === sKey) {
                            this.pRemoveFromSelected(sKey);
                            bWasRemoved.set(true);
                            return;
                        }
                    }
                }
                else {
                    if (this.alreadySelected(sKey))
                        return;
                }
                this.vSelectedKeys.push(sKey);
            }
            alreadySelected(sKey) {
                if (sKey === "") {
                    return true;
                }
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    if (this.vSelectedKeys[i] === sKey) {
                        return true;
                    }
                }
                return false;
            }
            pRemoveFromSelected(sKey) {
                let i;
                for (i = 0; i < this.vSelectedKeys.length; i++) {
                    if (this.vSelectedKeys[i] === sKey) {
                        break;
                    }
                }
                if (i > this.vSelectedKeys.length)
                    return;
                for (i = i + 1; i < this.vSelectedKeys.length; i++) {
                    this.vSelectedKeys[i - 1] = this.vSelectedKeys[i];
                }
                if (this.vSelectedKeys.length > 0) {
                    this.vSelectedKeys;
                }
                else {
                    this.vSelectedKeys = [];
                }
                this.paint.removeFromSelected(sKey, this.picReport.getGraphics());
            }
            clearSelected(button, ctrlKey, x, y) {
                if (!ctrlKey && button !== MouseButtons.Right) {
                    let sKey = new RefWrapper("");
                    this.paint.pointIsInObject(x, y, sKey);
                    for (let i = 0; i < this.vSelectedKeys.length; i++) {
                        if (this.vSelectedKeys[i] === sKey.get()) {
                            return false;
                        }
                    }
                    this.vSelectedKeys = [];
                    return true;
                }
                return false;
            }
            showMoveAll(x, y) {
                let i = 0;
                let offsetTop = 0;
                let offsetLeft = 0;
                let firstLeft = 0;
                let firstTop = 0;
                let clear = false;
                let offSet2 = 0;
                if (this.vSelectedKeys.length === 0)
                    return;
                let aspect = this.paint.getPaintObject(this.keyMoving).getAspect();
                firstLeft = aspect.getLeft();
                firstTop = aspect.getTop();
                clear = true;
                for (i = this.vSelectedKeys.length - 1; i > -1; i--) {
                    aspect = this.paint.getPaintObject(this.vSelectedKeys[i]).getAspect();
                    offsetLeft = cEditor.getOffsetLeftFromControls(firstLeft, aspect.getLeft());
                    offsetTop = cEditor.getOffsetTopFromControls(firstTop, aspect.getTop());
                    offSet2 = aspect.getOffset();
                    if (this.bMoveHorizontal) {
                        this.paint.moveObjToXYEx(this.keyMoving, x - this.offX + offsetLeft, firstTop - offSet2 + offsetTop, this.picReport.getGraphics(), clear);
                    }
                    else if (this.bMoveVertical) {
                        this.paint.moveObjToXYEx(this.keyMoving, firstLeft + offsetLeft, y - this.offY + offsetTop, this.picReport.getGraphics(), clear);
                    }
                    else {
                        this.paint.moveObjToXYEx(this.keyMoving, x - this.offX + offsetLeft, y - this.offY + offsetTop, this.picReport.getGraphics(), clear);
                    }
                    if (clear) {
                        clear = false;
                    }
                }
            }
            picReportMouseMove(event, insidePos) {
                if (this.paint === null)
                    return;
                let button = event.buttons !== 0 ? event.button : -1;
                let x = insidePos.x;
                let y = insidePos.y;
                let sKey = "";
                let rgnTp = new RefWrapper(csRptPaintRegionType.BODY);
                if (this.dragging)
                    return;
                if (this.inMouseDown)
                    return;
                if (button === MouseButtons.Left) {
                    this.paint.beginMove();
                    if (this.keyMoving !== "") {
                        switch (this.moveType) {
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTALL:
                                this.showMoveAll(x, y);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTHORIZONTAL:
                                this.paint.moveHorizontal(this.keyMoving, x - this.offX, this.picReport.getGraphics());
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL:
                                this.paint.moveVertical(this.keyMoving, y - this.offY, this.picReport.getGraphics());
                                break;
                        }
                        this.moving = true;
                    }
                    else if (this.keySizing !== "") {
                        switch (this.moveType) {
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVDOWN:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE, y / this.zoom);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFT:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, x / this.zoom, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHT:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE, x / this.zoom, CSReportEditor.cGlobals.NO_CHANGE);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVUP:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, CSReportEditor.cGlobals.NO_CHANGE, y / this.zoom, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTDOWN:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, x / this.zoom, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE, y / this.zoom);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTUP:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, x / this.zoom, y / this.zoom, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTDOWN:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, CSReportEditor.cGlobals.NO_CHANGE, CSReportEditor.cGlobals.NO_CHANGE, x / this.zoom, y / this.zoom);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTUP:
                                this.paint.resize(this.picReport.getGraphics(), this.keySizing, CSReportEditor.cGlobals.NO_CHANGE, y / this.zoom, x / this.zoom, CSReportEditor.cGlobals.NO_CHANGE);
                                break;
                        }
                        this.moving = true;
                    }
                    else {
                        this.moving = false;
                    }
                }
                else {
                    if (this.keyFocus !== "") {
                        sKey = this.keyFocus;
                        const keyFocus = new RefWrapper(this.keyFocus);
                        if (this.paint.pointIsInThisObject(x, y, keyFocus, rgnTp)) {
                            const keyFocus = new RefWrapper(this.keyFocus);
                            this.keyFocus = keyFocus.get();
                            let po = this.paint.getPaintObject(sKey);
                            let ctrl = this.report.getControls().item(po.getTag());
                            this.setStatusBarText(ctrl.getName(), ctrl.getControlType(), ctrl.getFormulaHide().getText(), ctrl.getFormulaValue().getText(), ctrl.getHasFormulaHide(), ctrl.getHasFormulaValue(), ctrl.getField().getName());
                            if (po.getPaintType() === csRptPaintObjType.PAINT_OBJ_LINE) {
                                this.keyMoving = sKey;
                                this.keySizing = "";
                                this.picReport.setCursor(Cursor.SizeNS);
                            }
                            else {
                                switch (po.getTag()) {
                                    case CSReportEditor.cGlobals.KEY_DETAIL:
                                    case CSReportEditor.cGlobals.KEY_FOOTER:
                                    case CSReportEditor.cGlobals.KEY_HEADER:
                                        this.keyMoving = sKey;
                                        this.keySizing = "";
                                        this.picReport.setCursor(Cursor.SizeNS);
                                        this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                                        break;
                                    default:
                                        if (po.getRptType() === csRptSectionType.DETAIL
                                            || po.getRptType() === csRptSectionType.HEADER
                                            || po.getRptType() === csRptSectionType.GROUP_HEADER
                                            || po.getRptType() === csRptSectionType.GROUP_FOOTER
                                            || po.getRptType() === csRptSectionType.FOOTER) {
                                            this.keyMoving = sKey;
                                            this.keySizing = "";
                                            this.picReport.setCursor(Cursor.SizeNS);
                                            this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL;
                                        }
                                        else {
                                            switch (rgnTp.get()) {
                                                case csRptPaintRegionType.BODY:
                                                    this.picReport.setCursor(Cursor.MoveAll);
                                                    this.keyMoving = sKey;
                                                    this.keySizing = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTALL;
                                                    break;
                                                case csRptPaintRegionType.DOWN:
                                                    this.picReport.setCursor(Cursor.SizeNS);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVDOWN;
                                                    break;
                                                case csRptPaintRegionType.UP:
                                                    this.picReport.setCursor(Cursor.SizeNS);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVUP;
                                                    break;
                                                case csRptPaintRegionType.LEFT:
                                                    this.picReport.setCursor(Cursor.SizeEW);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFT;
                                                    break;
                                                case csRptPaintRegionType.RIGHT:
                                                    this.picReport.setCursor(Cursor.SizeEW);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHT;
                                                    break;
                                                case csRptPaintRegionType.LEFT_DOWN:
                                                    this.picReport.setCursor(Cursor.SizeNESW);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTDOWN;
                                                    break;
                                                case csRptPaintRegionType.RIGHT_UP:
                                                    this.picReport.setCursor(Cursor.SizeNESW);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTUP;
                                                    break;
                                                case csRptPaintRegionType.RIGHT_DOWN:
                                                    this.picReport.setCursor(Cursor.SizeNWSE);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTDOWN;
                                                    break;
                                                case csRptPaintRegionType.LEFT_UP:
                                                    this.picReport.setCursor(Cursor.SizeNWSE);
                                                    this.keySizing = sKey;
                                                    this.keyMoving = "";
                                                    this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTUP;
                                                    break;
                                                default:
                                                    this.keySizing = "";
                                                    this.keyMoving = "";
                                                    break;
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                        else {
                            this.setStatusBarText("");
                            this.picReport.setCursor(Cursor.Default);
                            this.keySizing = "";
                            this.keyMoving = "";
                        }
                    }
                    const rsKey = new RefWrapper(sKey);
                    if (this.paint.pointIsInObject(x, y, rsKey, rgnTp)) {
                        sKey = rsKey.get();
                        let po = this.paint.getPaintObject(sKey);
                        if (po.getRptType() === csRptSectionType.CONTROL) {
                            let rptCtrl = this.report.getControls().item(po.getTag());
                            if (rptCtrl !== null) {
                                this.setStatusBarText(rptCtrl.getName(), rptCtrl.getControlType(), rptCtrl.getFormulaHide().getText(), rptCtrl.getFormulaValue().getText(), rptCtrl.getHasFormulaHide(), rptCtrl.getHasFormulaValue(), rptCtrl.getField().getName());
                            }
                        }
                        else {
                            this.setStatusBarText("");
                        }
                    }
                    else {
                        this.setStatusBarText("");
                    }
                }
            }
            setStatusBarText(ctrlName, ctrlType = csRptControlType.RPT_CT_LABEL, formulaHide = "", formulaValue = "", hasFormulaHide = false, hasFormulaValue = false, fieldName = "") {
                let msg = "";
                let strCtlType = "";
                switch (ctrlType) {
                    case csRptControlType.RPT_CT_DB_IMAGE:
                        strCtlType = "DbImage";
                        break;
                    case csRptControlType.RPT_CT_FIELD:
                        strCtlType = "Field";
                        break;
                    case csRptControlType.RPT_CT_IMAGE:
                        strCtlType = "Image";
                        break;
                    case csRptControlType.RPT_CT_LABEL:
                        strCtlType = "Label";
                        break;
                }
                if (ctrlName !== "") {
                    msg = "Ctl:[" + ctrlName
                        + "]Tipo:[" + strCtlType
                        + "]F.Hide:[" + formulaHide.substring(0, 100)
                        + "]Activa[" + hasFormulaHide.toString()
                        + "]F.Value:[" + formulaValue.substring(0, 100)
                        + "]Activa[" + hasFormulaValue.toString()
                        + "]Field:[" + fieldName + "]";
                }
                this.fMain.setStatusBarText(msg);
            }
            picReportMouseUp(event, insidePos) {
                if (this.paint === null)
                    return;
                let x = insidePos.x;
                let y = insidePos.y;
                if (this.opening)
                    return;
                if (this.moving) {
                    if (this.keyMoving !== "") {
                        switch (this.moveType) {
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTALL:
                                if (this.bMoveVertical) {
                                    this.pMoveAll(this.NO_MOVE, y);
                                }
                                else if (this.bMoveHorizontal) {
                                    this.pMoveAll(x, this.NO_MOVE);
                                }
                                else {
                                    this.pMoveAll(x, y);
                                }
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTHORIZONTAL:
                                this.pMoveHorizontal(x);
                                break;
                            case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTVERTICAL:
                                this.pMoveVertical(x, y);
                                break;
                        }
                    }
                    else if (this.keySizing !== "") {
                        this.pResizeControl(x, y);
                    }
                    this.refreshBody();
                    this.moving = false;
                    this.refreshRule();
                }
                this.keySizing = "";
                this.keyMoving = "";
            }
            setParamsAndExecute(serverConnection) {
                let connect = new CSReports.CSConnect.cConnect();
                for (let _i = 0; _i < this.report.getConnect().getParameters().count(); _i++) {
                    let param = this.report.getConnect().getParameters().item(_i);
                    let connectParam = connect.getParameters().add(null, "");
                    connectParam.setName(param.getName());
                    connectParam.setValue(param.getValue());
                }
                if (this.report.getConnect().getDataSource() === "") {
                    cWindow.msgWarning("Before editing the parameter info you must define a connection");
                    return;
                }
                connect.setStrConnect(this.report.getConnect().getStrConnect());
                connect.setDataSource(this.report.getConnect().getDataSource());
                connect.setDataSourceType(this.report.getConnect().getDataSourceType());
                return connect.getDataSourceColumnsInfo(serverConnection).then(P.call(this, (result) => {
                    if (result.success)
                        CSReportEditor.cGlobals.setParametersAux(connect, this.report.getConnect());
                    let p = P._([result]);
                    for (let i = 0; i < this.report.getConnectsAux().size(); i++) {
                        let rptConnect = this.report.getConnectsAux().item(i);
                        connect = new CSReports.CSConnect.cConnect();
                        for (let _i = 0; _i < rptConnect.getParameters().count(); _i++) {
                            let param = rptConnect.getParameters().item(_i);
                            let connectParam = connect.getParameters().add(null, "");
                            connectParam.setName(param.getName());
                            connectParam.setValue(param.getValue());
                        }
                        connect.setStrConnect(rptConnect.getStrConnect());
                        connect.setDataSource(rptConnect.getDataSource());
                        connect.setDataSourceType(rptConnect.getDataSourceType());
                        p = p.then(P.call(this, this.loadAdditionalConnection(connect, serverConnection, rptConnect)));
                    }
                    return p;
                }));
            }
            loadAdditionalConnection(connect, serverConnection, rptConnect) {
                return (results) => {
                    return connect.getDataSourceColumnsInfo(serverConnection).then(P.call(this, (result) => {
                        if (result.success)
                            CSReportEditor.cGlobals.setParametersAux(connect, rptConnect);
                        results.push(result);
                        return results;
                    }));
                };
            }
            setSimpleConnection() {
                let f = new CSReportEditor.FSimpleConnect();
                try {
                    let strConnect = "";
                    strConnect = this.report.getConnect().getStrConnect();
                    f.setServer(U.getToken("Data Source", strConnect));
                    f.setDataBase(U.getToken("Initial Catalog", strConnect));
                    f.setUser(U.getToken("User ID", strConnect));
                    f.setPassword(U.getToken("Password", strConnect));
                    if (f.getUser() === "") {
                        f.setConnectTypeToNT();
                    }
                    else {
                        f.setConnectTypeToSQL();
                    }
                    f.showDialog();
                    if (!f.getOk()) {
                        f.close();
                    }
                    else {
                        this.report.getConnect().setStrConnect(f.getStrConnect());
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                    f.close();
                }
            }
            configConnection(rptConnect, serverConnection) {
                try {
                    let connect = new CSReports.CSConnect.cConnect();
                    connect.setDataSource(rptConnect.getDataSource());
                    return connect.getDataSourceColumnsInfo(serverConnection).then(P.call(this, (result) => {
                        if (result.success)
                            CSReportEditor.cGlobals.setParametersAux(connect, rptConnect);
                        return result;
                    }));
                }
                catch (ex) {
                    return cError.mngError(ex);
                }
            }
            setAllConnectToMainConnect() {
                try {
                    let connect = null;
                    for (let _i = 0; _i < this.report.getConnectsAux().count(); _i++) {
                        connect = this.report.getConnectsAux().item(_i);
                        connect.setStrConnect(this.report.getConnect().getStrConnect());
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            deleteObj(bDelSectionLine) {
                let sec = null;
                let secs = new RefWrapper(null);
                let secLn = new RefWrapper(null);
                let ctrl = null;
                let paintObj = null;
                let isGroupFooter = new RefWrapper(false);
                let isGroupHeader = new RefWrapper(false);
                let isSecLn = new RefWrapper(false);
                if (this.keyFocus === "")
                    return;
                let group = null;
                let secG = null;
                if (this.paint.paintObjIsSection(this.keyFocus)) {
                    if (this.paint.getPaintSections().item(this.keyFocus) === null)
                        return;
                    let po = this.paint.getPaintSections().item(this.keyFocus);
                    sec = this.getSection2(isSecLn, secLn, false, isGroupHeader, isGroupFooter);
                    if (!isSecLn.get()) {
                        if (bDelSectionLine) {
                            sec = this.getSection2(isSecLn, secLn, true, isGroupHeader, isGroupFooter);
                        }
                        if (!this.canDeleteSection(secs, sec, po.getTag()))
                            return;
                    }
                    let what;
                    if (isSecLn.get()) {
                        what = "the section line";
                    }
                    else {
                        what = "the section";
                    }
                    return cWindow.ask("Are yuo sure you want to delete "
                        + what + " and all the controls it contains? ", MessageBoxDefaultButton.Button2).then((answer) => {
                        if (!answer)
                            return;
                        if (isSecLn) {
                            for (let _i = 0; _i < secLn.get().getControls().count(); _i++) {
                                ctrl = secLn.get().getControls().item(_i);
                                for (let i = 0; i < this.paint.getPaintObjects().count(); i++) {
                                    paintObj = this.paint.getPaintObjects().item(i);
                                    if (paintObj.getTag() === ctrl.getKey()) {
                                        this.paint.getPaintObjects().remove(paintObj.getKey());
                                        break;
                                    }
                                }
                            }
                            secLn.get().getControls().clear();
                            if (sec.getSectionLines().count() > 1) {
                                sec.getSectionLines().remove(secLn.get().getKey());
                            }
                        }
                        else {
                            for (let _i = 0; _i < sec.getSectionLines().count(); _i++) {
                                secLn.set(sec.getSectionLines().item(_i));
                                for (let _j = 0; _j < secLn.get().getControls().count(); _j++) {
                                    ctrl = secLn.get().getControls().item(_j);
                                    for (let i = 0; i < this.paint.getPaintObjects().count(); i++) {
                                        paintObj = this.paint.getPaintObjects().item(i);
                                        if (paintObj.getTag() === ctrl.getKey()) {
                                            this.paint.getPaintObjects().remove(paintObj.getKey());
                                            break;
                                        }
                                    }
                                }
                            }
                            if (isGroupFooter || isGroupHeader) {
                                if (isGroupHeader) {
                                    for (let _i = 0; _i < this.report.getGroups().count(); _i++) {
                                        group = this.report.getGroups().item(_i);
                                        if (group.getHeader().getKey() === sec.getKey()) {
                                            break;
                                        }
                                    }
                                    secG = group.getFooter();
                                }
                                else if (isGroupFooter) {
                                    for (let _i = 0; _i < this.report.getGroups().count(); _i++) {
                                        group = this.report.getGroups().item(_i);
                                        if (group.getFooter().getKey() === sec.getKey()) {
                                            break;
                                        }
                                    }
                                    secG = group.getHeader();
                                }
                                for (let _i = 0; _i < secG.getSectionLines().count(); _i++) {
                                    secLn.set(secG.getSectionLines().item(_i));
                                    for (let _j = 0; _j < secLn.get().getControls().count(); _j++) {
                                        ctrl = secLn.get().getControls().item(_j);
                                        for (let i = 0; i < this.paint.getPaintObjects().count(); i++) {
                                            paintObj = this.paint.getPaintObjects().item(i);
                                            if (paintObj.getTag() === ctrl.getKey()) {
                                                this.paint.getPaintObjects().remove(paintObj.getKey());
                                                break;
                                            }
                                        }
                                    }
                                }
                                for (let i = 0; i < this.paint.getPaintSections().count(); i++) {
                                    paintObj = this.paint.getPaintSections().item(i);
                                    if (paintObj.getTag() === secG.getKey()) {
                                        this.paint.getPaintSections().remove(paintObj.getKey());
                                        break;
                                    }
                                }
                                if (group === null) {
                                    throw new Exception("group is null");
                                }
                                this.report.getGroups().remove(group.getIndex());
                            }
                            else {
                                if (secs === null) {
                                    throw new Exception("secs is null");
                                }
                                secs.get().remove(sec.getKey());
                            }
                        }
                        let bDeletePaintObj = true;
                        if (isSecLn) {
                            bDeletePaintObj = sec.getKeyPaint() !== this.keyFocus;
                        }
                        if (bDeletePaintObj) {
                            this.paint.getPaintSections().remove(this.keyFocus);
                        }
                        else {
                            let secLns = sec.getSectionLines();
                            this.paint.getPaintSections().remove(secLns.item(secLns.count() - 1).getKeyPaint());
                            secLns.item(secLns.count() - 1).setKeyPaint(sec.getKeyPaint());
                        }
                        this.pResetKeysFocus();
                        this.vSelectedKeys = [];
                        this.validateSectionAspect();
                        this.updateSectionNameInPaintObjects();
                        this.refreshAll();
                    });
                }
                else {
                    paintObj = this.paint.getPaintObjects().item(this.keyFocus);
                    if (paintObj === null)
                        return;
                    if (!cWindow.ask("Confirm you want to delete the control? ", MessageBoxDefaultButton.Button2))
                        return;
                    for (let i = 0; i < this.vSelectedKeys.length; i++) {
                        paintObj = this.paint.getPaintObjects().item(this.vSelectedKeys[i]);
                        ctrl = this.report.getControls().item(paintObj.getTag());
                        this.paint.getPaintObjects().remove(paintObj.getKey());
                        if (ctrl === null)
                            return;
                        ctrl.getSectionLine().getControls().remove(ctrl.getKey());
                    }
                    this.pResetKeysFocus();
                    this.vSelectedKeys = [];
                }
                this.refreshAll();
                return Promise.resolve();
            }
            updateSectionNameInPaintObjects() {
                this.updateSectionNameInPaintObjectsAux(this.report.getHeaders());
                this.updateSectionNameInPaintObjectsAux(this.report.getFooters());
                this.updateSectionNameInPaintObjectsAux(this.report.getDetails());
                this.updateSectionNameInPaintObjectsAux(this.report.getGroupsHeaders());
                this.updateSectionNameInPaintObjectsAux(this.report.getGroupsFooters());
            }
            updateSectionNameInPaintObjectsAux(sections) {
                for (let i = 0; i < sections.count(); i++) {
                    let sec = sections.item(i);
                    let paintObj = this.paint.getPaintSections().item(sec.getKeyPaint());
                    if (paintObj !== null) {
                        paintObj.setText(sec.getName());
                    }
                }
            }
            canDeleteSection(secs, sec, tag) {
                let secAux = this.report.getHeaders().item(tag);
                secs.set(null);
                if (secAux !== null) {
                    if (secAux === sec || sec === null) {
                        if (secAux.getTypeSection() === csRptSectionType.MAIN_HEADER) {
                            return cWindow.msgInfo("The main header can't be deleted").then(() => {
                                return false;
                            });
                        }
                        secs.set(this.report.getHeaders());
                    }
                }
                if (secs.get() === null) {
                    secAux = this.report.getFooters().item(tag);
                    if (secAux !== null) {
                        if (secAux === sec || sec === null) {
                            if (secAux.getTypeSection() === csRptSectionType.MAIN_FOOTER) {
                                cWindow.msgInfo("The main footer can't be deleted");
                                return false;
                            }
                            secs.set(this.report.getFooters());
                        }
                    }
                    if (secs.get() === null) {
                        secAux = this.report.getGroupsHeaders().item(tag);
                        if (secAux !== null) {
                            if (!((secAux === sec || sec === null))) {
                                secAux = this.report.getGroupsFooters().item(tag);
                                if (secAux !== null) {
                                    if (!(secAux === sec || sec === null)) {
                                        cWindow.msgInfo("The detail section can't be deleted");
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
                return true;
            }
            pResetKeysFocus() {
                this.keyFocus = "";
                this.keyMoving = "";
                this.keySizing = "";
                this.picReport.setCursor(Cursor.Default);
            }
            addDBField() {
                this.fMain.showDbFields("", this).then(P.call(this, (result) => {
                    if (result.success) {
                        this.beginDragging();
                        this.controlName = "";
                        this.controlType = CSReportEditor.csRptEditCtrlType.field;
                        this.fieldName = result.field;
                        this.formulaText = "";
                        this.fieldIndex = result.fieldIndex;
                        this.fieldType = result.fieldType;
                    }
                }));
            }
            addLabel() {
                this.pAddLabelAux(CSReportEditor.csRptEditCtrlType.label);
            }
            addLineLabel() {
                this.pAddLabelAux(CSReportEditor.csRptEditCtrlType.lineLabel);
            }
            addImage() {
                this.pAddLabelAux(CSReportEditor.csRptEditCtrlType.image);
            }
            addChart() {
                this.pAddLabelAux(CSReportEditor.csRptEditCtrlType.chart);
            }
            pAddLabelAux(ctrlType) {
                this.beginDragging();
                this.controlName = "";
                this.controlType = ctrlType;
                this.fieldName = "";
                this.formulaText = "";
                this.fieldIndex = 0;
                this.fieldType = 0;
            }
            addControlEnd(left, top) {
                this.dragging = false;
                left /= this.zoom;
                top /= this.zoom;
                if (this.controlType === CSReportEditor.csRptEditCtrlType.none) {
                    return true;
                }
                this.dataHasChanged = true;
                let originalLeft = 0;
                let copyCtrl = null;
                let movedCtrl = null;
                let firstCtrlLeft = 0;
                let offSet = 0;
                if (this.copyControls) {
                    if (this.vCopyKeys.length === 0) {
                        return false;
                    }
                    originalLeft = left;
                    let keyPaint = this.vCopyKeys[this.vCopyKeys.length - 1];
                    let keyCtrl = this.paint.getPaintObjects().item(keyPaint).getTag();
                    movedCtrl = this.report.getControls().item(keyCtrl);
                    firstCtrlLeft = movedCtrl.getLabel().getAspect().getLeft();
                    for (let i = this.vCopyKeys.length - 1; i > -1; i--) {
                        keyPaint = this.vCopyKeys[i];
                        keyCtrl = this.paint.getPaintObjects().item(keyPaint).getTag();
                        copyCtrl = this.report.getControls().item(keyCtrl);
                        offSet = cEditor.getOffsetLeftFromControls(firstCtrlLeft, copyCtrl.getLabel().getAspect().getLeft());
                        left = originalLeft + offSet;
                        if (this.bCopyWithoutMoving) {
                            top = copyCtrl.getLabel().getAspect().getTop();
                            left = copyCtrl.getLabel().getAspect().getLeft();
                        }
                        if (left - 26 > this.picReport.getWidth()) {
                            left = originalLeft + (offSet % originalLeft);
                            top += 6;
                        }
                        if (top > this.picReport.getHeight()) {
                            top = this.picReport.getHeight() - 6;
                        }
                        this.addControlEndAux(left, top, copyCtrl);
                    }
                    this.copyControls = false;
                }
                else if (this.copyControlsFromOtherReport) {
                    if (this.fMain.getReportCopySource() === null) {
                        return false;
                    }
                    originalLeft = left;
                    let editor = this.fMain.getReportCopySource();
                    let keyPaint = editor.getVCopyKeys(editor.getVCopyKeysCount());
                    let keyCtrl = editor.getPaint().getPaintObjects().item(keyPaint).getTag();
                    movedCtrl = editor.getReport().getControls().item(keyCtrl);
                    firstCtrlLeft = movedCtrl.getLabel().getAspect().getLeft();
                    for (let i = editor.getVCopyKeysCount() - 1; i > -1; i--) {
                        keyPaint = editor.getVCopyKeys(i);
                        keyCtrl = editor.getPaint().getPaintObjects().item(keyPaint).getTag();
                        copyCtrl = editor.getReport().getControls().item(keyCtrl);
                        offSet = cEditor.getOffsetLeftFromControls(firstCtrlLeft, copyCtrl.getLabel().getAspect().getLeft());
                        left = originalLeft + offSet;
                        if (this.bCopyWithoutMoving) {
                            top = copyCtrl.getLabel().getAspect().getTop();
                            left = copyCtrl.getLabel().getAspect().getLeft();
                        }
                        if (left - 400 > this.picReport.getWidth()) {
                            left = originalLeft + (offSet % originalLeft);
                            top = top + 100;
                        }
                        if (top > this.picReport.getHeight()) {
                            top = this.picReport.getHeight() - 100;
                        }
                        this.addControlEndAux(left, top, copyCtrl);
                    }
                    this.copyControlsFromOtherReport = false;
                }
                else {
                    this.addControlEndAux(left, top, null);
                }
                this.refreshBody();
                return true;
            }
            static getOffsetLeftFromControls(leftCtrl1, leftCtrl2) {
                return leftCtrl2 - leftCtrl1;
            }
            static getOffsetTopFromControls(topCtrl1, topCtrl2) {
                return topCtrl2 - topCtrl1;
            }
            addControlEndAux(left, top, baseControl) {
                let ctrl = this.report.getHeaders().item(CSReportEditor.cGlobals.KEY_HEADER)
                    .getSectionLines().item(0).getControls().add();
                this.nextNameCtrl = this.nextNameCtrl + 1;
                ctrl.setName(CSReportEditor.cGlobals.CONTROL_NAME + this.nextNameCtrl);
                if (baseControl === null) {
                    this.setNewControlProperties(ctrl);
                }
                else {
                    cEditor.copyControl(baseControl, ctrl);
                }
                this.setNewControlPosition(ctrl, left, top);
            }
            static copyFont(fromFont, toFont) {
                toFont.setBold(fromFont.getBold());
                toFont.setForeColor(fromFont.getForeColor());
                toFont.setItalic(fromFont.getItalic());
                toFont.setName(fromFont.getName());
                toFont.setSize(fromFont.getSize());
                toFont.setStrike(fromFont.getStrike());
                toFont.setUnderline(fromFont.getUnderline());
            }
            static copyChart(fromChart, toChart) {
                toChart.setChartTitle(fromChart.getChartTitle());
                toChart.setChartType(fromChart.getChartType());
                toChart.setDiameter(fromChart.getDiameter());
                toChart.setFormat(fromChart.getFormat());
                toChart.setGridLines(fromChart.getGridLines());
                toChart.setOutlineBars(fromChart.getOutlineBars());
                toChart.setShowValues(fromChart.getShowValues());
                toChart.setThickness(fromChart.getThickness());
                toChart.setTop(fromChart.getTop());
                toChart.setGroupFieldName(fromChart.getGroupFieldName());
                toChart.setGroupFieldIndex(fromChart.getGroupFieldIndex());
                toChart.setGroupValue(fromChart.getGroupValue());
                toChart.setSort(fromChart.getSort());
                for (let _i = 0; _i < fromChart.getSeries().count(); _i++) {
                    let fromSequence = fromChart.getSeries().item(_i);
                    let sequence = toChart.getSeries().add(new cReportChartSequence());
                    sequence.setColor(fromSequence.getColor());
                    sequence.setLabelFieldName(fromSequence.getLabelFieldName());
                    sequence.setLabelIndex(fromSequence.getLabelIndex());
                    sequence.setValueFieldName(fromSequence.getValueFieldName());
                    sequence.setValueIndex(fromSequence.getValueIndex());
                }
            }
            static copyAspect(fromAspect, toAspect) {
                toAspect.setAlign(fromAspect.getAlign());
                toAspect.setBackColor(fromAspect.getBackColor());
                toAspect.setBorderColor(fromAspect.getBorderColor());
                toAspect.setBorderColor3d(fromAspect.getBorderColor3d());
                toAspect.setBorderColor3dShadow(fromAspect.getBorderColor3dShadow());
                toAspect.setBorderType(fromAspect.getBorderType());
                toAspect.setBorderWidth(fromAspect.getBorderWidth());
                toAspect.setCanGrow(fromAspect.getCanGrow());
                toAspect.setFormat(fromAspect.getFormat());
                toAspect.setHeight(fromAspect.getHeight());
                toAspect.setIsAccounting(fromAspect.getIsAccounting());
                toAspect.setLeft(fromAspect.getLeft());
                toAspect.setNZOrder(fromAspect.getNZOrder());
                toAspect.setSelectColor(fromAspect.getSelectColor());
                toAspect.setSymbol(fromAspect.getSymbol());
                toAspect.setTop(fromAspect.getTop());
                toAspect.setTransparent(fromAspect.getTransparent());
                toAspect.setWidth(fromAspect.getWidth());
                toAspect.setWordWrap(fromAspect.getWordWrap());
                cEditor.copyFont(fromAspect.getFont(), toAspect.getFont());
            }
            static copyAspectToPaint(fromAspect, toAspect) {
                toAspect.setAlign(fromAspect.getAlign());
                toAspect.setBackColor(fromAspect.getBackColor());
                toAspect.setBorderColor(fromAspect.getBorderColor());
                toAspect.setBorderColor3d(fromAspect.getBorderColor3d());
                toAspect.setBorderColor3dShadow(fromAspect.getBorderColor3dShadow());
                toAspect.setBorderType(fromAspect.getBorderType());
                toAspect.setBorderWidth(fromAspect.getBorderWidth());
                toAspect.setCanGrow(fromAspect.getCanGrow());
                toAspect.setFormat(fromAspect.getFormat());
                toAspect.setHeight(fromAspect.getHeight());
                toAspect.setIsAccounting(fromAspect.getIsAccounting());
                toAspect.setLeft(fromAspect.getLeft());
                toAspect.setNZOrder(fromAspect.getNZOrder());
                toAspect.setSelectColor(fromAspect.getSelectColor());
                toAspect.setSymbol(fromAspect.getSymbol());
                toAspect.setTop(fromAspect.getTop());
                toAspect.setTransparent(fromAspect.getTransparent());
                toAspect.setWidth(fromAspect.getWidth());
                toAspect.setWordWrap(fromAspect.getWordWrap());
                cEditor.copyFontPaint(fromAspect.getFont(), toAspect.getFont());
            }
            static copyFontPaint(fromFont, toFont) {
                toFont.setBold(fromFont.getBold());
                toFont.setForeColor(fromFont.getForeColor());
                toFont.setItalic(fromFont.getItalic());
                toFont.setName(fromFont.getName());
                toFont.setSize(fromFont.getSize());
                toFont.setStrike(fromFont.getStrike());
                toFont.setUnderline(fromFont.getUnderline());
            }
            static copyControl(fromCtrl, toCtrl) {
                toCtrl.setControlType(fromCtrl.getControlType());
                let field = toCtrl.getField();
                field.setFieldType(fromCtrl.getField().getFieldType());
                field.setIndex(fromCtrl.getField().getIndex());
                field.setName(fromCtrl.getField().getName());
                toCtrl.getFormulaHide().setName(fromCtrl.getFormulaHide().getName());
                toCtrl.getFormulaHide().setText(fromCtrl.getFormulaHide().getText());
                toCtrl.getFormulaValue().setName(fromCtrl.getFormulaValue().getName());
                toCtrl.getFormulaValue().setText(fromCtrl.getFormulaValue().getText());
                toCtrl.setHasFormulaHide(fromCtrl.getHasFormulaHide());
                toCtrl.setHasFormulaValue(fromCtrl.getHasFormulaValue());
                cEditor.copyAspect(fromCtrl.getImage().getAspect(), toCtrl.getImage().getAspect());
                let label = toCtrl.getLabel();
                cEditor.copyAspect(fromCtrl.getLabel().getAspect(), label.getAspect());
                label.setCanGrow(fromCtrl.getLabel().getCanGrow());
                label.setText(fromCtrl.getLabel().getText());
                cEditor.copyAspect(fromCtrl.getLine().getAspect(), toCtrl.getLine().getAspect());
                cEditor.copyChart(fromCtrl.getChart(), toCtrl.getChart());
            }
            setNewControlProperties(ctrl) {
                const CTRL_HEIGHT = 19;
                const CTRL_WIDTH = 133;
                const LINE_HEIGHT = 1;
                let label = null;
                let aspect = null;
                let ctrlHeight = CTRL_HEIGHT;
                let transparent = true;
                ctrl.getLabel().getAspect().setAlign(HorizontalAlignment.Left);
                switch (this.controlType) {
                    case CSReportEditor.csRptEditCtrlType.field:
                        ctrl.setControlType(csRptControlType.RPT_CT_FIELD);
                        ctrl.getLabel().setText(this.fieldName);
                        let field = ctrl.getField();
                        field.setIndex(this.fieldIndex);
                        field.setName(this.fieldName);
                        field.setFieldType(this.fieldType);
                        if (DatabaseGlobals.isNumberField(this.fieldType)) {
                            aspect = ctrl.getLabel().getAspect();
                            aspect.setAlign(HorizontalAlignment.Right);
                            aspect.setFormat("#0.00;-#0.00");
                        }
                        break;
                    case CSReportEditor.csRptEditCtrlType.formula:
                        ctrl.setControlType(csRptControlType.RPT_CT_LABEL);
                        ctrl.getFormulaValue().setText(this.formulaText + "(" + this.controlName + ")");
                        ctrl.setHasFormulaValue(true);
                        label = ctrl.getLabel();
                        aspect = label.getAspect();
                        aspect.setFormat("0.00;-0.00");
                        aspect.getFont().setBold(true);
                        label.setText(ctrl.getFormulaValue().getText());
                        aspect.setAlign(HorizontalAlignment.Right);
                        break;
                    case CSReportEditor.csRptEditCtrlType.label:
                        ctrl.setControlType(csRptControlType.RPT_CT_LABEL);
                        label = ctrl.getLabel();
                        label.setText(this.fieldName);
                        label.getAspect().getFont().setBold(true);
                        break;
                    case CSReportEditor.csRptEditCtrlType.lineLabel:
                        ctrlHeight = LINE_HEIGHT;
                        ctrl.setControlType(csRptControlType.RPT_CT_LABEL);
                        label = ctrl.getLabel();
                        label.setText(this.fieldName);
                        aspect = label.getAspect();
                        aspect.getFont().setBold(true);
                        aspect.setBackColor(Color.Gray.toArgb());
                        transparent = false;
                        break;
                    case CSReportEditor.csRptEditCtrlType.image:
                        ctrl.setControlType(csRptControlType.RPT_CT_IMAGE);
                        ctrl.getLabel().setText(this.fieldName);
                        break;
                    case CSReportEditor.csRptEditCtrlType.chart:
                        ctrl.setControlType(csRptControlType.RPT_CT_CHART);
                        ctrl.getLabel().setText(this.fieldName);
                        break;
                }
                aspect = ctrl.getLabel().getAspect();
                aspect.setWidth(CTRL_WIDTH);
                aspect.setHeight(ctrlHeight);
                aspect.setTransparent(transparent);
            }
            setNewControlPosition(ctrl, left, top) {
                let aspect = ctrl.getLabel().getAspect();
                aspect.setLeft(left);
                aspect.setTop(top);
                let paintType = csRptPaintObjType.PAINT_OBJ_BOX;
                if (ctrl.getControlType() === csRptControlType.RPT_CT_IMAGE
                    || ctrl.getControlType() === csRptControlType.RPT_CT_CHART) {
                    paintType = csRptPaintObjType.PAINT_OBJ_IMAGE;
                }
                let paintObj = this.paint.getNewObject(paintType);
                aspect = ctrl.getLabel().getAspect();
                cEditor.copyAspectToPaint(aspect, paintObj.getAspect());
                aspect.setLeft(left);
                aspect.setTop(top);
                paintObj.setText(ctrl.getLabel().getText());
                paintObj.setRptType(csRptSectionType.CONTROL);
                paintObj.setTag(ctrl.getKey());
                ctrl.setKeyPaint(paintObj.getKey());
                this.moveControl(paintObj.getKey());
                this.paint.drawObject(paintObj.getKey(), this.picReport.getGraphics());
            }
            addGroup() {
                this.showGroupProperties(null);
                this.refreshAll();
            }
            getGroup(key) {
                let group = null;
                for (let _i = 0; _i < this.report.getGroups().count(); _i++) {
                    group = this.report.getGroups().item(_i);
                    if (group.getHeader().getKey() === key) {
                        break;
                    }
                    if (group.getFooter().getKey() === key) {
                        break;
                    }
                }
                return group;
            }
            addSectionLine() {
                let aspect = null;
                let isGroup = new RefWrapper(false);
                let sec = this.getSection(isGroup);
                if (sec === null)
                    return;
                switch (sec.getTypeSection()) {
                    case csRptSectionType.FOOTER:
                    case csRptSectionType.MAIN_FOOTER:
                        aspect = sec.getSectionLines().add(null, "", 0).getAspect();
                        aspect.setHeight(CSReportEditor.cGlobals.HEIGHT_NEW_SECTION);
                        aspect.setWidth(sec.getAspect().getWidth());
                        aspect.setTop(sec.getSectionLines().item(0).getAspect().getTop() - CSReportEditor.cGlobals.HEIGHT_NEW_SECTION);
                        break;
                    default:
                        this.newSecLineOffSet = CSReportEditor.cGlobals.HEIGHT_NEW_SECTION;
                        aspect = sec.getSectionLines().add().getAspect();
                        aspect.setHeight(CSReportEditor.cGlobals.HEIGHT_NEW_SECTION);
                        aspect.setWidth(sec.getAspect().getWidth());
                        break;
                }
                aspect = sec.getAspect();
                aspect.setHeight(aspect.getHeight() + CSReportEditor.cGlobals.HEIGHT_NEW_SECTION);
                this.pAddSectionLinesAux(sec);
                this.newSecLineOffSet = 0;
            }
            pAddSectionLinesAux(sec) {
                let typeSecLn = csRptSectionType.CONTROL;
                let aspect = null;
                let maxBottom = new RefWrapper(0);
                let minBottom = new RefWrapper(0);
                let index = 0;
                let y = 0;
                switch (sec.getTypeSection()) {
                    case csRptSectionType.HEADER:
                    case csRptSectionType.MAIN_HEADER:
                        this.moveHeader(sec.getKey(), minBottom, maxBottom);
                        aspect = sec.getAspect();
                        y = aspect.getHeight() + aspect.getTop();
                        typeSecLn = csRptSectionType.SECLN_HEADER;
                        index = sec.getSectionLines().count() - 2;
                        break;
                    case csRptSectionType.DETAIL:
                    case csRptSectionType.MAIN_DETAIL:
                        this.moveDetails(sec.getKey(), minBottom, maxBottom);
                        aspect = sec.getAspect();
                        y = aspect.getHeight() + aspect.getTop();
                        typeSecLn = csRptSectionType.SECLN_DETAIL;
                        index = sec.getSectionLines().count() - 2;
                        break;
                    case csRptSectionType.GROUP_HEADER:
                        this.moveGroupHeader(sec.getKey(), minBottom, maxBottom);
                        aspect = sec.getAspect();
                        y = aspect.getHeight() + aspect.getTop();
                        typeSecLn = csRptSectionType.SECLN_GROUPH;
                        index = sec.getSectionLines().count() - 2;
                        break;
                    case csRptSectionType.GROUP_FOOTER:
                        this.moveGroupFooter(sec.getKey(), minBottom, maxBottom);
                        aspect = sec.getAspect();
                        y = aspect.getHeight() + aspect.getTop();
                        typeSecLn = csRptSectionType.SECLN_GROUPF;
                        index = sec.getSectionLines().count() - 2;
                        break;
                    case csRptSectionType.FOOTER:
                    case csRptSectionType.MAIN_FOOTER:
                        aspect = sec.getAspect();
                        aspect.setTop(aspect.getTop() - CSReportEditor.cGlobals.HEIGHT_NEW_SECTION);
                        this.moveFooter(sec.getKey(), minBottom, maxBottom);
                        this.offY = 0;
                        y = aspect.getHeight() + aspect.getTop() - this.offSet - CSReportEditor.cGlobals.HEIGHT_BAR_SECTION;
                        typeSecLn = csRptSectionType.SECLN_FOOTER;
                        index = 0;
                        break;
                }
                let secL = sec.getSectionLines().item(index);
                secL.setKeyPaint(this.paintSection(secL.getAspect(), secL.getKey(), sec.getTypeSection(), this.SECTION_LINE + (sec.getSectionLines().count() - 2).toString(), true));
                let po = this.paint.getPaintSections().item(secL.getKeyPaint());
                po.setRptType(typeSecLn);
                po.setRptKeySec(sec.getKey());
                po = this.paint.getPaintSections().item(sec.getKeyPaint());
                po.setTextLine(this.SECTION_LINE + (sec.getSectionLines().count() - 1).toString());
                this.moveSection(this.paint.getPaintSections().item(this.keyFocus), 0, y, minBottom.get(), maxBottom.get(), sec, false);
                this.refreshBody();
                this.refreshRule();
            }
            addSection(typeSection) {
                if (!this.editor.isVisible())
                    return Promise.resolve();
                let rptSection = null;
                let topSec = null;
                let aspect = null;
                let paintObj = null;
                let maxBottom = new RefWrapper(0);
                let minBottom = new RefWrapper(0);
                let y = 0;
                switch (typeSection) {
                    case csRptSectionType.HEADER:
                        let headers = this.report.getHeaders();
                        rptSection = headers.add();
                        rptSection.setName("H_" + rptSection.getIndex().toString());
                        aspect = headers.item(headers.count() - 2).getAspect();
                        rptSection.getAspect().setWidth(aspect.getWidth());
                        rptSection.getAspect().setHeight(0);
                        rptSection.getAspect().setTop(aspect.getTop() + aspect.getHeight());
                        rptSection.setKeyPaint(this.paintSection(rptSection.getAspect(), rptSection.getKey(), csRptSectionType.HEADER, rptSection.getName(), false));
                        aspect = rptSection.getAspect();
                        this.moveSection(this.paint.getPaintObject(rptSection.getKeyPaint()), 0, aspect.getTop(), aspect.getTop() + CSReportEditor.cGlobals.HEIGHT_NEW_SECTION, aspect.getTop() + rptSection.getAspect().getHeight(), rptSection, true);
                        break;
                    case csRptSectionType.DETAIL:
                        break;
                    case csRptSectionType.GROUP_HEADER:
                        let groupsHeaders = this.report.getGroupsHeaders();
                        rptSection = groupsHeaders.item(groupsHeaders.count() - 1);
                        rptSection.setName("G_" + rptSection.getIndex().toString());
                        if (groupsHeaders.count() === 1) {
                            topSec = this.report.getHeaders().item(this.report.getHeaders().count() - 1);
                        }
                        else {
                            topSec = groupsHeaders.item(groupsHeaders.count() - 2);
                        }
                        aspect = topSec.getAspect();
                        rptSection.getAspect().setWidth(aspect.getWidth());
                        rptSection.getAspect().setHeight(0);
                        rptSection.getAspect().setTop(aspect.getTop() + aspect.getHeight());
                        rptSection.setKeyPaint(this.paintSection(rptSection.getAspect(), rptSection.getKey(), csRptSectionType.GROUP_HEADER, rptSection.getName(), false));
                        aspect = rptSection.getAspect();
                        this.moveSection(this.paint.getPaintObject(rptSection.getKeyPaint()), 0, aspect.getTop() + CSReportEditor.cGlobals.HEIGHT_NEW_SECTION, aspect.getTop(), aspect.getTop() + CSReportEditor.cGlobals.HEIGHT_NEW_SECTION, rptSection, true);
                        break;
                    case csRptSectionType.GROUP_FOOTER:
                        let groupsFooters = this.report.getGroupsFooters();
                        rptSection = groupsFooters.item(0);
                        rptSection.setName("G_" + rptSection.getIndex().toString());
                        topSec = this.report.getDetails().item(this.report.getDetails().count() - 1);
                        aspect = topSec.getAspect();
                        rptSection.getAspect().setWidth(aspect.getWidth());
                        rptSection.getAspect().setHeight(CSReportEditor.cGlobals.HEIGHT_NEW_SECTION);
                        rptSection.getAspect().setTop(aspect.getTop() + aspect.getHeight());
                        rptSection.setKeyPaint(this.paintSection(rptSection.getAspect(), rptSection.getKey(), csRptSectionType.GROUP_FOOTER, rptSection.getName(), false));
                        paintObj = this.paint.getPaintObject(rptSection.getKeyPaint());
                        this.moveGroupFooter(rptSection.getKey(), minBottom, maxBottom);
                        this.offY = 0;
                        aspect = rptSection.getAspect();
                        y = aspect.getHeight() + aspect.getTop() - CSReportEditor.cGlobals.HEIGHT_BAR_SECTION;
                        this.moveSection(paintObj, 0, y, minBottom.get(), maxBottom.get(), rptSection, true);
                        break;
                    case csRptSectionType.FOOTER:
                        let footers = this.report.getFooters();
                        rptSection = footers.add(null, "", 0);
                        rptSection.setName("F_" + rptSection.getIndex().toString());
                        aspect = footers.item(1).getAspect();
                        rptSection.getAspect().setWidth(aspect.getWidth());
                        rptSection.getAspect().setHeight(CSReportEditor.cGlobals.HEIGHT_NEW_SECTION);
                        rptSection.getAspect().setTop(aspect.getTop());
                        rptSection.setKeyPaint(this.paintSection(rptSection.getAspect(), rptSection.getKey(), csRptSectionType.FOOTER, rptSection.getName(), false));
                        paintObj = this.paint.getPaintObject(rptSection.getKeyPaint());
                        this.moveFooter(rptSection.getKey(), minBottom, maxBottom);
                        this.offY = 0;
                        aspect = rptSection.getAspect();
                        y = aspect.getHeight() + aspect.getTop() - this.offSet - CSReportEditor.cGlobals.HEIGHT_BAR_SECTION;
                        this.moveSection(paintObj, 0, y, minBottom.get(), maxBottom.get(), rptSection, true);
                        break;
                }
                aspect = rptSection.getSectionLines().item(0).getAspect();
                aspect.setWidth(rptSection.getAspect().getWidth());
                return this.refreshBody().then(P.call(this, () => this.refreshRule()));
            }
            bringToFront() {
                this.paint.getPaintObjects().setZorder(this.keyObj, true);
                this.refreshBody();
                this.dataHasChanged = true;
            }
            sendToBack() {
                this.paint.getPaintObjects().sendToBack(this.keyObj);
                this.refreshBody();
                this.dataHasChanged = true;
            }
            preview() {
                this.report.getLaunchInfo().setAction(csRptLaunchAction.CS_RPT_LAUNCH_PREVIEW);
                this.launchReport();
            }
            printReport() {
                this.report.getLaunchInfo().setAction(csRptLaunchAction.CS_RPT_LAUNCH_PRINTER);
                this.launchReport();
            }
            launchReport() {
                let mouse = new CMouseWait();
                try {
                    this.setZOrder();
                    this.showProgressDlg();
                    this.report.getLaunchInfo().getPrinter().setPaperInfo(this.report.getPaperInfo());
                    this.report.getLaunchInfo().setReportPrint(new cReportPrint());
                    this.report.getLaunchInfo().setShowPrintersDialog(true);
                    this.report.launch();
                }
                catch (ex) {
                    cError.mngError(ex);
                }
                finally {
                    mouse.dispose();
                    this.closeProgressDlg();
                }
            }
            saveDocumentInBrowser() {
                return this.saveDocument(false, true);
            }
            saveDocument(saveAs, inBrowser = false) {
                let mouse = new CMouseWait();
                try {
                    let isNew = this.isNew || this.report.getName() === "";
                    if (isNew) {
                        this.report.setName(this.name);
                    }
                    if (saveAs) {
                        isNew = true;
                    }
                    this.setZOrder();
                    this.validateSectionAspect();
                    if (this.report.save(isNew, inBrowser)) {
                        this.isNew = false;
                        this.reLoadReport();
                        CSReportEditor.cMainEditor.setDocActive(this);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                    return false;
                }
                finally {
                    mouse.dispose();
                }
            }
            setZOrder() {
                let ctrl = null;
                for (let _i = 0; _i < this.report.getControls().count(); _i++) {
                    ctrl = this.report.getControls().item(_i);
                    ctrl.getLabel().getAspect().setNZOrder(this.paint.getPaintObjects().getZOrderForKey(ctrl.getKeyPaint()));
                }
            }
            newReport(report) {
                this.isNew = true;
                if (report !== null) {
                    this.report = report;
                    this.validateSectionAspect();
                    this.reLoadReport();
                }
                else {
                    this.report.setName("New report");
                    this.paint.createPicture(this.picReport.getGraphics());
                    this.refreshRule();
                }
                CSReportEditor.cMainEditor.setDocActive(this);
            }
            openDocument(fileName = "") {
                let mouse = new CMouseWait();
                try {
                    this.opening = true;
                    let p;
                    if (fileName === "") {
                        CSReportEditor.cEditor.setInitDir();
                        p = this.report.load();
                    }
                    else {
                        p = this.report.loadSilent(fileName);
                    }
                    return p.then(P.call(this, (loadSuccess) => {
                        if (!loadSuccess) {
                            mouse.dispose();
                            return false;
                        }
                        else {
                            this.reLoadReport();
                            CSReportEditor.cMainEditor.setDocActive(this);
                            this.opening = false;
                            return true;
                        }
                    }));
                }
                catch (ex) {
                    cError.mngError(ex);
                    mouse.dispose();
                    return P._(false);
                }
            }
            saveChanges() {
                if (this.dataHasChanged) {
                    return this.askEdit("Do you want to save changes to " + this.reportFullPath + "?", "CSReportEditor").then((answer) => {
                        if (answer === csAskEditResult.CSASKRSLTYES) {
                            if (!this.saveDocument(false))
                                return false;
                            else {
                                this.dataHasChanged = false;
                                return true;
                            }
                        }
                        else {
                            return false;
                        }
                    });
                }
                this.dataHasChanged = false;
                return P._(true);
            }
            askEdit(msg, title) {
                return cWindow.askYesNoCancel(msg, title, MessageBoxDefaultButton.Button3);
            }
            showHelpDbField() {
                return this.showHelpDbField2(this.fProperties);
            }
            showHelpDbFieldForGroup() {
                return this.showHelpDbField2(this.fMain.getGroupDlg());
            }
            showHelpDbField2(f) {
                return this.fMain.showDbFields(f.getTxDbField().getText(), this).then(P.call(this, (result) => {
                    if (result.success) {
                        f.getTxDbField().setText(result.field);
                        f.setFieldType(result.fieldType);
                        f.setIndex(result.fieldIndex);
                        if (f instanceof CSReportEditor.FProperties) {
                            f.getTxText().setText(result.field);
                        }
                        return true;
                    }
                    else {
                        return false;
                    }
                }));
            }
            showHelpDbField3(field) {
                return this.fMain.showDbFields(field, this);
            }
            showCurrentGroupProperties() {
                let group = null;
                let isGroup = new RefWrapper(false);
                let sec = this.getSection(isGroup);
                if (sec === null)
                    return;
                if (!isGroup.get())
                    return;
                for (let _i = 0; _i < this.report.getGroups().count(); _i++) {
                    group = this.report.getGroups().item(_i);
                    if (group.getHeader().getKey() === sec.getKey()) {
                        break;
                    }
                    if (group.getFooter().getKey() === sec.getKey()) {
                        break;
                    }
                }
                this.showGroupProperties(group);
                this.refreshAll();
            }
            showGroupProperties(group) {
                try {
                    let isNew = false;
                    this.showingProperties = true;
                    this.fMain.getGroupDlg().setHandler(this);
                    if (group === null) {
                        isNew = true;
                    }
                    if (isNew) {
                        this.fMain.getGroupDlg().getTxName().setText("Group" + this.report.getGroups().count() + 1);
                        this.fMain.getGroupDlg().getOpAsc().setChecked(true);
                        this.fMain.getGroupDlg().getChkPrintInNewPage().setChecked(false);
                        this.fMain.getGroupDlg().getChkReprintGroup().setChecked(false);
                        this.fMain.getGroupDlg().getChkGrandTotal().setChecked(false);
                        this.fMain.getGroupDlg().getOpText().setChecked(true);
                    }
                    else {
                        this.fMain.getGroupDlg().getTxName().setText(group.getName());
                        this.fMain.getGroupDlg().getTxDbField().setText(group.getFieldName());
                        if (group.getOderType() === RptGrpOrderType.CS_RPT_GRP_ASC) {
                            this.fMain.getGroupDlg().getOpAsc().setChecked(true);
                        }
                        else {
                            this.fMain.getGroupDlg().getOpDesc().setChecked(true);
                        }
                        this.fMain.getGroupDlg().getChkPrintInNewPage().setChecked(group.getPrintInNewPage());
                        this.fMain.getGroupDlg().getChkReprintGroup().setChecked(group.getRePrintInNewPage());
                        this.fMain.getGroupDlg().getChkGrandTotal().setChecked(group.getGrandTotalGroup());
                        switch (group.getComparisonType()) {
                            case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                this.fMain.getGroupDlg().getOpDate().setChecked(true);
                                break;
                            case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                this.fMain.getGroupDlg().getOpNumber().setChecked(true);
                                break;
                            case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                this.fMain.getGroupDlg().getOpText().setChecked(true);
                                break;
                        }
                    }
                    this.fMain.getGroupDlg().getLbGroup().setText("Group: " + this.fMain.getGroupDlg().getTxName().getText());
                    this.fMain.getGroupDlg().showModal()
                        .then(P.call(this, (result) => {
                        if (result.success) {
                            if (isNew) {
                                group = this.report.getGroups().add(null, "");
                            }
                            group.setName(this.fMain.getGroupDlg().getTxName().getText());
                            group.setFieldName(this.fMain.getGroupDlg().getTxDbField().getText());
                            group.setIndex(this.report.getGroups().count());
                            group.setOderType(this.fMain.getGroupDlg().getOpAsc().getChecked() ? RptGrpOrderType.CS_RPT_GRP_ASC : RptGrpOrderType.CS_RPT_GRP_DESC);
                            group.setPrintInNewPage(this.fMain.getGroupDlg().getChkPrintInNewPage().getChecked());
                            group.setRePrintInNewPage(this.fMain.getGroupDlg().getChkReprintGroup().getChecked());
                            group.setGrandTotalGroup(this.fMain.getGroupDlg().getChkGrandTotal().getChecked());
                            if (this.fMain.getGroupDlg().getOpDate().getChecked()) {
                                group.setComparisonType(RptGrpComparisonType.CS_RPT_GRP_DATE);
                            }
                            else if (this.fMain.getGroupDlg().getOpNumber().getChecked()) {
                                group.setComparisonType(RptGrpComparisonType.CS_RPT_GRP_NUMBER);
                            }
                            else if (this.fMain.getGroupDlg().getOpText().getChecked()) {
                                group.setComparisonType(RptGrpComparisonType.CS_RPT_GRP_TEXT);
                            }
                            if (isNew) {
                                this.addSection(csRptSectionType.GROUP_HEADER).then(P.call(this, () => this.addSection(csRptSectionType.GROUP_FOOTER)));
                            }
                            this.dataHasChanged = true;
                        }
                    }));
                }
                catch (ex) {
                    cError.mngError(ex);
                    this.showingProperties = false;
                    this.fMain.getGroupDlg().close();
                }
            }
            moveGroup() {
                let group = null;
                let isGroup = new RefWrapper(false);
                const sec = this.getSection(isGroup);
                if (sec === null)
                    return;
                if (!isGroup.get())
                    return;
                for (let _i = 0; _i < this.report.getGroups().count(); _i++) {
                    group = this.report.getGroups().item(_i);
                    if (group.getHeader().getKey() === sec.getKey()) {
                        break;
                    }
                    if (group.getFooter().getKey() === sec.getKey()) {
                        break;
                    }
                }
                CSReportEditor.cGlobals.moveGroup(group, this);
                this.vSelectedKeys = [];
                this.refreshReport();
            }
            showSelectedSectionProperties() {
                let secLn = new RefWrapper(null);
                let isGroup = new RefWrapper(false);
                let isSecLn = new RefWrapper(false);
                let sec = this.getSection(isGroup, isSecLn, secLn, true);
                if (sec === null)
                    return;
                if (secLn.get() === null)
                    return;
                if (!isSecLn.get())
                    return;
                try {
                    const propertyDlg = CSReportEditor.cMainEditor.getPropertyDlg();
                    propertyDlg.setHandler(this);
                    propertyDlg.getChkSectionFormulaHide().setChecked(sec.getHasFormulaHide());
                    propertyDlg.setSectionFormulaHide(sec.getFormulaHide().getText());
                    propertyDlg.getChkSectionLineFormulaHide().setChecked(secLn.get().getHasFormulaHide());
                    propertyDlg.setSectionLineFormulaHide(secLn.get().getFormulaHide().getText());
                    if (sec instanceof cReportSectionLine) {
                        propertyDlg.getTxSectionName().setEnabled(false);
                    }
                    const secLnName = sec.getName() + " - line " + secLn.get().getIndex().toString();
                    propertyDlg.getLbControl().setText(sec.getName());
                    propertyDlg.getTxSectionName().setText(sec.getName());
                    propertyDlg.getLbSectionLineName().setText("Section: " + secLnName);
                    propertyDlg.showSectionPropertyTabs(isGroup.get());
                    if (isGroup.get()) {
                        let group = null;
                        for (let _i = 0; _i < this.report.getGroups().count(); _i++) {
                            group = this.report.getGroups().item(_i);
                            if (group.getHeader().getKey() === sec.getKey()) {
                                break;
                            }
                            if (group.getFooter().getKey() === sec.getKey()) {
                                break;
                            }
                        }
                        propertyDlg.getTxGroupName().setText(group.getName());
                        propertyDlg.getTxGroupDbField().setText(group.getFieldName());
                        if (group.getOderType() === RptGrpOrderType.CS_RPT_GRP_ASC) {
                            propertyDlg.getOpAsc().setChecked(true);
                        }
                        else {
                            propertyDlg.getOpDesc().setChecked(true);
                        }
                        propertyDlg.getChkPrintInNewPage().setChecked(group.getPrintInNewPage());
                        propertyDlg.getChkReprintGroup().setChecked(group.getRePrintInNewPage());
                        propertyDlg.getChkGrandTotal().setChecked(group.getGrandTotalGroup());
                        switch (group.getComparisonType()) {
                            case RptGrpComparisonType.CS_RPT_GRP_DATE:
                                propertyDlg.getOpDate().setChecked(true);
                                break;
                            case RptGrpComparisonType.CS_RPT_GRP_NUMBER:
                                propertyDlg.getOpNumber().setChecked(true);
                                break;
                            case RptGrpComparisonType.CS_RPT_GRP_TEXT:
                                propertyDlg.getOpText().setChecked(true);
                                break;
                        }
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            getSection2(isSecLn = new RefWrapper(false), secLn = new RefWrapper(null), returnSecLn = false, isGroupHeader = new RefWrapper(false), isGroupFooter = new RefWrapper(false)) {
                const isGroup = new RefWrapper(false);
                return this.getSection(isGroup, isSecLn, secLn, returnSecLn, isGroupHeader, isGroupFooter);
            }
            getSection(isGroup, isSecLn = new RefWrapper(false), secLn = new RefWrapper(null), returnSecLn = false, isGroupHeader = new RefWrapper(false), isGroupFooter = new RefWrapper(false)) {
                let sec = null;
                isGroup.set(false);
                isSecLn.set(false);
                secLn.set(null);
                isGroupFooter.set(false);
                isGroupHeader.set(false);
                if (this.keyFocus === "") {
                    return null;
                }
                if (!this.paint.paintObjIsSection(this.keyFocus)) {
                    return null;
                }
                let paintObj = this.paint.getPaintSections().item(this.keyFocus);
                if (paintObj === null) {
                    return null;
                }
                sec = this.report.getHeaders().item(paintObj.getTag());
                if (sec !== null) {
                }
                else {
                    sec = this.report.getFooters().item(paintObj.getTag());
                    if (sec !== null) {
                    }
                    else {
                        sec = this.report.getGroupsHeaders().item(paintObj.getTag());
                        if (sec !== null) {
                            isGroup.set(true);
                            isGroupHeader.set(true);
                        }
                        else {
                            sec = this.report.getGroupsFooters().item(paintObj.getTag());
                            if (sec !== null) {
                                isGroup.set(true);
                                isGroupFooter.set(true);
                            }
                            else {
                                sec = this.report.getDetails().item(paintObj.getTag());
                                if (sec !== null) {
                                }
                                else {
                                    isSecLn.set(true);
                                    switch (paintObj.getRptType()) {
                                        case csRptSectionType.SECLN_HEADER:
                                            sec = this.report.getHeaders().item(paintObj.getRptKeySec());
                                            break;
                                        case csRptSectionType.SECLN_DETAIL:
                                            sec = this.report.getDetails().item(paintObj.getRptKeySec());
                                            break;
                                        case csRptSectionType.SECLN_FOOTER:
                                            sec = this.report.getFooters().item(paintObj.getRptKeySec());
                                            break;
                                        case csRptSectionType.SECLN_GROUPH:
                                            sec = this.report.getGroupsHeaders().item(paintObj.getRptKeySec());
                                            break;
                                        case csRptSectionType.SECLN_GROUPF:
                                            sec = this.report.getGroupsFooters().item(paintObj.getRptKeySec());
                                            break;
                                    }
                                    secLn.set(sec.getSectionLines().item(paintObj.getTag()));
                                }
                            }
                        }
                    }
                }
                if (returnSecLn && !isSecLn.get()) {
                    secLn.set(sec.getSectionLines().item(sec.getSectionLines().count() - 1));
                    isSecLn.set(true);
                }
                return sec;
            }
            getSelectedKey() {
                if (this.keyObj) {
                    let poSelected = this.paint.getPaintObject(this.keyObj);
                    if (poSelected !== null) {
                        return poSelected.getIsSection() ? "S" + poSelected.getTag() : poSelected.getTag();
                    }
                }
                return null;
            }
            getSelectedKeyIsSection() {
                var _a;
                return ((_a = this.keyObj) === null || _a === void 0 ? void 0 : _a.substring(0, 1)) === 'S';
            }
            showSelectedCtrlProperties() {
                try {
                    let rptCtrl = null;
                    let aspect = null;
                    let font = null;
                    const propertyDlg = CSReportEditor.cMainEditor.getPropertyDlg();
                    propertyDlg.setHandler(this);
                    let paintObject = this.paint.getPaintObject(this.keyObj);
                    if (paintObject === null)
                        return;
                    propertyDlg.getTxText().setText(paintObject.getText());
                    rptCtrl = this.report.getControls().item(paintObject.getTag());
                    if (rptCtrl === null)
                        return;
                    propertyDlg.displayCtrlPropertyTabs();
                    propertyDlg.enable();
                    if (rptCtrl.getControlType() !== csRptControlType.RPT_CT_IMAGE) {
                        propertyDlg.hideTabImage();
                    }
                    else {
                        propertyDlg.getPicImage().setImage(rptCtrl.getImage().getImage());
                        propertyDlg.showTabImage();
                    }
                    if (rptCtrl.getControlType() !== csRptControlType.RPT_CT_CHART) {
                        propertyDlg.hideTabChart();
                    }
                    else {
                        U.listSetListIndexForId(propertyDlg.getCbType(), rptCtrl.getChart().getChartType());
                        U.listSetListIndexForId(propertyDlg.getCbChartSize(), rptCtrl.getChart().getDiameter());
                        U.listSetListIndexForId(propertyDlg.getCbChartThickness(), rptCtrl.getChart().getThickness());
                        U.listSetListIndexForId(propertyDlg.getCbLinesType(), rptCtrl.getChart().getGridLines());
                        propertyDlg.getTxChartTop().setText(rptCtrl.getChart().getTop().toString());
                        propertyDlg.getTxDbFieldGroupValue().setText(rptCtrl.getChart().getGroupFieldName());
                        propertyDlg.setChartGroupIndex(rptCtrl.getChart().getGroupFieldIndex());
                        propertyDlg.getTxChartGroupValue().setText(rptCtrl.getChart().getGroupValue());
                        propertyDlg.getChkShowOutlines().setChecked(rptCtrl.getChart().getOutlineBars());
                        propertyDlg.getChkShowBarValues().setChecked(rptCtrl.getChart().getShowValues());
                        propertyDlg.getChkSort().setChecked(rptCtrl.getChart().getSort());
                        propertyDlg.getTxText().setText(rptCtrl.getChart().getChartTitle());
                        if (rptCtrl.getChart().getSeries().count() > 0) {
                            propertyDlg.getTxDbFieldLbl1().setText(rptCtrl.getChart().getSeries().item(0).getLabelFieldName());
                            propertyDlg.getTxDbFieldVal1().setText(rptCtrl.getChart().getSeries().item(0).getValueFieldName());
                            propertyDlg.setChartIndex(0, rptCtrl.getChart().getSeries().item(0).getLabelIndex());
                            propertyDlg.setChartIndex(1, rptCtrl.getChart().getSeries().item(0).getValueIndex());
                            U.listSetListIndexForId(propertyDlg.getCbColorSerie1(), rptCtrl.getChart().getSeries().item(0).getColor());
                            if (rptCtrl.getChart().getSeries().count() > 1) {
                                propertyDlg.getTxDbFieldLbl1().setText(rptCtrl.getChart().getSeries().item(1).getLabelFieldName());
                                propertyDlg.getTxDbFieldVal2().setText(rptCtrl.getChart().getSeries().item(1).getValueFieldName());
                                propertyDlg.setChartIndex(2, rptCtrl.getChart().getSeries().item(1).getLabelIndex());
                                propertyDlg.setChartIndex(3, rptCtrl.getChart().getSeries().item(1).getValueIndex());
                                U.listSetListIndexForId(propertyDlg.getCbColorSerie2(), rptCtrl.getChart().getSeries().item(1).getColor());
                            }
                        }
                        propertyDlg.showTabChart();
                    }
                    if (rptCtrl.getControlType() === csRptControlType.RPT_CT_FIELD
                        || rptCtrl.getControlType() === csRptControlType.RPT_CT_DB_IMAGE) {
                        propertyDlg.getTxText().setEnabled(false);
                        let field = rptCtrl.getField();
                        propertyDlg.getTxText().setText(field.getName());
                        propertyDlg.getTxDbField().setText(field.getName());
                        propertyDlg.setFieldType(field.getFieldType());
                        propertyDlg.setIndex(field.getIndex());
                        propertyDlg.showTabField();
                    }
                    else {
                        propertyDlg.hideTabField();
                        propertyDlg.getTxText().setEnabled(true);
                    }
                    propertyDlg.getTxName().setText(rptCtrl.getName());
                    propertyDlg.getLbControl().setText(rptCtrl.getName());
                    propertyDlg.getChkFormulaHide().setChecked(rptCtrl.getHasFormulaHide());
                    propertyDlg.getChkFormulaValue().setChecked(rptCtrl.getHasFormulaValue());
                    propertyDlg.getTxExportColIdx().setText(rptCtrl.getExportColIdx().toString());
                    propertyDlg.getChkIsFreeCtrl().setChecked(rptCtrl.getIsFreeCtrl());
                    propertyDlg.getTxTag().setText(rptCtrl.getTag());
                    propertyDlg.setFormulaHide(rptCtrl.getFormulaHide().getText());
                    propertyDlg.setFormulaValue(rptCtrl.getFormulaValue().getText());
                    propertyDlg.getTxIdxGroup().setText(rptCtrl.getFormulaValue().getIdxGroup().toString());
                    propertyDlg.getOpBeforePrint().setChecked(rptCtrl.getFormulaValue().getWhenEval() === csRptWhenEval.CS_RPT_EVAL_PRE);
                    propertyDlg.getOpAfterPrint().setChecked(rptCtrl.getFormulaValue().getWhenEval() === csRptWhenEval.CS_RPT_EVAL_POST);
                    aspect = rptCtrl.getLabel().getAspect();
                    propertyDlg.getChkCanGrow().setChecked(aspect.getCanGrow());
                    propertyDlg.getTxFormat().setText(aspect.getFormat());
                    propertyDlg.getTxSymbol().setText(aspect.getSymbol());
                    propertyDlg.setIsAccounting(aspect.getIsAccounting());
                    propertyDlg.getChkWordWrap().setChecked(aspect.getWordWrap());
                    U.listSetListIndexForId(propertyDlg.getCbAlign(), aspect.getAlign());
                    propertyDlg.getTxBorderColor().setText(aspect.getBorderColor().toString());
                    propertyDlg.getShBorderColor().setBackColor(aspect.getBorderColor());
                    propertyDlg.getTxBorder3D().setText(aspect.getBorderColor3d().toString());
                    propertyDlg.getShBorder3D().setBackColor(aspect.getBorderColor3d());
                    propertyDlg.getTxBorderShadow().setText(aspect.getBorderColor3dShadow().toString());
                    propertyDlg.getShBorderShadow().setBackColor(aspect.getBorderColor3dShadow());
                    propertyDlg.getChkBorderRounded().setChecked(aspect.getBorderRounded());
                    propertyDlg.getTxBorderWidth().setText(aspect.getBorderWidth().toString());
                    U.listSetListIndexForId(propertyDlg.getCbBorderType(), aspect.getBorderType());
                    font = aspect.getFont();
                    propertyDlg.getCbFont().setText(font.getName());
                    propertyDlg.getTxForeColor().setText(font.getForeColor().toString());
                    propertyDlg.getShForeColor().setBackColor(font.getForeColor());
                    propertyDlg.getTxFontSize().setText(font.getSize().toString());
                    propertyDlg.getChkFontBold().setChecked(font.getBold());
                    propertyDlg.getChkFontItalic().setChecked(font.getItalic());
                    propertyDlg.getChkFontUnderline().setChecked(font.getUnderline());
                    propertyDlg.getChkFontStrike().setChecked(font.getStrike());
                    aspect = paintObject.getAspect();
                    propertyDlg.getTxLeft().setText(aspect.getLeft().toString());
                    propertyDlg.getTxTop().setText(aspect.getTop().toString());
                    propertyDlg.getTxWidth().setText(aspect.getWidth().toString());
                    propertyDlg.getTxHeight().setText(aspect.getHeight().toString());
                    propertyDlg.getTxBackColor().setText(aspect.getBackColor().toString());
                    propertyDlg.getShBackColor().setBackColor(aspect.getBackColor());
                    propertyDlg.getChkTransparent().setChecked(aspect.getTransparent());
                    propertyDlg.resetChangedFlags();
                    propertyDlg.showCtrlPropertyTabs();
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            restoreProperties() {
                CSReportEditor.cMainEditor.showProperties();
            }
            applyProperties() {
                if (this.vSelectedKeys.length === 0)
                    return;
                if (this.vSelectedKeys[0].charAt(0) === 'S') {
                    let isGroup = new RefWrapper(false);
                    let secLn = new RefWrapper(null);
                    let isSecLn = new RefWrapper(false);
                    let sec = this.getSection(isGroup, isSecLn, secLn, true);
                    if (sec === null)
                        return;
                    this.applySectionProperties(sec, secLn.get(), isGroup.get());
                }
                else {
                    this.applyCtrlProperties();
                }
            }
            applySectionProperties(sec, secLn, isGroup) {
                try {
                    const propertyDlg = CSReportEditor.cMainEditor.getPropertyDlg();
                    if (propertyDlg.getHasSectionFormulaHideChanged()) {
                        sec.setHasFormulaHide(propertyDlg.getChkSectionFormulaHide().getChecked());
                    }
                    if (propertyDlg.getSectionFormulaHideChanged()) {
                        sec.getFormulaHide().setText(propertyDlg.getSectionFormulaHide());
                    }
                    sec.setName(propertyDlg.getTxName().getText());
                    if (propertyDlg.getHasSectionLineFormulaHideChanged()) {
                        secLn.setHasFormulaHide(propertyDlg.getChkSectionLineFormulaHide().getChecked());
                    }
                    if (propertyDlg.getSectionLineFormulaHideChanged()) {
                        secLn.getFormulaHide().setText(propertyDlg.getSectionLineFormulaHide());
                    }
                    if (isGroup) {
                        let group = null;
                        for (let _i = 0; _i < this.report.getGroups().count(); _i++) {
                            group = this.report.getGroups().item(_i);
                            if (group.getHeader().getKey() === sec.getKey()) {
                                break;
                            }
                            if (group.getFooter().getKey() === sec.getKey()) {
                                break;
                            }
                        }
                        group.setName(propertyDlg.getTxGroupName().getText());
                        group.setFieldName(propertyDlg.getTxGroupDbField().getText());
                        group.setIndex(this.report.getGroups().count());
                        group.setOderType(propertyDlg.getOpAsc().getChecked() ? RptGrpOrderType.CS_RPT_GRP_ASC : RptGrpOrderType.CS_RPT_GRP_DESC);
                        group.setPrintInNewPage(propertyDlg.getChkPrintInNewPage().getChecked());
                        group.setRePrintInNewPage(propertyDlg.getChkReprintGroup().getChecked());
                        group.setGrandTotalGroup(propertyDlg.getChkGrandTotal().getChecked());
                        if (propertyDlg.getOpDate().getChecked()) {
                            group.setComparisonType(RptGrpComparisonType.CS_RPT_GRP_DATE);
                        }
                        else if (propertyDlg.getOpNumber().getChecked()) {
                            group.setComparisonType(RptGrpComparisonType.CS_RPT_GRP_NUMBER);
                        }
                        else if (propertyDlg.getOpText().getChecked()) {
                            group.setComparisonType(RptGrpComparisonType.CS_RPT_GRP_TEXT);
                        }
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            applyCtrlProperties() {
                try {
                    let bMultiSelect = this.vSelectedKeys.length > 1;
                    const propertyDlg = CSReportEditor.cMainEditor.getPropertyDlg();
                    for (let i = 0; i < this.vSelectedKeys.length; i++) {
                        const paintObject = this.paint.getPaintObject(this.vSelectedKeys[i]);
                        const rptCtrl = this.report.getControls().item(paintObject.getTag());
                        if (!bMultiSelect) {
                            if (rptCtrl.getName() !== propertyDlg.getTxName().getText()) {
                                if (rptCtrl.getName() !== "") {
                                    if (cWindow.ask("You have changed the name of this control.;;Do you want to update all references to this control in all formulas of this report?", MessageBoxDefaultButton.Button2)) {
                                        this.updateFormulas(rptCtrl.getName(), propertyDlg.getTxName().getText());
                                    }
                                }
                            }
                            rptCtrl.setName(propertyDlg.getTxName().getText());
                        }
                        if (propertyDlg.getTextChanged()) {
                            rptCtrl.getLabel().setText(propertyDlg.getTxText().getText());
                        }
                        if (propertyDlg.getTagChanged()) {
                            rptCtrl.setTag(propertyDlg.getTxTag().getText());
                        }
                        if (propertyDlg.getSetFormulaHideChanged()) {
                            rptCtrl.setHasFormulaHide(propertyDlg.getChkFormulaHide().getChecked());
                        }
                        if (propertyDlg.getSetFormulaValueChanged()) {
                            rptCtrl.setHasFormulaValue(propertyDlg.getChkFormulaValue().getChecked());
                        }
                        if (propertyDlg.getFormulaHideChanged()) {
                            rptCtrl.getFormulaHide().setText(propertyDlg.getFormulaHide());
                        }
                        if (propertyDlg.getFormulaValueChanged()) {
                            rptCtrl.getFormulaValue().setText(propertyDlg.getFormulaValue());
                        }
                        if (propertyDlg.getIdxGroupChanged()) {
                            rptCtrl.getFormulaValue().setIdxGroup(U.valInt(propertyDlg.getTxIdxGroup().getText()));
                        }
                        if (propertyDlg.getWhenEvalChanged()) {
                            rptCtrl.getFormulaValue().setWhenEval(propertyDlg.getOpAfterPrint().getChecked() ? csRptWhenEval.CS_RPT_EVAL_POST : csRptWhenEval.CS_RPT_EVAL_PRE);
                        }
                        if (propertyDlg.getExportColIdxChanged()) {
                            rptCtrl.setExportColIdx(U.valInt(propertyDlg.getTxExportColIdx().getText()));
                        }
                        if (propertyDlg.getIsFreeCtrlChanged()) {
                            rptCtrl.setIsFreeCtrl(propertyDlg.getChkIsFreeCtrl().getChecked());
                        }
                        if (rptCtrl.getControlType() === csRptControlType.RPT_CT_FIELD || rptCtrl.getControlType() === csRptControlType.RPT_CT_DB_IMAGE) {
                            let field = rptCtrl.getField();
                            if (propertyDlg.getDbFieldChanged()) {
                                field.setFieldType(propertyDlg.getFieldType());
                                field.setIndex(propertyDlg.getIndex());
                                field.setName(propertyDlg.getTxDbField().getText());
                            }
                        }
                        if (propertyDlg.getPictureChanged()) {
                            rptCtrl.getImage().setImage(propertyDlg.getPicImage().getImage());
                        }
                        if (rptCtrl.getControlType() === csRptControlType.RPT_CT_CHART) {
                            if (rptCtrl.getChart().getSeries().count() < 1) {
                                rptCtrl.getChart().getSeries().add(new cReportChartSequence());
                            }
                            if (propertyDlg.getChartTypeChanged()) {
                                rptCtrl.getChart().setChartType(U.listID(propertyDlg.getCbType()));
                            }
                            if (propertyDlg.getChartSizeChanged()) {
                                rptCtrl.getChart().setDiameter(U.listID(propertyDlg.getCbChartSize()));
                            }
                            if (propertyDlg.getChartThicknessChanged()) {
                                rptCtrl.getChart().setThickness(U.listID(propertyDlg.getCbChartThickness()));
                            }
                            if (propertyDlg.getChartLinesTypeChanged()) {
                                rptCtrl.getChart().setGridLines(U.listID(propertyDlg.getCbLinesType()));
                            }
                            if (propertyDlg.getChartShowLinesChanged()) {
                                rptCtrl.getChart().setOutlineBars(propertyDlg.getChkShowOutlines().getChecked());
                            }
                            if (propertyDlg.getChartShowValuesChanged()) {
                                rptCtrl.getChart().setShowValues(propertyDlg.getChkShowBarValues().getChecked());
                            }
                            if (propertyDlg.getTextChanged()) {
                                rptCtrl.getChart().setChartTitle(propertyDlg.getTxText().getText());
                            }
                            if (propertyDlg.getChartTopChanged()) {
                                rptCtrl.getChart().setTop(U.valInt(propertyDlg.getTxChartTop().getText()));
                            }
                            if (propertyDlg.getChartSortChanged()) {
                                rptCtrl.getChart().setSort(propertyDlg.getChkSort().getChecked());
                            }
                            if (propertyDlg.getChartGroupValueChanged()) {
                                rptCtrl.getChart().setGroupValue(propertyDlg.getTxChartGroupValue().getText());
                            }
                            if (propertyDlg.getChartFieldGroupChanged()) {
                                rptCtrl.getChart().setGroupFieldName(propertyDlg.getTxDbFieldGroupValue().getText());
                                rptCtrl.getChart().setGroupFieldIndex(propertyDlg.getChartGroupIndex());
                            }
                            if (propertyDlg.getChartFieldLbl1Changed()) {
                                rptCtrl.getChart().getSeries().item(0).setLabelFieldName(propertyDlg.getTxDbFieldLbl1().getText());
                                rptCtrl.getChart().getSeries().item(0).setLabelIndex(propertyDlg.getChartIndex(0));
                            }
                            if (propertyDlg.getChartFieldVal1Changed()) {
                                rptCtrl.getChart().getSeries().item(0).setValueFieldName(propertyDlg.getTxDbFieldVal1().getText());
                                rptCtrl.getChart().getSeries().item(0).setValueIndex(propertyDlg.getChartIndex(1));
                            }
                            if (propertyDlg.getChartColorSerie1Changed()) {
                                rptCtrl.getChart().getSeries().item(0).setColor(U.listID(propertyDlg.getCbColorSerie1()));
                            }
                            if (propertyDlg.getChartFieldLbl2Changed() || propertyDlg.getChartFieldVal2Changed()) {
                                if (rptCtrl.getChart().getSeries().count() < 2) {
                                    rptCtrl.getChart().getSeries().add();
                                }
                            }
                            if (propertyDlg.getTxDbFieldLbl2().getText() === "" || propertyDlg.getTxDbFieldVal2().getText() === "") {
                                if (rptCtrl.getChart().getSeries().count() > 1) {
                                    rptCtrl.getChart().getSeries().remove(1);
                                }
                            }
                            if (rptCtrl.getChart().getSeries().count() > 1) {
                                if (propertyDlg.getChartFieldLbl2Changed()) {
                                    rptCtrl.getChart().getSeries().item(1).setLabelFieldName(propertyDlg.getTxDbFieldLbl2().getText());
                                    rptCtrl.getChart().getSeries().item(1).setLabelIndex(propertyDlg.getChartIndex(2));
                                }
                                if (propertyDlg.getChartFieldVal2Changed()) {
                                    rptCtrl.getChart().getSeries().item(1).setValueFieldName(propertyDlg.getTxDbFieldVal2().getText());
                                    rptCtrl.getChart().getSeries().item(1).setValueIndex(propertyDlg.getChartIndex(3));
                                }
                                if (propertyDlg.getChartColorSerie2Changed()) {
                                    rptCtrl.getChart().getSeries().item(1).setColor(U.listID(propertyDlg.getCbColorSerie2()));
                                }
                            }
                        }
                        if (propertyDlg.getTextChanged()) {
                            paintObject.setText(propertyDlg.getTxText().getText());
                        }
                        let aspect = rptCtrl.getLabel().getAspect();
                        if (propertyDlg.getLeftChanged()) {
                            aspect.setLeft(U.val(propertyDlg.getTxLeft().getText()));
                        }
                        if (propertyDlg.getTopChanged()) {
                            aspect.setTop(U.val(propertyDlg.getTxTop().getText()));
                        }
                        if (propertyDlg.getWidthChanged()) {
                            aspect.setWidth(U.val(propertyDlg.getTxWidth().getText()));
                        }
                        if (propertyDlg.getHeightChanged()) {
                            aspect.setHeight(U.val(propertyDlg.getTxHeight().getText()));
                        }
                        if (propertyDlg.getBackColorChanged()) {
                            aspect.setBackColor(propertyDlg.getTxBackColor().getText());
                        }
                        if (propertyDlg.getTransparentChanged()) {
                            aspect.setTransparent(propertyDlg.getChkTransparent().getChecked());
                        }
                        if (propertyDlg.getAlignChanged()) {
                            aspect.setAlign(U.listID(propertyDlg.getCbAlign()));
                        }
                        if (propertyDlg.getFormatChanged()) {
                            aspect.setFormat(propertyDlg.getTxFormat().getText());
                        }
                        if (propertyDlg.getSymbolChanged()) {
                            aspect.setSymbol(propertyDlg.getTxSymbol().getText());
                            aspect.setIsAccounting(propertyDlg.getIsAccounting());
                        }
                        if (propertyDlg.getWordWrapChanged()) {
                            aspect.setWordWrap(propertyDlg.getChkWordWrap().getChecked());
                        }
                        if (propertyDlg.getCanGrowChanged()) {
                            aspect.setCanGrow(propertyDlg.getChkCanGrow().getChecked());
                        }
                        if (propertyDlg.getBorderColorChanged()) {
                            aspect.setBorderColor(propertyDlg.getTxBorderColor().getText());
                        }
                        if (propertyDlg.getBorder3DChanged()) {
                            aspect.setBorderColor3d(propertyDlg.getTxBorder3D().getText());
                        }
                        if (propertyDlg.getBorder3DShadowChanged()) {
                            aspect.setBorderColor3dShadow(propertyDlg.getTxBorderShadow().getText());
                        }
                        if (propertyDlg.getBorderRoundedChanged()) {
                            aspect.setBorderRounded(propertyDlg.getChkBorderRounded().getChecked());
                        }
                        if (propertyDlg.getBorderWidthChanged()) {
                            aspect.setBorderWidth(U.valInt(propertyDlg.getTxBorderWidth().getText()));
                        }
                        if (propertyDlg.getBorderTypeChanged()) {
                            aspect.setBorderType(U.listID(propertyDlg.getCbBorderType()));
                        }
                        let font = aspect.getFont();
                        if (propertyDlg.getFontChanged()) {
                            font.setName(propertyDlg.getCbFont().getText());
                        }
                        if (propertyDlg.getForeColorChanged()) {
                            font.setForeColor(propertyDlg.getTxForeColor().getText());
                        }
                        if (propertyDlg.getFontSizeChanged()) {
                            font.setSize(U.val(propertyDlg.getTxFontSize().getText()));
                        }
                        if (propertyDlg.getBoldChanged()) {
                            font.setBold(propertyDlg.getChkFontBold().getChecked());
                        }
                        if (propertyDlg.getItalicChanged()) {
                            font.setItalic(propertyDlg.getChkFontItalic().getChecked());
                        }
                        if (propertyDlg.getUnderlineChanged()) {
                            font.setUnderline(propertyDlg.getChkFontUnderline().getChecked());
                        }
                        if (propertyDlg.getStrikeChanged()) {
                            font.setStrike(propertyDlg.getChkFontStrike().getChecked());
                        }
                        if (propertyDlg.getPictureChanged()) {
                            paintObject.setImage(rptCtrl.getImage().getImage());
                        }
                        aspect = paintObject.getAspect();
                        if (propertyDlg.getLeftChanged()) {
                            aspect.setLeft(U.val(propertyDlg.getTxLeft().getText()));
                        }
                        if (propertyDlg.getTopChanged()) {
                            aspect.setTop(U.val(propertyDlg.getTxTop().getText()));
                        }
                        if (propertyDlg.getWidthChanged()) {
                            aspect.setWidth(U.val(propertyDlg.getTxWidth().getText()));
                        }
                        if (propertyDlg.getHeightChanged()) {
                            aspect.setHeight(U.val(propertyDlg.getTxHeight().getText()));
                        }
                        if (propertyDlg.getBackColorChanged()) {
                            aspect.setBackColor(propertyDlg.getTxBackColor().getText());
                        }
                        if (propertyDlg.getTransparentChanged()) {
                            aspect.setTransparent(propertyDlg.getChkTransparent().getChecked());
                        }
                        if (propertyDlg.getAlignChanged()) {
                            aspect.setAlign(U.listID(propertyDlg.getCbAlign()));
                        }
                        if (propertyDlg.getFormatChanged()) {
                            aspect.setFormat(propertyDlg.getTxFormat().getText());
                        }
                        if (propertyDlg.getSymbolChanged()) {
                            aspect.setSymbol(propertyDlg.getTxSymbol().getText());
                        }
                        if (propertyDlg.getWordWrapChanged()) {
                            aspect.setWordWrap(propertyDlg.getChkWordWrap().getChecked());
                        }
                        if (propertyDlg.getBorderTypeChanged()) {
                            aspect.setBorderType(U.listID(propertyDlg.getCbBorderType()));
                        }
                        if (aspect.getBorderType() === csReportBorderType.CS_RPT_BS_NONE) {
                            aspect.setBorderColor(Color.Black.toArgb());
                            aspect.setBorderWidth(1);
                            aspect.setBorderRounded(false);
                            aspect.setBorderType(csReportBorderType.CS_RPT_BS_FIXED);
                        }
                        else {
                            if (propertyDlg.getBorderColorChanged()) {
                                aspect.setBorderColor(propertyDlg.getTxBorderColor().getText());
                            }
                            if (propertyDlg.getBorder3DChanged()) {
                                aspect.setBorderColor3d(propertyDlg.getTxBorder3D().getText());
                            }
                            if (propertyDlg.getBorder3DShadowChanged()) {
                                aspect.setBorderColor3dShadow(propertyDlg.getTxBorderShadow().getText());
                            }
                            if (propertyDlg.getBorderRoundedChanged()) {
                                aspect.setBorderRounded(propertyDlg.getChkBorderRounded().getChecked());
                            }
                            if (propertyDlg.getBorderWidthChanged()) {
                                aspect.setBorderWidth(U.valInt(propertyDlg.getTxBorderWidth().getText()));
                            }
                        }
                        font = aspect.getFont();
                        if (propertyDlg.getFontChanged()) {
                            font.setName(propertyDlg.getCbFont().getText());
                        }
                        if (propertyDlg.getForeColorChanged()) {
                            font.setForeColor(propertyDlg.getTxForeColor().getText());
                        }
                        if (propertyDlg.getFontSizeChanged()) {
                            font.setSize(U.val(propertyDlg.getTxFontSize().getText()));
                        }
                        if (propertyDlg.getBoldChanged()) {
                            font.setBold(propertyDlg.getChkFontBold().getChecked());
                        }
                        if (propertyDlg.getItalicChanged()) {
                            font.setItalic(propertyDlg.getChkFontItalic().getChecked());
                        }
                        if (propertyDlg.getUnderlineChanged()) {
                            font.setUnderline(propertyDlg.getChkFontUnderline().getChecked());
                        }
                        if (propertyDlg.getStrikeChanged()) {
                            font.setStrike(propertyDlg.getChkFontStrike().getChecked());
                        }
                    }
                    this.dataHasChanged = true;
                }
                catch (ex) {
                    cError.mngError(ex);
                }
                finally {
                    this.paint.endMove(this.picReport.getGraphics());
                }
            }
            beginDragging() {
                this.picReport.focus();
                this.dragging = true;
                this.picReport.setCursor(Cursor.Move);
            }
            endDragging() {
                this.dragging = false;
                this.controlType = CSReportEditor.csRptEditCtrlType.none;
                this.picReport.setCursor(Cursor.Default);
            }
            showToolbox() {
                let f = CSReportEditor.cMainEditor.getToolbox(this);
                f.clear();
                this.addColumnsToToolbox(this.report.getConnect().getDataSource(), this.report.getConnect().getColumns(), f);
                for (let _i = 0; _i < this.report.getConnectsAux().count(); _i++) {
                    let connect = this.report.getConnectsAux().item(_i);
                    this.addColumnsToToolbox(connect.getDataSource(), connect.getColumns(), f);
                }
                for (let _i = 0; _i < this.report.getControls().count(); _i++) {
                    let ctrl = this.report.getControls().item(_i);
                    if (DatabaseGlobals.isNumberField(ctrl.getField().getFieldType())) {
                        f.addLbFormula(ctrl.getField().getName());
                        f.addFormula("Sum", ctrl.getName(), "_Sum");
                        f.addFormula("Maximum", ctrl.getName(), "_Max");
                        f.addFormula("Minimum", ctrl.getName(), "_Min");
                        f.addFormula("Averagge", ctrl.getName(), "_Average");
                    }
                }
                if (!f.getVisible()) {
                    f.show(this.fMain);
                }
            }
            addColumnsToToolbox(dataSource, columns, f) {
                for (let _i = 0; _i < columns.count(); _i++) {
                    let col = columns.item(_i);
                    f.addField(CSReportEditor.cGlobals.getDataSourceStr(dataSource) + col.getName(), col.getColumnType(), col.getPosition());
                    f.addLabels(col.getName());
                }
            }
            copy() {
                if (this.vSelectedKeys.length === 0)
                    return;
                try {
                    this.vCopyKeys = [...this.vSelectedKeys];
                    this.fMain.setReportCopySource(this);
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            paste(bDontMove) {
                try {
                    this.bCopyWithoutMoving = bDontMove;
                    if (this.vCopyKeys.length === 0) {
                        if (this.fMain.getReportCopySource() === null)
                            return;
                        this.copyControlsFromOtherReport = true;
                    }
                    else {
                        this.copyControls = true;
                    }
                    this.addLabel();
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            editText() {
                try {
                    let sText = "";
                    let paintObjAspect = null;
                    let ctrl = null;
                    if (this.keyObj === "")
                        return;
                    let paintObject = this.paint.getPaintObject(this.keyObj);
                    paintObjAspect = paintObject.getAspect();
                    sText = paintObject.getText();
                    ctrl = this.report.getControls().item(paintObject.getTag());
                    if (paintObjAspect === null)
                        return;
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            endEditText(descartar) {
            }
            paintSection(aspect, sKey, rptType, text, isSecLn) {
                const paintObj = this.paint.getNewSection(csRptPaintObjType.PAINT_OBJ_BOX);
                let paintAspect = paintObj.getAspect();
                paintAspect.setLeft(0);
                paintAspect.setTop(aspect.getTop() + aspect.getHeight() - CSReportEditor.cGlobals.HEIGHT_BAR_SECTION);
                paintAspect.setWidth(aspect.getWidth());
                paintAspect.setHeight(CSReportEditor.cGlobals.HEIGHT_BAR_SECTION);
                paintAspect.setBorderType(csReportBorderType.CS_RPT_BS_FIXED);
                paintAspect.setBorderWidth(1);
                if (isSecLn) {
                    paintAspect.setBackColor("#ffcc99");
                    paintAspect.setBorderColor(Color.Red.toArgb());
                }
                else {
                    const INNER_COLOR = "#99ccff";
                    if (rptType === csRptSectionType.GROUP_FOOTER
                        || rptType === csRptSectionType.GROUP_HEADER) {
                        paintAspect.setBackColor(INNER_COLOR);
                        paintAspect.setBorderColor("#C0C000");
                    }
                    else {
                        paintAspect.setBackColor(INNER_COLOR);
                        paintAspect.setBorderColor("#0066cc");
                    }
                }
                if (rptType === csRptSectionType.MAIN_FOOTER
                    || rptType === csRptSectionType.FOOTER) {
                    paintAspect.setOffset(this.offSet);
                }
                paintObj.setIsSection(!isSecLn);
                paintObj.setIsSectionLine(isSecLn);
                paintObj.setRptType(rptType);
                paintObj.setTag(sKey);
                paintObj.setText(text);
                return paintObj.getKey();
            }
            getLineRegionForControl(sKeyPaintObj, rptSecLine, isFreeCtrl) {
                let rptSection = new RefWrapper(null);
                rptSecLine.set(null);
                if (!this.getRegionForControl(sKeyPaintObj, rptSection, isFreeCtrl)) {
                    return false;
                }
                let w1 = 0;
                let w2 = 0;
                let y = 0;
                let rtnSecLine = null;
                let aspect = this.paint.getPaintObject(sKeyPaintObj).getAspect();
                if (isFreeCtrl) {
                    y = aspect.getTop() + aspect.getOffset();
                }
                else {
                    y = aspect.getTop() + aspect.getHeight() / 2 + aspect.getOffset();
                }
                for (let _i = 0; _i < rptSection.get().getSectionLines().count(); _i++) {
                    let rptSL = rptSection.get().getSectionLines().item(_i);
                    aspect = rptSL.getAspect();
                    w1 = aspect.getTop();
                    w2 = aspect.getTop() + aspect.getHeight();
                    if (isFreeCtrl) {
                        if (w1 <= y) {
                            rtnSecLine = rptSL;
                        }
                    }
                    else {
                        if (w1 <= y && w2 >= y) {
                            rtnSecLine = rptSL;
                            break;
                        }
                    }
                }
                if (rtnSecLine !== null) {
                    rptSecLine.set(rtnSecLine);
                    return true;
                }
                else {
                    return false;
                }
            }
            getRegionForControl(sKeyPaintObj, rptSection, isFreeCtrl) {
                let y;
                let aspect = this.paint.getPaintObject(sKeyPaintObj).getAspect();
                let x = aspect.getLeft();
                if (isFreeCtrl) {
                    y = aspect.getTop();
                }
                else {
                    y = aspect.getTop() + aspect.getHeight() / 2;
                }
                if (cEditor.getRegionForControlAux(this.report.getHeaders(), x, y, rptSection, isFreeCtrl)) {
                    aspect.setOffset(0);
                    return true;
                }
                if (cEditor.getRegionForControlAux(this.report.getGroupsHeaders(), x, y, rptSection, isFreeCtrl)) {
                    aspect.setOffset(0);
                    return true;
                }
                if (cEditor.getRegionForControlAux(this.report.getDetails(), x, y, rptSection, isFreeCtrl)) {
                    aspect.setOffset(0);
                    return true;
                }
                if (cEditor.getRegionForControlAux(this.report.getGroupsFooters(), x, y, rptSection, isFreeCtrl)) {
                    aspect.setOffset(0);
                    return true;
                }
                y = y + this.offSet;
                if (cEditor.getRegionForControlAux(this.report.getFooters(), x, y, rptSection, isFreeCtrl)) {
                    aspect.setOffset(this.offSet);
                    return true;
                }
                return false;
            }
            static getRegionForControlAux(rptSections, x, y, rptSection, isFreeCtrl) {
                let y1 = 0;
                let y2 = 0;
                let rtnSec = null;
                rptSection.set(null);
                for (let _i = 0; _i < rptSections.count(); _i++) {
                    let rptSec = rptSections.item(_i);
                    let aspect = rptSec.getAspect();
                    y1 = aspect.getTop();
                    y2 = aspect.getTop() + aspect.getHeight();
                    if (isFreeCtrl) {
                        if (y1 <= y) {
                            rtnSec = rptSec;
                        }
                    }
                    else {
                        if (y1 <= y && y2 >= y) {
                            rtnSec = rptSec;
                            break;
                        }
                    }
                }
                if (rtnSec !== null) {
                    rptSection.set(rtnSec);
                    return true;
                }
                else {
                    return false;
                }
            }
            pChangeTopSection(rptSec, offSetTopSection, bChangeTop, bZeroOffset) {
                let newTopCtrl = 0;
                let bottom = 0;
                let secLnHeight = 0;
                let offSecLn = 0;
                let paintSec;
                let secAspect = rptSec.getAspect();
                secAspect.setTop(secAspect.getTop() + offSetTopSection);
                let offSet = rptSec.getSectionLines().item(0).getAspect().getTop() - secAspect.getTop();
                const secTop = secAspect.getTop();
                for (let _i = 0; _i < rptSec.getSectionLines().count(); _i++) {
                    let rptSecLine = rptSec.getSectionLines().item(_i);
                    let secLineAspect = rptSecLine.getAspect();
                    if (rptSec.getTypeSection() === csRptSectionType.MAIN_FOOTER
                        || rptSec.getTypeSection() === csRptSectionType.FOOTER) {
                        if (bChangeTop) {
                            if (bZeroOffset) {
                                offSet = 0;
                            }
                        }
                        else {
                            if (rptSecLine.getRealIndex() >= this.indexSecLnMoved && this.indexSecLnMoved > 0) {
                                bChangeTop = true;
                            }
                        }
                    }
                    else {
                        offSecLn = -secLineAspect.getTop();
                        if (offSetTopSection !== 0) {
                            offSecLn = 0;
                        }
                    }
                    secLineAspect.setTop(secTop + secLnHeight);
                    secLnHeight = secLnHeight + secLineAspect.getHeight();
                    if (rptSecLine.getKeyPaint() !== "") {
                        paintSec = this.paint.getPaintSections().item(rptSecLine.getKeyPaint());
                        paintSec.getAspect().setTop(secLineAspect.getTop() + secLineAspect.getHeight() - CSReportEditor.cGlobals.HEIGHT_BAR_SECTION);
                    }
                    else {
                        paintSec = this.paint.getPaintSections().item(rptSec.getKeyPaint());
                    }
                    if (paintSec !== null) {
                        paintSec.setHeightSecLine(secLineAspect.getHeight());
                    }
                    for (let _j = 0; _j < rptSecLine.getControls().count(); _j++) {
                        let rptCtrl = rptSecLine.getControls().item(_j);
                        let ctrLabelAspect = rptCtrl.getLabel().getAspect();
                        if (rptCtrl.getIsFreeCtrl()) {
                            newTopCtrl = (ctrLabelAspect.getTop() - offSet) + offSecLn;
                        }
                        else {
                            newTopCtrl = (ctrLabelAspect.getTop() + ctrLabelAspect.getHeight() - offSet) + offSecLn;
                        }
                        bottom = secLineAspect.getTop() + secLineAspect.getHeight();
                        if (newTopCtrl > bottom) {
                            newTopCtrl = bottom - ctrLabelAspect.getHeight();
                        }
                        else {
                            newTopCtrl = (ctrLabelAspect.getTop() - offSet) + offSecLn;
                        }
                        if (newTopCtrl < secLineAspect.getTop()) {
                            newTopCtrl = secLineAspect.getTop();
                        }
                        ctrLabelAspect.setTop(newTopCtrl);
                        if (this.paint.getPaintObject(rptCtrl.getKeyPaint()) !== null) {
                            this.paint.getPaintObject(rptCtrl.getKeyPaint()).getAspect().setTop(ctrLabelAspect.getTop());
                        }
                    }
                }
                if (rptSec.getKeyPaint() === "")
                    return;
                let aspect = rptSec.getAspect();
                paintSec = this.paint.getPaintSections().item(rptSec.getKeyPaint());
                if (paintSec !== null) {
                    paintSec.getAspect().setTop(aspect.getTop()
                        + aspect.getHeight()
                        - CSReportEditor.cGlobals.HEIGHT_BAR_SECTION);
                    paintSec.setHeightSec(aspect.getHeight());
                }
            }
            moveSection(paintObj, x, y, minBottom, maxBottom, secToMove, isNew) {
                if (this.bNoMove)
                    return;
                let oldHeight = 0;
                this.dataHasChanged = true;
                let aspect = paintObj.getAspect();
                if (y >= minBottom && y <= maxBottom) {
                    aspect.setTop(y - this.offY);
                    aspect.setTop(aspect.getTop() + aspect.getOffset());
                }
                else {
                    if (y < minBottom) {
                        aspect.setTop(minBottom);
                        aspect.setTop(aspect.getTop() + aspect.getOffset());
                    }
                    else {
                        aspect.setTop(maxBottom);
                    }
                }
                if (isNew) {
                    oldHeight = 0;
                }
                else {
                    oldHeight = secToMove.getAspect().getHeight();
                }
                secToMove.getAspect().setHeight(aspect.getTop()
                    + CSReportEditor.cGlobals.HEIGHT_BAR_SECTION
                    - secToMove.getAspect().getTop());
                let offsetTop = 0;
                aspect = secToMove.getAspect();
                offsetTop = oldHeight - (aspect.getHeight() + this.newSecLineOffSet);
                switch (secToMove.getTypeSection()) {
                    case csRptSectionType.FOOTER:
                    case csRptSectionType.MAIN_FOOTER:
                        aspect.setTop(aspect.getTop() + offsetTop);
                        this.pChangeHeightSection(secToMove, oldHeight);
                        this.pChangeBottomSections(secToMove, offsetTop);
                        break;
                    default:
                        this.pChangeHeightSection(secToMove, oldHeight);
                        offsetTop = offsetTop * -1;
                        this.pChangeTopSections(secToMove, offsetTop);
                        break;
                }
                let pageHeight = 0;
                let paperInfo = this.report.getPaperInfo();
                this.pGetOffSet(CSReports.CSReportPaint.cGlobals.getRectFromPaperSize(this.report.getPaperInfo(), paperInfo.getPaperSize(), paperInfo.getOrientation()).getHeight(), pageHeight);
                this.pRefreshOffSetInPaintObjs();
                this.paint.setGridHeight(pageHeight);
            }
            pChangeBottomSections(secToMove, offsetTop) {
                let sec = null;
                let bChangeTop = false;
                if (secToMove.getTypeSection() === csRptSectionType.FOOTER
                    || secToMove.getTypeSection() === csRptSectionType.MAIN_FOOTER
                    || bChangeTop) {
                    for (let i = this.report.getFooters().count() - 1; i > -1; i--) {
                        sec = this.report.getFooters().item(i);
                        if (bChangeTop) {
                            this.pChangeTopSection(sec, offsetTop, bChangeTop, false);
                        }
                        if (sec === secToMove) {
                            bChangeTop = true;
                        }
                    }
                }
            }
            pChangeTopSections(secToMove, offsetTop) {
                let sec = null;
                let bChangeTop = false;
                if (secToMove.getTypeSection() === csRptSectionType.HEADER
                    || secToMove.getTypeSection() === csRptSectionType.MAIN_HEADER) {
                    for (let _i = 0; _i < this.report.getHeaders().count(); _i++) {
                        sec = this.report.getHeaders().item(_i);
                        if (bChangeTop) {
                            this.pChangeTopSection(sec, offsetTop, bChangeTop, false);
                        }
                        if (sec === secToMove) {
                            bChangeTop = true;
                        }
                    }
                }
                if (secToMove.getTypeSection() === csRptSectionType.GROUP_HEADER || bChangeTop) {
                    for (let _i = 0; _i < this.report.getGroupsHeaders().count(); _i++) {
                        sec = this.report.getGroupsHeaders().item(_i);
                        if (bChangeTop) {
                            this.pChangeTopSection(sec, offsetTop, bChangeTop, false);
                        }
                        if (sec === secToMove) {
                            bChangeTop = true;
                        }
                    }
                }
                if (secToMove.getTypeSection() === csRptSectionType.MAIN_DETAIL
                    || secToMove.getTypeSection() === csRptSectionType.DETAIL || bChangeTop) {
                    for (let _i = 0; _i < this.report.getDetails().count(); _i++) {
                        sec = this.report.getDetails().item(_i);
                        if (bChangeTop) {
                            this.pChangeTopSection(sec, offsetTop, bChangeTop, false);
                        }
                        if (sec === secToMove) {
                            bChangeTop = true;
                        }
                    }
                }
                if (secToMove.getTypeSection() === csRptSectionType.GROUP_FOOTER || bChangeTop) {
                    for (let _i = 0; _i < this.report.getGroupsFooters().count(); _i++) {
                        sec = this.report.getGroupsFooters().item(_i);
                        if (bChangeTop) {
                            this.pChangeTopSection(sec, offsetTop, bChangeTop, false);
                        }
                        if (sec === secToMove) {
                            bChangeTop = true;
                        }
                    }
                }
            }
            pChangeHeightSection(sec, oldSecHeight) {
                let heightLines = 0;
                let aspect;
                for (let i = 0; i < sec.getSectionLines().count() - 1; i++) {
                    aspect = sec.getSectionLines().item(i).getAspect();
                    heightLines = heightLines + aspect.getHeight();
                }
                let sectionLines = sec.getSectionLines();
                aspect = sectionLines.item(sectionLines.count() - 1).getAspect();
                aspect.setHeight(sec.getAspect().getHeight() - heightLines);
                this.pChangeTopSection(sec, 0, false, true);
            }
            getSectionRuleName(sec) {
                switch (sec.getTypeSection()) {
                    case csRptSectionType.HEADER: return "H " + sec.getRealIndex();
                    case csRptSectionType.DETAIL: return "D " + sec.getRealIndex();
                    case csRptSectionType.FOOTER: return "F " + (sec.getIndex() - 1);
                    case csRptSectionType.GROUP_HEADER: return "GH " + sec.getRealIndex();
                    case csRptSectionType.GROUP_FOOTER: return "GF " + (sec.getIndex() - 1);
                    case csRptSectionType.MAIN_HEADER: return "MH";
                    case csRptSectionType.MAIN_DETAIL: return "MD";
                    case csRptSectionType.MAIN_FOOTER: return "MF";
                    case csRptSectionType.CONTROL: return "C";
                    case csRptSectionType.SECLN_HEADER: return "LH";
                    case csRptSectionType.SECLN_DETAIL: return "LD";
                    case csRptSectionType.SECLN_FOOTER: return "LF " + (sec.getIndex() - 1);
                    case csRptSectionType.SECLN_GROUPH: return "GH " + sec.getRealIndex();
                    case csRptSectionType.SECLN_GROUPF: return "GF " + (sec.getIndex() - 1);
                }
            }
            reLoadReport() {
                let paintSec = null;
                this.keyMoving = "";
                this.keySizing = "";
                this.keyObj = "";
                this.keyFocus = "";
                this.moveType = CSReportEditor.csRptEditorMoveType.CSRPTEDMOVTNONE;
                this.paint = new cReportPaint();
                this.paint.setScaleX(this.zoom);
                this.paint.setScaleY(this.zoom);
                let paperInfo = this.report.getPaperInfo();
                this.paint.setGridHeight(this.setSizePics(CSReports.CSReportPaint.cGlobals.getRectFromPaperSize(this.report.getPaperInfo(), paperInfo.getPaperSize(), paperInfo.getOrientation()).getHeight()));
                return this.paint.initGrid(this.picReport.getGraphics(), this.typeGrid).then(P.call(this, () => {
                    if (this.report.getName() !== "") {
                        this.editorTab.setText(this.report.getName());
                    }
                    for (let _i = 0; _i < this.report.getHeaders().count(); _i++) {
                        this.loadSection(this.report.getHeaders().item(_i), csRptSectionType.SECLN_HEADER);
                    }
                    for (let _i = 0; _i < this.report.getGroupsHeaders().count(); _i++) {
                        this.loadSection(this.report.getGroupsHeaders().item(_i), csRptSectionType.SECLN_GROUPH);
                    }
                    for (let _i = 0; _i < this.report.getDetails().count(); _i++) {
                        this.loadSection(this.report.getDetails().item(_i), csRptSectionType.SECLN_DETAIL);
                    }
                    for (let _i = 0; _i < this.report.getGroupsFooters().count(); _i++) {
                        this.loadSection(this.report.getGroupsFooters().item(_i), csRptSectionType.SECLN_GROUPF);
                    }
                    for (let _i = 0; _i < this.report.getFooters().count(); _i++) {
                        this.loadSection(this.report.getFooters().item(_i), csRptSectionType.SECLN_FOOTER);
                    }
                    let paintType;
                    for (let _i = 0; _i < this.report.getControls().count(); _i++) {
                        let rptCtrl = this.report.getControls().item(_i);
                        this.refreshNextNameCtrl(rptCtrl.getName());
                        let ctrlAspect = rptCtrl.getLabel().getAspect();
                        if (rptCtrl.getControlType() === csRptControlType.RPT_CT_IMAGE
                            || rptCtrl.getControlType() === csRptControlType.RPT_CT_CHART) {
                            paintType = csRptPaintObjType.PAINT_OBJ_IMAGE;
                        }
                        else {
                            paintType = csRptPaintObjType.PAINT_OBJ_BOX;
                        }
                        let paintObj = this.paint.getNewObject(paintType);
                        if (ctrlAspect.getBackColor() === Color.White.toArgb()) {
                            ctrlAspect.setTransparent(true);
                        }
                        paintObj.setImage(rptCtrl.getImage().getImage());
                        let aspect = paintObj.getAspect();
                        aspect.setLeft(ctrlAspect.getLeft());
                        aspect.setTop(ctrlAspect.getTop());
                        aspect.setWidth(ctrlAspect.getWidth());
                        aspect.setHeight(ctrlAspect.getHeight());
                        aspect.setBackColor(ctrlAspect.getBackColor());
                        aspect.setTransparent(ctrlAspect.getTransparent());
                        aspect.setAlign(ctrlAspect.getAlign());
                        aspect.setWordWrap(ctrlAspect.getWordWrap());
                        if (ctrlAspect.getBorderType() === csReportBorderType.CS_RPT_BS_NONE) {
                            aspect.setBorderColor(Color.Black.toArgb());
                            aspect.setBorderWidth(0);
                            aspect.setBorderRounded(false);
                            aspect.setBorderType(csReportBorderType.CS_RPT_BS_FIXED);
                        }
                        else {
                            aspect.setBorderType(ctrlAspect.getBorderType());
                            aspect.setBorderColor(ctrlAspect.getBorderColor());
                            aspect.setBorderColor3d(ctrlAspect.getBorderColor3d());
                            aspect.setBorderColor3dShadow(ctrlAspect.getBorderColor3dShadow());
                            aspect.setBorderRounded(ctrlAspect.getBorderRounded());
                            aspect.setBorderWidth(ctrlAspect.getBorderWidth());
                        }
                        switch (rptCtrl.getSectionLine().getTypeSection()) {
                            case csRptSectionType.FOOTER:
                            case csRptSectionType.MAIN_FOOTER:
                                aspect.setOffset(this.offSet);
                                break;
                        }
                        let font = aspect.getFont();
                        font.setName(ctrlAspect.getFont().getName());
                        font.setForeColor(ctrlAspect.getFont().getForeColor());
                        font.setSize(ctrlAspect.getFont().getSize());
                        font.setBold(ctrlAspect.getFont().getBold());
                        font.setItalic(ctrlAspect.getFont().getItalic());
                        font.setUnderline(ctrlAspect.getFont().getUnderline());
                        font.setStrike(ctrlAspect.getFont().getStrike());
                        paintObj.setText(rptCtrl.getLabel().getText());
                        paintObj.setRptType(csRptSectionType.CONTROL);
                        paintObj.setTag(rptCtrl.getKey());
                        rptCtrl.setKeyPaint(paintObj.getKey());
                    }
                    this.dataHasChanged = false;
                    this.paint.createPicture(this.picReport.getGraphics());
                    this.refreshRule();
                    CSReportEditor.cMainEditor.clearProperties();
                }));
            }
            loadSection(sec, secType) {
                const secName = this.getSectionRuleName(sec);
                if (sec.getName() === "")
                    sec.setName(secName);
                sec.setKeyPaint(this.paintSection(sec.getAspect(), sec.getKey(), sec.getTypeSection(), secName, false));
                const paintSec = this.paint.getPaintSections().item(sec.getKeyPaint());
                paintSec.setHeightSec(sec.getAspect().getHeight());
                this.addPaintSectionForSecLn(sec, secType);
            }
            addPaintSectionForSecLn(sec, typeSecLn) {
                let paintSec = null;
                if (sec.getSectionLines().count() > 1) {
                    for (let i = 0; i < sec.getSectionLines().count() - 1; i++) {
                        let secLine = sec.getSectionLines().item(i);
                        secLine.setKeyPaint(this.paintSection(secLine.getAspect(), secLine.getKey(), sec.getTypeSection(), this.SECTION_LINE + i.toString(), true));
                        paintSec = this.paint.getPaintSections().item(secLine.getKeyPaint());
                        paintSec.setHeightSecLine(secLine.getAspect().getHeight());
                        paintSec.setRptType(typeSecLn);
                        paintSec.setRptKeySec(sec.getKey());
                    }
                    let po = this.paint.getPaintSections().item(sec.getKeyPaint());
                    po.setTextLine(this.SECTION_LINE + (sec.getSectionLines().count() - 1).toString());
                }
                paintSec = this.paint.getPaintSections().item(sec.getKeyPaint());
                let secLines = sec.getSectionLines();
                paintSec.setHeightSecLine(secLines.item(secLines.count() - 1).getAspect().getHeight());
            }
            refreshNextNameCtrl(nameCtrl) {
                let x = 0;
                if (nameCtrl.substring(0, CSReportEditor.cGlobals.CONTROL_NAME.length).toUpperCase() === CSReportEditor.cGlobals.CONTROL_NAME.toUpperCase()) {
                    x = U.valInt(nameCtrl.substring(CSReportEditor.cGlobals.CONTROL_NAME.length + 1));
                    if (x > this.nextNameCtrl) {
                        this.nextNameCtrl = x + 1;
                    }
                }
            }
            moveControl(sKeyPaintObj) {
                let rptSecLine = new RefWrapper(null);
                let rptSecLineAspect = null;
                this.paint.alignToGrid(sKeyPaintObj);
                const rptCtrl = this.report.getControls().item(this.paint.getPaintObject(sKeyPaintObj).getTag());
                const objPaintAspect = this.paint.getPaintObject(sKeyPaintObj).getAspect();
                if (rptCtrl === null)
                    return;
                let aspect = rptCtrl.getLabel().getAspect();
                aspect.setTop(objPaintAspect.getTop() + objPaintAspect.getOffset());
                aspect.setHeight(objPaintAspect.getHeight());
                aspect.setWidth(objPaintAspect.getWidth());
                aspect.setLeft(objPaintAspect.getLeft());
                if (this.getLineRegionForControl(sKeyPaintObj, rptSecLine, rptCtrl.getIsFreeCtrl())) {
                    if (!(rptSecLine.get() === rptCtrl.getSectionLine())) {
                        rptCtrl.getSectionLine().getControls().remove(rptCtrl.getKey());
                        rptSecLine.get().getControls().add(rptCtrl, rptCtrl.getKey());
                    }
                    rptSecLineAspect = rptCtrl.getSectionLine().getAspect();
                    aspect = rptCtrl.getLabel().getAspect();
                    aspect.setTop(objPaintAspect.getTop() + objPaintAspect.getOffset());
                    if (!rptCtrl.getIsFreeCtrl()) {
                        if (aspect.getTop() + aspect.getHeight()
                            > rptSecLineAspect.getTop() + rptSecLineAspect.getHeight()) {
                            aspect.setTop(rptSecLineAspect.getTop()
                                + rptSecLineAspect.getHeight()
                                - aspect.getHeight());
                        }
                    }
                    if (aspect.getTop() < rptSecLineAspect.getTop()) {
                        aspect.setTop(rptSecLineAspect.getTop());
                    }
                    objPaintAspect.setTop(aspect.getTop());
                }
            }
            showPopMenuSection(noDelete, showGroups, x, y, event) {
                this.fMain.showPopMenuSection(this, noDelete, showGroups, this.picReport.pointToScreen(new Point(x, y)), event);
            }
            showPopMenuControl(clickInCtrl, x, y, event) {
                let pasteEnabled = false;
                if (this.vCopyKeys.length > 0) {
                    pasteEnabled = true;
                }
                else if (!(this.fMain.getReportCopySource() === null)) {
                    pasteEnabled = this.fMain.getReportCopySource().getVCopyKeysCount() > 0;
                }
                this.fMain.showPopMenuControl(this, clickInCtrl, pasteEnabled, this.picReport.pointToScreen(new Point(x, y)), event);
            }
            destroyPropertiesFormReference() {
                this.fProperties = null;
            }
            refreshBody() {
                try {
                    return this.paint.endMove(this.picReport.getGraphics());
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            refreshRule() {
                if (this.paint !== null) {
                    this.paint.clearRule(this.picRule.getGraphics());
                    let ps = this.paint.getPaintSections();
                    for (let i = 0; i < ps.count(); i++) {
                        this.paint.drawRule(ps.getNextKeyForZOrder(i), this.picRule.getGraphics(), this.RULE_WIDTH);
                    }
                }
            }
            refreshReport() {
                let paperInfo = this.report.getPaperInfo();
                this.paint.setGridHeight(this.setSizePics(CSReports.CSReportPaint.cGlobals.getRectFromPaperSize(this.report.getPaperInfo(), paperInfo.getPaperSize(), paperInfo.getOrientation())
                    .getHeight()));
                this.validateSectionAspect();
                return this.reLoadReport();
            }
            refreshAll() {
                this.refreshBody();
                this.refreshRule();
                CSReportEditor.cMainEditor.setDocActive(this);
            }
            reportDone(report) {
                this.closeProgressDlg();
            }
            reportProgress(sender, e) {
                let task = e.task;
                let page = e.page;
                let currRecord = e.currRecord;
                let recordCount = e.recordCount;
                if (this.cancelPrinting) {
                    if (cWindow.ask("Confirm you want to cancel the execution of this report?", MessageBoxDefaultButton.Button2)) {
                        e.cancel = true;
                        this.closeProgressDlg();
                        return;
                    }
                    else {
                        this.cancelPrinting = false;
                    }
                }
                if (this.fProgress === null)
                    return;
                if (page > 0) {
                    this.fProgress.getLbCurrPage().setText(page.toString());
                }
                if (task !== "") {
                    this.fProgress.getLbTask().setText(task);
                }
                if (currRecord > 0) {
                    this.fProgress.getLbCurrRecord().setText(currRecord.toString());
                }
                if (recordCount > 0 && U.val(this.fProgress.getLbRecordCount().getText()) !== recordCount) {
                    this.fProgress.getLbRecordCount().setText(recordCount.toString());
                }
                let percent = 0;
                if (recordCount > 0 && currRecord > 0) {
                    percent = currRecord / recordCount;
                    let value = Math.trunc(percent * 100);
                    if (value > 100)
                        value = 100;
                    this.fProgress.getPrgBar().setValue(value);
                }
            }
            closeProgressDlg() {
                if (this.fProgress !== null && !this.fProgress.isDisposed()) {
                    this.fProgress.close();
                }
                this.fProgress = null;
            }
            showProgressDlg() {
                this.cancelPrinting = false;
                if (this.fProgress === null) {
                    this.fProgress = new CSReportEditor.FProgress();
                }
                this.fProgress.show();
                this.fProgress.bringToFront();
            }
            fProgress_Cancel() {
                this.cancelPrinting = true;
            }
            getLeftBody() {
                if (CSReportEditor.cMainEditor.gHideLeftBar) {
                    return this.LEFT_BODY;
                }
                else {
                    return this.picRule.getWidth() + this.LEFT_BODY;
                }
            }
            setSizePics(realPageHeight) {
                let pageHeight = 0;
                let paperInfo = this.report.getPaperInfo();
                this.picReport.setWidth(CSReports.CSReportPaint.cGlobals.getRectFromPaperSize(this.report.getPaperInfo(), paperInfo.getPaperSize(), paperInfo.getOrientation())
                    .getWidth() * this.zoom);
                this.pGetOffSet(realPageHeight, pageHeight);
                if (pageHeight > realPageHeight) {
                    realPageHeight = pageHeight;
                }
                this.picReport.setHeight(realPageHeight * this.zoom);
                this.picRule.setHeight(realPageHeight * this.zoom + this.TOP_BODY * 2);
                this.picRule.setWidth(this.RULE_WIDTH * this.zoom);
                return pageHeight;
            }
            pMoveAll(x, y) {
                let rptCtrlAspect = null;
                let paintObj = null;
                this.dataHasChanged = true;
                if (this.bNoMove)
                    return;
                let i = 0;
                let offsetTop = 0;
                let offsetLeft = 0;
                let firstLeft = 0;
                let firstTop = 0;
                let firstOffSet = 0;
                if (this.vSelectedKeys.length === 0)
                    return;
                paintObj = this.paint.getPaintObject(this.keyMoving);
                let aspect = paintObj.getAspect();
                firstLeft = aspect.getLeft();
                firstTop = aspect.getTop();
                firstOffSet = aspect.getOffset();
                for (i = this.vSelectedKeys.length - 1; i > -1; i--) {
                    paintObj = this.paint.getPaintObject(this.vSelectedKeys[i]);
                    offsetLeft = cEditor.getOffsetLeftFromControls(firstLeft, paintObj.getAspect().getLeft());
                    offsetTop = cEditor.getOffsetTopFromControls(firstTop - firstOffSet, paintObj.getAspect().getTop()
                        - paintObj.getAspect().getOffset());
                    aspect = paintObj.getAspect();
                    if (x !== this.NO_MOVE) {
                        aspect.setLeft(x - this.offX + offsetLeft);
                    }
                    if (y !== this.NO_MOVE) {
                        aspect.setTop(y - this.offY + offsetTop);
                    }
                    else {
                        aspect.setTop(aspect.getTop() - paintObj.getAspect().getOffset());
                    }
                    if (paintObj.getRptType() === csRptSectionType.CONTROL) {
                        rptCtrlAspect = this.report.getControls().item(paintObj.getTag()).getLabel().getAspect();
                        rptCtrlAspect.setLeft(aspect.getLeft());
                        rptCtrlAspect.setTop(aspect.getTop());
                        rptCtrlAspect.setWidth(aspect.getWidth());
                        rptCtrlAspect.setHeight(aspect.getHeight());
                    }
                    this.moveControl(this.vSelectedKeys[i]);
                }
            }
            pMoveHorizontal(x) {
                this.dataHasChanged = true;
                this.paint.getPaintObject(this.keyMoving).getAspect().setLeft(x - this.offX);
            }
            pMoveVertical(x, y) {
                let sKeySection = "";
                let maxBottom = new RefWrapper(0);
                let minBottom = new RefWrapper(0);
                let maxBottomSectionLine = new RefWrapper(0);
                let rptSec = null;
                let isSecLn = false;
                this.indexSecLnMoved = -1;
                let paintObj = this.paint.getPaintObject(this.keyMoving);
                let aspect = paintObj.getAspect();
                sKeySection = paintObj.getTag();
                let rptType = paintObj.getRptType();
                switch (rptType) {
                    case csRptSectionType.MAIN_HEADER:
                    case csRptSectionType.HEADER:
                        rptSec = this.moveHeader(sKeySection, minBottom, maxBottom);
                        break;
                    case csRptSectionType.GROUP_HEADER:
                        rptSec = this.moveGroupHeader(sKeySection, minBottom, maxBottom);
                        break;
                    case csRptSectionType.MAIN_DETAIL:
                    case csRptSectionType.DETAIL:
                        rptSec = this.moveDetails(sKeySection, minBottom, maxBottom);
                        break;
                    case csRptSectionType.GROUP_FOOTER:
                        rptSec = this.moveGroupFooter(sKeySection, minBottom, maxBottom);
                        break;
                    case csRptSectionType.MAIN_FOOTER:
                    case csRptSectionType.FOOTER:
                        rptSec = this.moveFooter(sKeySection, minBottom, maxBottom);
                        break;
                    case csRptSectionType.SECLN_HEADER:
                        sKeySection = paintObj.getRptKeySec();
                        rptSec = this.moveHeader(sKeySection, minBottom, maxBottom, true, paintObj.getTag(), maxBottomSectionLine);
                        isSecLn = true;
                        break;
                    case csRptSectionType.SECLN_GROUPH:
                        sKeySection = paintObj.getRptKeySec();
                        rptSec = this.moveGroupHeader(sKeySection, minBottom, maxBottom, true, paintObj.getTag(), maxBottomSectionLine);
                        isSecLn = true;
                        break;
                    case csRptSectionType.SECLN_DETAIL:
                        sKeySection = paintObj.getRptKeySec();
                        rptSec = this.moveDetails(sKeySection, minBottom, maxBottom, true, paintObj.getTag(), maxBottomSectionLine);
                        isSecLn = true;
                        break;
                    case csRptSectionType.SECLN_GROUPF:
                        sKeySection = paintObj.getRptKeySec();
                        rptSec = this.moveGroupFooter(sKeySection, minBottom, maxBottom, true, paintObj.getTag(), maxBottomSectionLine);
                        isSecLn = true;
                        break;
                    case csRptSectionType.SECLN_FOOTER:
                        sKeySection = paintObj.getRptKeySec();
                        rptSec = this.moveFooter(sKeySection, minBottom, maxBottom, true, paintObj.getTag(), maxBottomSectionLine);
                        isSecLn = true;
                        this.indexSecLnMoved = rptSec.getSectionLines().item(paintObj.getTag()).getRealIndex();
                        break;
                }
                if (isSecLn) {
                    minBottom.set(cEditor.getMinBottomForSecLn(rptSec, paintObj.getTag(), minBottom.get()));
                    this.changeSecLnHeight(paintObj, y, minBottom.get(), maxBottomSectionLine.get(), rptSec.getSectionLines().item(paintObj.getTag()));
                    y = rptSec.getAspect().getTop()
                        - paintObj.getAspect().getOffset()
                        + cEditor.getSecHeightFromSecLines(rptSec)
                        - CSReportEditor.cGlobals.HEIGHT_BAR_SECTION;
                    this.offY = 0;
                    paintObj = this.paint.getPaintSections().item(rptSec.getKeyPaint());
                }
                this.moveSection(paintObj, x, y, minBottom.get(), maxBottom.get(), rptSec, false);
            }
            static getSecHeightFromSecLines(sec) {
                let rtn = 0;
                for (let _i = 0; _i < sec.getSectionLines().count(); _i++) {
                    let secLn = sec.getSectionLines().item(_i);
                    rtn = rtn + secLn.getAspect().getHeight();
                }
                return rtn;
            }
            static getMinBottomForSecLn(sec, secLnKey, minBottom) {
                for (let _i = 0; _i < sec.getSectionLines().count(); _i++) {
                    let secLn = sec.getSectionLines().item(_i);
                    if (secLn.getKey() === secLnKey) {
                        break;
                    }
                    minBottom = minBottom + secLn.getAspect().getHeight();
                }
                return minBottom;
            }
            changeSecLnHeight(paintObj, y, minBottom, maxBottom, secLn) {
                let aspect = paintObj.getAspect();
                if (y >= minBottom && y <= maxBottom) {
                    aspect.setTop(y - this.offY);
                }
                else {
                    if (y < minBottom) {
                        aspect.setTop(minBottom);
                    }
                    else {
                        aspect.setTop(maxBottom);
                    }
                }
                aspect.setTop(aspect.getTop() + aspect.getOffset());
                secLn.getAspect().setHeight(aspect.getTop()
                    + CSReportEditor.cGlobals.HEIGHT_BAR_SECTION
                    - secLn.getAspect().getTop());
            }
            pResizeControl(x, y) {
                x /= this.zoom;
                y /= this.zoom;
                let height = 0;
                let width = 0;
                let left = 0;
                let top = 0;
                if (this.vSelectedKeys.length === 0)
                    return;
                this.dataHasChanged = true;
                let po = this.paint.getPaintObject(this.keySizing);
                let aspect = po.getAspect();
                height = aspect.getHeight();
                width = aspect.getWidth();
                left = aspect.getLeft();
                top = aspect.getTop();
                switch (this.moveType) {
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVDOWN:
                        aspect.setHeight(y - (aspect.getTop() - aspect.getOffset()));
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFT:
                        aspect.setWidth(aspect.getWidth() + aspect.getLeft() - x);
                        aspect.setLeft(x);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHT:
                        aspect.setWidth(x - aspect.getLeft());
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVUP:
                        aspect.setHeight(aspect.getHeight() + (aspect.getTop() - aspect.getOffset()) - y);
                        aspect.setTop(y + aspect.getOffset());
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTDOWN:
                        aspect.setHeight(y - (aspect.getTop() - aspect.getOffset()));
                        aspect.setWidth(aspect.getWidth() + aspect.getLeft() - x);
                        aspect.setLeft(x);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTUP:
                        aspect.setHeight(aspect.getHeight() + (aspect.getTop() - aspect.getOffset()) - y);
                        aspect.setTop(y + aspect.getOffset());
                        aspect.setWidth(aspect.getWidth() + aspect.getLeft() - x);
                        aspect.setLeft(x);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTDOWN:
                        aspect.setWidth(x - aspect.getLeft());
                        aspect.setHeight(y - (aspect.getTop() - aspect.getOffset()));
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTUP:
                        aspect.setHeight(aspect.getHeight() + (aspect.getTop() - aspect.getOffset()) - y);
                        aspect.setTop(y + aspect.getOffset());
                        aspect.setWidth(x - aspect.getLeft());
                        break;
                }
                top = aspect.getTop() - top;
                left = aspect.getLeft() - left;
                width = aspect.getWidth() - width;
                height = aspect.getHeight() - height;
                this.pMoveControlAfterResize(po.getAspect(), true);
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    if (this.keySizing !== this.vSelectedKeys[i]) {
                        po = this.paint.getPaintObject(this.vSelectedKeys[i]);
                        aspect = po.getAspect();
                        aspect.setHeight(aspect.getHeight() + height);
                        aspect.setTop(aspect.getTop() + top);
                        aspect.setWidth(aspect.getWidth() + width);
                        aspect.setLeft(aspect.getLeft() + left);
                        this.pMoveControlAfterResize(po.getAspect(), false);
                    }
                }
            }
            pMoveControlAfterResize(aspect, bSizing) {
                const MIN_WIDTH = 1;
                const MIN_HEIGHT = 1;
                let rptCtrlAspect = null;
                if (this.paint.getPaintObject(this.keySizing).getRptType() === csRptSectionType.CONTROL) {
                    rptCtrlAspect = this.report.getControls().item(this.paint.getPaintObject(this.keySizing).getTag()).getLabel().getAspect();
                    rptCtrlAspect.setLeft(aspect.getLeft());
                    if (!bSizing) {
                        rptCtrlAspect.setTop(aspect.getTop() + aspect.getOffset());
                    }
                    else {
                        rptCtrlAspect.setTop(aspect.getTop());
                    }
                    rptCtrlAspect.setWidth(aspect.getWidth());
                    rptCtrlAspect.setHeight(aspect.getHeight());
                }
                switch (this.moveType) {
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVDOWN:
                        this.paint.alignObjBottomToGrid(this.keySizing);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFT:
                        this.paint.alignObjLeftToGrid(this.keySizing);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHT:
                        this.paint.alignObjRightToGrid(this.keySizing);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVUP:
                        this.paint.alignObjTopToGrid(this.keySizing);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTDOWN:
                        this.paint.alignObjLeftBottomToGrid(this.keySizing);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVLEFTUP:
                        this.paint.alignObjLeftTopToGrid(this.keySizing);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTDOWN:
                        this.paint.alignObjRightBottomToGrid(this.keySizing);
                        break;
                    case CSReportEditor.csRptEditorMoveType.CSRPTEDMOVRIGHTUP:
                        this.paint.alignObjRightTopToGrid(this.keySizing);
                        break;
                }
                if (aspect.getWidth() < MIN_WIDTH) {
                    aspect.setWidth(MIN_WIDTH);
                }
                if (aspect.getHeight() < MIN_HEIGHT) {
                    aspect.setHeight(MIN_HEIGHT);
                }
            }
            moveHeader(sKeySection, minBottom, maxBottom, isForSectionLine = false, secLnKey = "", maxBottomSectionLine = null) {
                let rptSec = this.report.getHeaders().item(sKeySection);
                let index = rptSec.getRealIndex();
                if (index === 0) {
                    minBottom.set(this.MIN_HEIGHT_SECTION);
                }
                else {
                    let aspect = this.report.getHeaders().item(index - 1).getAspect();
                    minBottom.set(aspect.getTop() + aspect.getHeight() + this.MIN_HEIGHT_SECTION);
                }
                if (!isForSectionLine) {
                    minBottom.set(cEditor.getMinBottomWithSecLn(rptSec.getSectionLines(), minBottom.get()));
                }
                if (maxBottomSectionLine !== null) {
                    maxBottomSectionLine.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, secLnKey));
                }
                maxBottom.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, ""));
                return rptSec;
            }
            moveGroupHeader(sKeySection, minBottom, maxBottom, isForSectionLine = false, secLnKey = "", maxBottomSectionLine = null) {
                const rptSec = this.report.getGroupsHeaders().item(sKeySection);
                const index = rptSec.getRealIndex();
                if (index === 0) {
                    let headers = this.report.getHeaders();
                    let aspect = headers.item(headers.count() - 1).getAspect();
                    minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                }
                else {
                    let aspect = this.report.getGroupsHeaders().item(index - 1).getAspect();
                    minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                }
                if (!isForSectionLine) {
                    minBottom.set(cEditor.getMinBottomWithSecLn(rptSec.getSectionLines(), minBottom.get()));
                }
                if (maxBottomSectionLine !== null) {
                    maxBottomSectionLine.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, secLnKey));
                }
                maxBottom.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, ""));
                return rptSec;
            }
            getHeightOfSectionsBellowMe(section, secLnKey) {
                let height = 0;
                if (!(secLnKey === null || secLnKey.trim() === "")) {
                    let add = false;
                    for (let _i = 0; _i < section.getSectionLines().count(); _i++) {
                        let secLn = section.getSectionLines().item(_i);
                        if (add) {
                            height += secLn.getAspect().getHeight();
                        }
                        else if (secLn.getKey() === secLnKey) {
                            add = true;
                        }
                    }
                }
                let rptType = section.getTypeSection();
                switch (rptType) {
                    case csRptSectionType.HEADER:
                    case csRptSectionType.MAIN_HEADER:
                        height += cEditor.getHeightFromSections(this.report.getHeaders(), section);
                        height += cEditor.getHeightFromSections(this.report.getGroupsHeaders(), null);
                        height += cEditor.getHeightFromSections(this.report.getDetails(), null);
                        height += cEditor.getHeightFromSections(this.report.getGroupsFooters(), null);
                        height += cEditor.getHeightFromSections(this.report.getFooters(), null);
                        break;
                    case csRptSectionType.GROUP_HEADER:
                        height += cEditor.getHeightFromSections(this.report.getGroupsHeaders(), section);
                        height += cEditor.getHeightFromSections(this.report.getDetails(), null);
                        height += cEditor.getHeightFromSections(this.report.getGroupsFooters(), null);
                        height += cEditor.getHeightFromSections(this.report.getFooters(), null);
                        break;
                    case csRptSectionType.DETAIL:
                    case csRptSectionType.MAIN_DETAIL:
                        height += cEditor.getHeightFromSections(this.report.getDetails(), section);
                        height += cEditor.getHeightFromSections(this.report.getGroupsFooters(), null);
                        height += cEditor.getHeightFromSections(this.report.getFooters(), null);
                        break;
                    case csRptSectionType.GROUP_FOOTER:
                        height += cEditor.getHeightFromSections(this.report.getGroupsFooters(), section);
                        height += cEditor.getHeightFromSections(this.report.getFooters(), null);
                        break;
                    case csRptSectionType.FOOTER:
                    case csRptSectionType.MAIN_FOOTER:
                        height += cEditor.getHeightFromSections(this.report.getFooters(), section);
                        break;
                    default:
                        throw new CSReportEditor.ReportEditorException(CSReportEditor.cReportEditorError.errGetDescription(CSReportEditor.csRptEditorErrors.CSRPT_EDITOR_SECTION_TYPE_INVALID));
                }
                return height;
            }
            static getHeightFromSections(sections, section) {
                let add = section === null;
                let height = 0;
                for (let _i = 0; _i < sections.count(); _i++) {
                    let sec = sections.item(_i);
                    if (add) {
                        height += sec.getAspect().getHeight();
                    }
                    else if (section === sec) {
                        add = true;
                    }
                }
                return height;
            }
            getAllHeadersAndGroupsAndDetailsHeight() {
                let sec = null;
                let height = 0;
                for (let _i = 0; _i < this.report.getHeaders().count(); _i++) {
                    sec = this.report.getHeaders().item(_i);
                    height = height + sec.getAspect().getHeight();
                }
                for (let _i = 0; _i < this.report.getGroupsHeaders().count(); _i++) {
                    sec = this.report.getGroupsHeaders().item(_i);
                    height = height + sec.getAspect().getHeight();
                }
                for (let _i = 0; _i < this.report.getDetails().count(); _i++) {
                    sec = this.report.getDetails().item(_i);
                    height = height + sec.getAspect().getHeight();
                }
                return height;
            }
            moveDetails(sKeySection, minBottom, maxBottom, isForSectionLine = false, secLnKey = "", maxBottomSectionLine = null) {
                let rptSec = this.report.getDetails().item(sKeySection);
                let index = rptSec.getRealIndex();
                if (index === 0) {
                    if (this.report.getGroupsHeaders().count() > 0) {
                        let groupsHeaders = this.report.getGroupsHeaders();
                        let aspect = groupsHeaders.item(groupsHeaders.count() - 1).getAspect();
                        minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                    }
                    else {
                        let headers = this.report.getHeaders();
                        let aspect = headers.item(headers.count() - 1).getAspect();
                        minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                    }
                }
                else {
                    let aspect = this.report.getDetails().item(index - 1).getAspect();
                    minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                }
                if (!isForSectionLine) {
                    minBottom.set(cEditor.getMinBottomWithSecLn(rptSec.getSectionLines(), minBottom.get()));
                }
                if (maxBottomSectionLine !== null) {
                    maxBottomSectionLine.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, secLnKey));
                }
                maxBottom.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, ""));
                return rptSec;
            }
            moveGroupFooter(sKeySection, minBottom, maxBottom, isForSectionLine = false, secLnKey = "", maxBottomSectionLine = null) {
                let rptSec = this.report.getGroupsFooters().item(sKeySection);
                let index = rptSec.getRealIndex();
                if (index === 0) {
                    let details = this.report.getDetails();
                    let aspect = details.item(details.count() - 1).getAspect();
                    minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                }
                else {
                    let aspect = this.report.getGroupsFooters().item(index - 1).getAspect();
                    minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                }
                if (!isForSectionLine) {
                    minBottom.set(cEditor.getMinBottomWithSecLn(rptSec.getSectionLines(), minBottom.get()));
                }
                if (maxBottomSectionLine !== null) {
                    maxBottomSectionLine.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, secLnKey));
                }
                maxBottom.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, ""));
                return rptSec;
            }
            moveFooter(sKeySection, minBottom, maxBottom, isForSectionLine = false, secLnKey = "", maxBottomSectionLine = null) {
                let rptSec = this.report.getFooters().item(sKeySection);
                let index = rptSec.getRealIndex();
                if (index === 0) {
                    if (this.report.getGroupsFooters().count() > 0) {
                        let groupsFooters = this.report.getGroupsFooters();
                        let aspect = groupsFooters.item(groupsFooters.count() - 1).getAspect();
                        minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                    }
                    else {
                        let details = this.report.getDetails();
                        let aspect = details.item(details.count() - 1).getAspect();
                        minBottom.set(aspect.getHeight() + aspect.getTop() + this.MIN_HEIGHT_SECTION);
                    }
                }
                else {
                    let aspect = this.report.getFooters().item(index - 1).getAspect();
                    minBottom.set(aspect.getHeight() + aspect.getTop() - this.offSet + this.MIN_HEIGHT_SECTION);
                }
                if (!isForSectionLine) {
                    minBottom.set(cEditor.getMinBottomWithSecLn(rptSec.getSectionLines(), minBottom.get()));
                }
                if (maxBottomSectionLine !== null) {
                    maxBottomSectionLine.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, secLnKey));
                }
                maxBottom.set(this.picReport.getHeight() - this.getHeightOfSectionsBellowMe(rptSec, ""));
                return rptSec;
            }
            static getMinBottomWithSecLn(secLns, minBottom) {
                for (let i = 0; i < secLns.count() - 1; i++) {
                    minBottom = minBottom + secLns.item(i).getAspect().getHeight();
                }
                return minBottom;
            }
            pGetOffSet(realPageHeight, rtnPageHeight = 0) {
                let sec = null;
                rtnPageHeight = 0;
                for (let _i = 0; _i < this.report.getHeaders().count(); _i++) {
                    sec = this.report.getHeaders().item(_i);
                    rtnPageHeight = rtnPageHeight + sec.getAspect().getHeight();
                }
                for (let _i = 0; _i < this.report.getGroupsHeaders().count(); _i++) {
                    sec = this.report.getGroupsHeaders().item(_i);
                    rtnPageHeight = rtnPageHeight + sec.getAspect().getHeight();
                }
                for (let _i = 0; _i < this.report.getDetails().count(); _i++) {
                    sec = this.report.getDetails().item(_i);
                    rtnPageHeight = rtnPageHeight + sec.getAspect().getHeight();
                }
                for (let _i = 0; _i < this.report.getGroupsFooters().count(); _i++) {
                    sec = this.report.getGroupsFooters().item(_i);
                    rtnPageHeight = rtnPageHeight + sec.getAspect().getHeight();
                }
                for (let _i = 0; _i < this.report.getFooters().count(); _i++) {
                    sec = this.report.getFooters().item(_i);
                    rtnPageHeight = rtnPageHeight + sec.getAspect().getHeight();
                }
                this.offSet = realPageHeight - rtnPageHeight;
                if (this.offSet < 0) {
                    this.offSet = 0;
                }
            }
            pRefreshOffSetInPaintObjs() {
                let sec = null;
                let secLines = null;
                let ctl = null;
                let paintSections = this.paint.getPaintSections();
                for (let _i = 0; _i < this.report.getFooters().count(); _i++) {
                    sec = this.report.getFooters().item(_i);
                    paintSections.item(sec.getKeyPaint()).getAspect().setOffset(this.offSet);
                    for (let _j = 0; _j < sec.getSectionLines().count(); _j++) {
                        secLines = sec.getSectionLines().item(_j);
                        if (secLines.getKeyPaint() !== "") {
                            paintSections.item(secLines.getKeyPaint()).getAspect().setOffset(this.offSet);
                        }
                        for (let _k = 0; _k < secLines.getControls().count(); _k++) {
                            ctl = secLines.getControls().item(_k);
                            let po = this.paint.getPaintObjects().item(ctl.getKeyPaint());
                            po.getAspect().setOffset(this.offSet);
                        }
                    }
                }
            }
            setSelectForRightButton() {
                for (let i = 0; i < this.vSelectedKeys.length; i++) {
                    if (this.vSelectedKeys[i] === this.keyObj) {
                        return false;
                    }
                }
                this.vSelectedKeys = [this.keyObj];
                return true;
            }
            validateSectionAspect() {
                let sec = null;
                let top = 0;
                for (let _i = 0; _i < this.report.getHeaders().count(); _i++) {
                    sec = this.report.getHeaders().item(_i);
                    top = this.validateSectionAspectAux(top, sec);
                }
                for (let _i = 0; _i < this.report.getGroupsHeaders().count(); _i++) {
                    sec = this.report.getGroupsHeaders().item(_i);
                    top = this.validateSectionAspectAux(top, sec);
                }
                for (let _i = 0; _i < this.report.getDetails().count(); _i++) {
                    sec = this.report.getDetails().item(_i);
                    top = this.validateSectionAspectAux(top, sec);
                }
                for (let _i = 0; _i < this.report.getGroupsFooters().count(); _i++) {
                    sec = this.report.getGroupsFooters().item(_i);
                    top = this.validateSectionAspectAux(top, sec);
                }
                let paperInfo = this.report.getPaperInfo();
                let height = CSReports.CSReportPaint.cGlobals.getRectFromPaperSize(this.report.getPaperInfo(), paperInfo.getPaperSize(), paperInfo.getOrientation()).getHeight();
                top = height;
                this.pGetOffSet(height);
                for (let i = this.report.getFooters().count() - 1; i > -1; i--) {
                    sec = this.report.getFooters().item(i);
                    top = top - sec.getAspect().getHeight();
                    this.validateSectionAspectAux(top, sec);
                }
                this.pRefreshOffSetInPaintObjs();
            }
            validateSectionAspectAux(top, sec) {
                let secLn = null;
                let secLnHeight = 0;
                let paperInfo = this.report.getPaperInfo();
                let width = CSReports.CSReportPaint.cGlobals.getRectFromPaperSize(this.report.getPaperInfo(), paperInfo.getPaperSize(), paperInfo.getOrientation()).getWidth();
                let topLn = top;
                let aspect;
                for (let i = 0; i < sec.getSectionLines().count() - 1; i++) {
                    secLn = sec.getSectionLines().item(i);
                    aspect = secLn.getAspect();
                    aspect.setTop(topLn);
                    aspect.setWidth(width);
                    if (aspect.getHeight() < this.MIN_HEIGHT_SECTION) {
                        aspect.setHeight(this.MIN_HEIGHT_SECTION);
                    }
                    topLn = topLn + aspect.getHeight();
                    secLnHeight = secLnHeight + aspect.getHeight();
                }
                let sectionLines = sec.getSectionLines();
                secLn = sectionLines.item(sectionLines.count() - 1);
                aspect = secLn.getAspect();
                aspect.setTop(topLn);
                aspect.setHeight(sec.getAspect().getHeight() - secLnHeight);
                if (aspect.getHeight() < this.MIN_HEIGHT_SECTION) {
                    aspect.setHeight(this.MIN_HEIGHT_SECTION);
                }
                secLnHeight = secLnHeight + aspect.getHeight();
                aspect = sec.getAspect();
                aspect.setHeight(secLnHeight);
                if (aspect.getHeight() < this.MIN_HEIGHT_SECTION) {
                    aspect.setHeight(this.MIN_HEIGHT_SECTION);
                }
                aspect.setWidth(width);
                aspect.setTop(top);
                top = top + aspect.getHeight();
                this.pChangeTopSection(sec, 0, false, false);
                return top;
            }
            showControls() {
                try {
                    let f = CSReportEditor.cMainEditor.getCtrlBox(this);
                    f.clear();
                    f.addCtrls(this.report);
                    if (!f.getVisible()) {
                        f.show(this.fMain);
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            showControlsTree() {
                try {
                    let f = CSReportEditor.cMainEditor.getCtrlTreeBox(this);
                    f.clear();
                    f.addCtrls();
                    if (!f.getVisible()) {
                        f.show(this.fMain);
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            static setInitDir() {
                if (CSReportEditor.cMainEditor.gbFirstOpen) {
                    CSReportEditor.cMainEditor.gbFirstOpen = false;
                }
            }
            init() {
                this.showingProperties = false;
                this.report = new cReport();
                this.report.onProgress(this.reportProgress);
                this.report.onReportDone(this.reportDone);
                const oLaunchInfo = new cReportLaunchInfo();
                this.report.getPaperInfo().setPaperSize(this.fMain.getPaperSize());
                this.report.getPaperInfo().setOrientation(this.fMain.getOrientation());
                oLaunchInfo.setPrinter(cPrintAPI.getcPrinterFromDefaultPrinter(this.fMain.printDialog()));
                oLaunchInfo.setReportPrint(new cReportPrint());
                if (!this.report.init(oLaunchInfo))
                    return;
                this.report.setPathDefault("~");
                this.picReport.setTop(this.TOP_BODY);
                this.picRule.setLeft(0);
                this.picReport.setLeft(this.getLeftBody());
                this.keyMoving = "";
                this.keySizing = "";
                this.keyObj = "";
                this.keyFocus = "";
                this.nextNameCtrl = 0;
                this.paint = new cReportPaint();
                let paperInfo = this.report.getPaperInfo();
                let tR = new CSReportEditor.Rectangle(CSReports.CSReportPaint.cGlobals.getRectFromPaperSize(this.report.getPaperInfo(), paperInfo.getPaperSize(), paperInfo.getOrientation()));
                CSReportEditor.cGlobals.createStandardSections(this.report, tR);
                this.picReport.setMouseDownEventListner(P.call(this, this.picReportMouseDown));
                this.picReport.setMouseUpEventListner(P.call(this, this.picReportMouseUp));
                this.picReport.setMouseEventListner(P.call(this, this.picReportMouseMove));
                return this.reLoadReport();
            }
            updateFormulas(currentName, newName) {
                let rptCtrl = null;
                for (let i = 0; i < this.report.getControls().count(); i++) {
                    rptCtrl = this.report.getControls().item(i);
                    let formulaHide = rptCtrl.getFormulaHide();
                    if (formulaHide.getText() !== "") {
                        if (formulaHide.getText().indexOf(currentName, 1) !== 0) {
                            formulaHide.setText(CSReportEditor.cEditor.replaceInFormula(formulaHide.getText(), currentName, newName));
                        }
                    }
                    let formulaValue = rptCtrl.getFormulaValue();
                    if (formulaValue.getText() !== "") {
                        if (formulaValue.getText().indexOf(currentName, 1) !== 0) {
                            formulaValue.setText(CSReportEditor.cEditor.replaceInFormula(formulaValue.getText(), currentName, newName));
                        }
                    }
                }
            }
            static replaceInFormula(formulaText, currentName, newName) {
                let rtn;
                if (formulaText.substring(0, 1).trim() !== "_") {
                    const fReplace = new CSReportEditor.FFormulaReplace();
                    fReplace.getTxCurrFormula().setText(formulaText);
                    fReplace.getTxNewFormula().setText(formulaText.replaceAll(currentName, newName));
                    fReplace.showDialog();
                    if (fReplace.getOk()) {
                        rtn = fReplace.getTxNewFormula().getText();
                    }
                    else {
                        rtn = formulaText;
                    }
                    fReplace.hide();
                }
                else {
                    rtn = formulaText.replaceAll(currentName, newName);
                }
                return rtn;
            }
            editConnectionString() {
                return U.getInput(this.report.getConnect().getStrConnect(), "You can modify the string connection of this report", "String connection").then(P.call(this, (result) => {
                    if (result.success) {
                        this.report.getConnect().setStrConnect(result.value);
                    }
                }));
            }
            setDataSource(dataSource) {
                this.report.getConnect().setDataSource(dataSource);
                this.report.getConnect().setDataSourceType(csDataSourceType.CS_DT_PROCEDURE);
            }
            keyFromKey(key) {
                switch (key) {
                    case "F11": return Keys.F11;
                    case "F12": return Keys.F12;
                    case "F9": return Keys.F9;
                    case "F8": return Keys.F8;
                    case "F2": return Keys.F2;
                    case "F4": return Keys.F4;
                    case "Delete": return Keys.Delete;
                    case "Escape": return Keys.Escape;
                    case "Up": return Keys.Up;
                    case "Down": return Keys.Down;
                    case "Left": return Keys.Left;
                    case "Right": return Keys.Right;
                    case "C": return Keys.C;
                    case "V": return Keys.V;
                }
            }
        }
        cEditor.__nextId = 0;
        CSReportEditor.cEditor = cEditor;
        let Keys;
        (function (Keys) {
            Keys["F11"] = "F11";
            Keys["F12"] = "F12";
            Keys["F9"] = "F9";
            Keys["F8"] = "F8";
            Keys["F2"] = "F2";
            Keys["F4"] = "F4";
            Keys["Delete"] = "Delete";
            Keys["Escape"] = "Escape";
            Keys["Up"] = "Up";
            Keys["Down"] = "Down";
            Keys["Left"] = "Left";
            Keys["Right"] = "Right";
            Keys["C"] = "C";
            Keys["V"] = "V";
        })(Keys || (Keys = {}));
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        var csRptControlType = CSReports.CSReportGlobals.csRptControlType;
        var Color = CSReports.CSDrawing.Color;
        let csRptEditorMoveType;
        (function (csRptEditorMoveType) {
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVTHORIZONTAL"] = 0] = "CSRPTEDMOVTHORIZONTAL";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVTVERTICAL"] = 1] = "CSRPTEDMOVTVERTICAL";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVTALL"] = 2] = "CSRPTEDMOVTALL";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVLEFT"] = 3] = "CSRPTEDMOVLEFT";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVRIGHT"] = 4] = "CSRPTEDMOVRIGHT";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVUP"] = 5] = "CSRPTEDMOVUP";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVDOWN"] = 6] = "CSRPTEDMOVDOWN";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVLEFTDOWN"] = 7] = "CSRPTEDMOVLEFTDOWN";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVLEFTUP"] = 8] = "CSRPTEDMOVLEFTUP";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVRIGHTDOWN"] = 9] = "CSRPTEDMOVRIGHTDOWN";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVRIGHTUP"] = 10] = "CSRPTEDMOVRIGHTUP";
            csRptEditorMoveType[csRptEditorMoveType["CSRPTEDMOVTNONE"] = 11] = "CSRPTEDMOVTNONE";
        })(csRptEditorMoveType = CSReportEditor.csRptEditorMoveType || (CSReportEditor.csRptEditorMoveType = {}));
        let csRptEditCtrlType;
        (function (csRptEditCtrlType) {
            csRptEditCtrlType[csRptEditCtrlType["none"] = 0] = "none";
            csRptEditCtrlType[csRptEditCtrlType["label"] = 1] = "label";
            csRptEditCtrlType[csRptEditCtrlType["field"] = 2] = "field";
            csRptEditCtrlType[csRptEditCtrlType["formula"] = 3] = "formula";
            csRptEditCtrlType[csRptEditCtrlType["image"] = 4] = "image";
            csRptEditCtrlType[csRptEditCtrlType["chart"] = 5] = "chart";
            csRptEditCtrlType[csRptEditCtrlType["lineLabel"] = 6] = "lineLabel";
        })(csRptEditCtrlType = CSReportEditor.csRptEditCtrlType || (CSReportEditor.csRptEditCtrlType = {}));
        class cGlobals {
            static setStatus() {
            }
            static setEditAlignTextState(state) {
                this.implementThisMessage("setEditAlignTextState", "(CSReportEditor cGlobals)");
            }
            static setEditAlignCtlState(b) {
                this.implementThisMessage("setEditAlignCtlState", "(CSReportEditor cGlobals)");
            }
            static setEditFontBoldValue(bBold) {
                this.implementThisMessage("setEditFontBoldValue", "(CSReportEditor cGlobals)");
            }
            static setEditAlignValue(align) {
                this.implementThisMessage("setEditAlignValue", "(CSReportEditor cGlobals)");
            }
            static setParametersAux(connect, rptConnect) {
                rptConnect.getColumns().clear();
                rptConnect.getParameters().clear();
                for (let i = 0; i < connect.getColumnsInfo().count(); i++) {
                    let colInfo = connect.getColumnsInfo().item(i);
                    let rptColInfo = new CSReports.CSReportEngine.cColumnInfo();
                    rptColInfo.setName(colInfo.getName());
                    rptColInfo.setPosition(colInfo.getPosition());
                    rptColInfo.setColumnType(colInfo.getColumnType());
                    rptConnect.getColumns().add(rptColInfo, "");
                }
                for (let i = 0; i < connect.getParameters().count(); i++) {
                    let parameter = connect.getParameters().item(i);
                    let rptParameter = new CSReports.CSReportEngine.cParameter();
                    rptParameter.setName(parameter.getName());
                    rptParameter.setPosition(parameter.getPosition());
                    rptParameter.setColumnType(parameter.getColumnType());
                    rptParameter.setValue(parameter.getValue());
                    rptConnect.getParameters().add(rptParameter, "");
                }
            }
            static moveGroup(group, editor) {
                throw new NotImplementedException();
            }
            static getDataSourceStr(dataSource) {
                return "{" + dataSource + "}.";
            }
            static createStandardSections(report, tr) {
                report.getHeaders().add(null, cGlobals.KEY_HEADER);
                report.getFooters().add(null, cGlobals.KEY_FOOTER);
                report.getDetails().add(null, cGlobals.KEY_DETAIL);
                let sec = report.getHeaders().item(cGlobals.KEY_HEADER);
                sec.setName("Main header");
                let aspect = sec.getAspect();
                aspect.setTop(0);
                aspect.setHeight(tr.height * 0.25);
                aspect.setWidth(tr.width);
                let secLn = sec.getSectionLines().item(0);
                secLn.setSectionName("Main header");
                aspect = secLn.getAspect();
                aspect.setTop(0);
                aspect.setHeight(tr.height * 0.25);
                aspect.setWidth(tr.width);
                sec = report.getDetails().item(cGlobals.KEY_DETAIL);
                sec.setName("Detail");
                aspect = sec.getAspect();
                aspect.setTop(tr.height * 0.25);
                aspect.setHeight(tr.height * 0.25);
                aspect.setWidth(tr.width);
                secLn = sec.getSectionLines().item(0);
                secLn.setSectionName("Detail");
                aspect = secLn.getAspect();
                aspect.setTop(tr.height * 0.25);
                aspect.setHeight(tr.height * 0.25);
                aspect.setWidth(tr.width);
                sec = report.getFooters().item(cGlobals.KEY_FOOTER);
                sec.setName("Main footer");
                aspect = sec.getAspect();
                aspect.setTop(tr.height * 0.75);
                aspect.setHeight(tr.height * 0.25);
                aspect.setWidth(tr.width);
                secLn = sec.getSectionLines().item(0);
                secLn.setSectionName("Main footer");
                aspect = secLn.getAspect();
                aspect.setTop(tr.height * 0.75);
                aspect.setHeight(tr.height * 0.25);
                aspect.setWidth(tr.width);
            }
            static clearCtrlBox(editor) {
                throw new NotImplementedException();
            }
            static implementThisMessage(functionName, moduleName) {
            }
            static addCtrls(report, lvControls, ctrlImage, dbImage) {
                lvControls.clear();
                lvControls.createHeaders(['Name', 'F hide', 'F value', 'Db field']);
                for (let i = 0; i < report.getControls().count(); i++) {
                    let ctrl = report.getControls().item(i);
                    let ctrlName = ctrl.getName();
                    let ctrlInfo = "";
                    let ctrlField = "";
                    switch (ctrl.getControlType()) {
                        case csRptControlType.RPT_CT_FIELD:
                            ctrlField = ctrl.getField().getName();
                            break;
                        case csRptControlType.RPT_CT_DB_IMAGE:
                            ctrlInfo = ctrl.getField().getName();
                            break;
                        case csRptControlType.RPT_CT_IMAGE:
                            ctrlInfo = " (Image)";
                            break;
                        case csRptControlType.RPT_CT_LABEL:
                            ctrlInfo = ctrl.getLabel().getText();
                            break;
                    }
                    if (ctrlInfo.length > 0) {
                        ctrlName += " (" + ctrlInfo + ")";
                    }
                    let item = lvControls.add(ctrlName, ctrlImage);
                    item.tag = ctrl.getKey();
                    item.subItems.add("");
                    item.subItems.add("");
                    item.subItems.add("");
                    if (ctrl.getHasFormulaValue())
                        item.subItems.item(1).setText("*");
                    if (ctrl.getHasFormulaHide())
                        item.subItems.item(2).setText("*");
                    if (ctrlField.length > 0) {
                        item.subItems.item(3).setText(ctrlField);
                        item.subItems.item(3).setForeColor(Color.Blue);
                        item.setImageIndex(dbImage);
                    }
                    if (ctrl.getName().length > 4 && ctrl.getName().substring(0, 4) === "lnk_") {
                        item.setForeColor(Color.Red);
                    }
                }
            }
            static addCtrls2(report, tv_controls, folderImage, formulaImage, controlImage, databaseFieldImage) {
                tv_controls.clear();
                let nodeRoot = tv_controls.getNodes().add(report.getName(), folderImage);
                let nodeGroup = nodeRoot.getNodes().add("Headers", folderImage);
                this.pAddCtrlsAux(report.getHeaders(), nodeGroup, folderImage, formulaImage, controlImage, databaseFieldImage);
                nodeGroup = nodeRoot.getNodes().add("Group Header", folderImage);
                this.pAddCtrlsAux(report.getGroupsHeaders(), nodeGroup, folderImage, formulaImage, controlImage, databaseFieldImage);
                nodeGroup = nodeRoot.getNodes().add("Details", folderImage);
                this.pAddCtrlsAux(report.getDetails(), nodeGroup, folderImage, formulaImage, controlImage, databaseFieldImage);
                nodeGroup = nodeRoot.getNodes().add("Group Footer", folderImage);
                this.pAddCtrlsAux(report.getGroupsFooters(), nodeGroup, folderImage, formulaImage, controlImage, databaseFieldImage);
                nodeGroup = nodeRoot.getNodes().add("Footers", folderImage);
                this.pAddCtrlsAux(report.getFooters(), nodeGroup, folderImage, formulaImage, controlImage, databaseFieldImage);
                nodeRoot.expandAll();
            }
            static pAddCtrlsAux(sections, father, folderImage, formulaImage, controlImage, databaseFieldImage) {
                let nodeSec;
                let nodeSecLn;
                let nodeCtrl;
                let item;
                let text;
                let bComplexF = false;
                let sec;
                let secLn;
                let ctrl;
                for (let i = 0; i < sections.count(); i++) {
                    sec = sections.item(i);
                    nodeSec = father.getNodes().add(sec.getName(), folderImage);
                    nodeSec.tag = "S" + sec.getKey();
                    if (sec.getFormulaHide().getText() !== "") {
                        if (sec.getFormulaHide().getText() === "0") {
                            text = "Hidden";
                            bComplexF = false;
                        }
                        else {
                            text = "Visibility formula";
                            bComplexF = true;
                        }
                        item = nodeSec.getNodes().add(text, formulaImage);
                        item.selectedImageIndex = formulaImage;
                        if (!sec.getHasFormulaHide()) {
                            item.foreColor = Color.Red.toString();
                        }
                        if (bComplexF) {
                            item.tag = "@FH=" + sec.getFormulaHide().getText();
                        }
                    }
                    for (let j = 0; j < sec.getSectionLines().count(); j++) {
                        secLn = sec.getSectionLines().item(j);
                        nodeSecLn = nodeSec.getNodes().add("Line " + secLn.getRealIndex(), folderImage);
                        nodeSecLn.tag = "L" + secLn.getKey();
                        if (secLn.getFormulaHide().getText() !== "") {
                            if (secLn.getFormulaHide().getText() === "0") {
                                text = "Hidden";
                                bComplexF = false;
                            }
                            else {
                                text = "Visibility formula";
                                bComplexF = true;
                            }
                            item = nodeSecLn.getNodes().add(text, formulaImage);
                            item.selectedImageIndex = formulaImage;
                            if (!secLn.getHasFormulaHide()) {
                                item.foreColor = Color.Red.toString();
                            }
                            if (bComplexF) {
                                item.tag = "@FH=" + secLn.getFormulaHide().getText();
                            }
                        }
                        for (let t = 0; t < secLn.getControls().count(); t++) {
                            ctrl = secLn.getControls().item(t);
                            nodeCtrl = nodeSecLn.getNodes().add(ctrl.getName()
                                + (ctrl.getLabel().getText() !== ""
                                    ? " - " + ctrl.getLabel().getText()
                                    : ""), controlImage);
                            nodeCtrl.selectedImageIndex = controlImage;
                            nodeCtrl.tag = ctrl.getKey();
                            nodeCtrl.backColor = ctrl.getLabel().getAspect().getBackColor();
                            nodeCtrl.foreColor = ctrl.getLabel().getAspect().getFont().getForeColor();
                            if (ctrl.getControlType() === csRptControlType.RPT_CT_FIELD) {
                                item = nodeCtrl.getNodes().add(ctrl.getField().getName(), databaseFieldImage);
                                item.selectedImageIndex = databaseFieldImage;
                            }
                            if (ctrl.getFormulaHide().getText() !== "") {
                                if (ctrl.getFormulaHide().getText() === "0") {
                                    text = "hidden";
                                    bComplexF = false;
                                }
                                else {
                                    text = "Visibility formula";
                                    bComplexF = true;
                                }
                                item = nodeCtrl.getNodes().add(text, formulaImage);
                                item.selectedImageIndex = formulaImage;
                                if (!ctrl.getHasFormulaHide()) {
                                    item.foreColor = Color.Red.toString();
                                }
                                if (bComplexF) {
                                    item.tag = "@FH=" + ctrl.getFormulaHide().getText();
                                }
                            }
                            if (ctrl.getFormulaValue().getText() !== "") {
                                item = nodeCtrl.getNodes().add("Value formula", formulaImage);
                                item.selectedImageIndex = formulaImage;
                                if (!ctrl.getHasFormulaValue()) {
                                    item.foreColor = Color.Red.toString();
                                }
                                item.tag = "@FV=" + ctrl.getFormulaValue().getText();
                            }
                        }
                    }
                }
                father.expandAll();
            }
            static fillColumns(dataSource, columns, lvColumns, index, fieldType, add) {
                if (!add) {
                    lvColumns.clear();
                    lvColumns.createHeaders(['Name']);
                }
                for (let i_ = 0; i_ < columns.count(); i_++) {
                    let column = columns.item(i_);
                    var item = lvColumns.add(`{${dataSource}}.${column.getName()}`);
                    item.setImageIndex(0);
                    let info = U.setInfoString("", index, column.getPosition().toString());
                    info = U.setInfoString(info, fieldType, column.getColumnType().toString());
                    item.tag = info;
                }
            }
        }
        cGlobals.KEY_HEADER = "RH";
        cGlobals.KEY_FOOTER = "RF";
        cGlobals.KEY_DETAIL = "RD";
        cGlobals.KEY_GROUPH = "GH";
        cGlobals.KEY_GROUPF = "GF";
        cGlobals.BTN_PRINT = "PRINT";
        cGlobals.BTN_PROPERTIES = "PROPERTIES";
        cGlobals.BTN_DB = "DB";
        cGlobals.BTN_SAVE = "SAVE";
        cGlobals.BTN_OPEN = "OPEN";
        cGlobals.BTN_TOOL = "TOOL";
        cGlobals.BTN_NEW = "NEW";
        cGlobals.BTN_PREV = "PREV";
        cGlobals.BTN_ALIGN_LEFT = "ALIGN_LEFT";
        cGlobals.BTN_ALIGN_CENTER = "ALIGN_CENTER";
        cGlobals.BTN_ALIGN_RIGHT = "ALIGN_RIGHT";
        cGlobals.BTN_FONT_BOLD = "FONT_BOLD";
        cGlobals.BTN_SEARCH = "SEARCH";
        cGlobals.BTN_CTL_ALIGN_TOP = "CTL_ALIGN_TOP";
        cGlobals.BTN_CTL_ALIGN_BOTTOM = "CTL_ALIGN_BOTTOM";
        cGlobals.BTN_CTL_ALIGN_VERTICAL = "CTL_ALIGN_VERTICAL";
        cGlobals.BTN_CTL_ALIGN_HORIZONTAL = "CTL_ALIGN_HORIZONTAL";
        cGlobals.BTN_CTL_ALIGN_LEFT = "CTL_ALIGN_LEFT";
        cGlobals.BTN_CTL_ALIGN_RIGHT = "CTL_ALIGN_RIGHT";
        cGlobals.BTN_CTL_WIDTH = "CTL_WIDTH";
        cGlobals.BTN_CTL_HEIGHT = "CTL_HEIGHT";
        cGlobals.CONTROL_NAME = "Control";
        cGlobals.TOT_IN_RECENT_LIST = 7;
        cGlobals.HEIGHT_NEW_SECTION = 23;
        cGlobals.HEIGHT_BAR_SECTION = 8;
        cGlobals.NO_CHANGE = -32768;
        cGlobals.MAIN_HEADER = "Main Header";
        cGlobals.MAIN_DETAIL = "Detail";
        cGlobals.MAIN_FOOTER = "Main Footer";
        cGlobals.GROUP_LABEL = "Group";
        cGlobals.ShiftMask = 1;
        CSReportEditor.cGlobals = cGlobals;
        class Rectangle {
            constructor(rect) {
                this.height = null;
                this.width = null;
                this.height = rect.getHeight();
                this.width = rect.getWidth();
            }
        }
        CSReportEditor.Rectangle = Rectangle;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var cError = CSReports.CSKernelClient.cError;
        var U = CSReports.CSOAPI.Utils;
        class cMainEditor {
            constructor() {
                this.csNoDate = new Date("1900-01-01T00:00:00Z");
                this.C_HEIGHT_BAR_SECTION = 120;
                this.C_HEIGHT_NEW_SECTION = 350;
            }
            static runningInBrowser() {
                return true;
            }
            static initEditor() {
                if (this.fMain === null) {
                    this.fMain = new CSReportEditor.FMain();
                    this.fMain.init();
                }
            }
            static getEditor() {
                return this.fMain;
            }
            static getDocActive() {
                return this.editor;
            }
            static setDocActive(maybeEditor) {
                this.setMenu();
                this.editor = maybeEditor;
                const editor = this.editor;
                if (editor !== null && editor.isEditor()) {
                    if (this.fToolbox !== null && U.isVisible(this.fToolbox)) {
                        if (this.getToolbox(editor) !== null) {
                            editor.showToolbox();
                        }
                    }
                    if (this.fControls !== null && U.isVisible(this.fControls)) {
                        if (this.getCtrlBox(editor) !== null) {
                            editor.showControls();
                        }
                    }
                    if (this.fTreeViewCtrls !== null && U.isVisible(this.fTreeViewCtrls)) {
                        if (this.getCtrlTreeBox(editor) !== null) {
                            editor.showControlsTree();
                        }
                    }
                    this.fMain.setZoom((editor.getZoom() * 100).toString());
                }
                else {
                    if (this.fToolbox !== null && U.isVisible(this.fToolbox)) {
                        this.fToolbox.clear();
                    }
                    if (this.fControls !== null && U.isVisible(this.fControls)) {
                        this.fControls.clear();
                    }
                    if (this.fTreeViewCtrls !== null && U.isVisible(this.fTreeViewCtrls)) {
                        this.fTreeViewCtrls.clear();
                    }
                }
                this.fMain.showControls(editor);
                this.fMain.showControlsTree(editor);
                this.fMain.showFields(editor);
                this.clearProperties();
                this.showProperties();
            }
            static setDocInacActive(editor) {
                if (this.editor !== editor) {
                    return;
                }
                this.editor = null;
                this.setMenu();
                this.setEditAlignTextState(false);
            }
            static setStatus() {
                try {
                    if (this.editor === null) {
                        this.setStatusAux("");
                    }
                    else {
                        this.setStatusAux(this.pGetStatus());
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            static setStatusAux(status) {
            }
            static setBarText(text) {
            }
            static setDisconnectedReport(isDisconnectedReport) {
            }
            static setEditAlignTextState(status) {
                this.fMain.setEditAlignTextState(status);
            }
            static setEditAlignCtlState(status) {
                this.fMain.setEditAlignCtlState(status);
            }
            static setMenuAux(enabled) {
                this.fMain.setMenuAux(enabled);
            }
            static addToRecentList(fileName) {
                this.fMain.addToRecentList(fileName);
            }
            static setEditFontBoldValue(bBold) {
            }
            static setMenu() {
                const editor = this.editor;
                try {
                    if (this.editor === null
                        || !this.editor.isEditor()
                        || editor.getReport() === null) {
                        this.fMain.setMenuAux(false);
                        this.fMain.setBarText("");
                        this.fMain.setStatus("");
                    }
                    else {
                        this.fMain.setMenuAux(true);
                        this.fMain.setBarText(editor.getReport().getName());
                        this.fMain.setStatus(this.pGetStatus());
                    }
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            static pGetStatus() {
                return "";
            }
            static getToolbox(editor) {
                if (this.fToolbox === null) {
                    this.fToolbox = new CSReportEditor.FToolbox();
                }
                if (editor)
                    this.fToolbox.setHandler(editor);
                return this.fToolbox;
            }
            static getCtrlBox(editor) {
                if (this.fControls === null) {
                    this.fControls = new CSReportEditor.FControls();
                }
                if (editor)
                    this.fControls.setHandler(editor);
                return this.fControls;
            }
            static getCtrlTreeBox(editor) {
                if (this.fTreeViewCtrls === null) {
                    this.fTreeViewCtrls = new CSReportEditor.FTreeViewCtrls();
                }
                if (editor)
                    this.fTreeViewCtrls.setHandler(editor);
                return this.fTreeViewCtrls;
            }
            static clearToolbox(editor) {
                if (this.editor === editor) {
                    if (this.fToolbox !== null && U.isVisible(this.fToolbox)) {
                        this.fToolbox.clear();
                    }
                }
            }
            static clearProperties() {
                this.getPropertyDlg().clear();
                this.getPropertyDlg().disable();
                this.getPropertyDlg().displayCtrlPropertyTabs();
                this.getPropertyDlg().showCtrlPropertyTabs();
                this.fMain.clearProperties();
            }
            static showProperties(key, isSection = false) {
                if (this.editor === null || !this.editor.isEditor())
                    return;
                const editor = this.editor;
                if (key === undefined) {
                    key = editor.getSelectedKey();
                    isSection = editor.getSelectedKeyIsSection();
                }
                if (isSection) {
                    this.clearProperties();
                    editor.showSelectedSectionProperties();
                }
                else {
                    editor.showSelectedCtrlProperties();
                }
                this.fMain.showProperties(editor, key);
            }
            static getPropertyDlg() {
                return this.fMain.getPropertyDlg();
            }
            static showPropertyTab(tab) {
                this.fMain.getPropertyDlg().selectTab(tab);
            }
            static showSideBarTab(tab) {
                U.el('sidebar-tv-controls').style.display = tab === 'sidebar-tv-controls' ? 'block' : 'none';
                U.el('sidebar-lv-controls').style.display = tab === 'sidebar-lv-controls' ? 'block' : 'none';
                U.el('sidebar-lv-properties').style.display = tab === 'sidebar-lv-properties' ? 'block' : 'none';
                U.el('sidebar-lv-database').style.display = tab === 'sidebar-lv-database' ? 'block' : 'none';
                U.el('sidebar-tv-controls-tab').style.backgroundColor = tab === 'sidebar-tv-controls' ? '#ddd' : '#bcb8b8';
                U.el('sidebar-lv-controls-tab').style.backgroundColor = tab === 'sidebar-lv-controls' ? '#ddd' : '#bcb8b8';
                U.el('sidebar-lv-properties-tab').style.backgroundColor = tab === 'sidebar-lv-properties' ? '#ddd' : '#bcb8b8';
                U.el('sidebar-lv-database-tab').style.backgroundColor = tab === 'sidebar-lv-database' ? '#ddd' : '#bcb8b8';
            }
            static toggleSideBarTab() {
                this.wideSidebar = !this.wideSidebar;
                if (this.wideSidebar) {
                    U.el('sidebar').style.width = "790px";
                    U.el('sidebar-toogle-width').textContent = "<<";
                }
                else {
                    U.el('sidebar').style.width = "254px";
                    U.el('sidebar-toogle-width').textContent = ">>";
                }
            }
            static hideOrShowSideBarTab() {
                this.wideSidebar2 = !this.wideSidebar2;
                let display;
                let margin;
                let editorWidth;
                if (this.wideSidebar2) {
                    display = 'none';
                    U.el('sidebar').style.display = "none";
                    U.el('sidebar-toogle-hide').textContent = ">>";
                    U.elc('sidebar-tab', document.documentElement).style.width = "40px";
                    margin = "0px";
                    editorWidth = "calc(100% - 505px)";
                }
                else {
                    display = 'block';
                    U.el('sidebar').style.display = "block";
                    U.el('sidebar-toogle-hide').textContent = "<<";
                    U.elc('sidebar-tab', document.documentElement).style.width = "310px";
                    margin = "315px";
                    editorWidth = "calc(100% - 820px)";
                }
                const editors = document.getElementsByClassName('editor');
                Array.from(editors).forEach((el) => {
                    el.style.marginLeft = margin;
                    el.style.width = editorWidth;
                });
                U.el('sidebar-toogle-width').style.display = display;
                U.el('sidebar-lv-properties-tab').style.display = display;
                U.el('sidebar-lv-database-tab').style.display = display;
                U.el('sidebar-lv-controls-tab').style.display = display;
                U.el('sidebar-tv-controls-tab').style.display = display;
            }
        }
        cMainEditor.editor = null;
        cMainEditor.fToolbox = null;
        cMainEditor.fControls = null;
        cMainEditor.fTreeViewCtrls = null;
        cMainEditor.fSearch = null;
        cMainEditor.gBackColor = 0;
        cMainEditor.gHideLeftBar = false;
        cMainEditor.gWorkFolder = "";
        cMainEditor.gbFirstOpen = false;
        cMainEditor.fMain = null;
        cMainEditor.wideSidebar = false;
        cMainEditor.wideSidebar2 = false;
        CSReportEditor.cMainEditor = cMainEditor;
        let SpecialFolderIDs;
        (function (SpecialFolderIDs) {
            SpecialFolderIDs[SpecialFolderIDs["SFIDDESKTOP"] = 0] = "SFIDDESKTOP";
            SpecialFolderIDs[SpecialFolderIDs["SFIDPROGRAMS"] = 2] = "SFIDPROGRAMS";
            SpecialFolderIDs[SpecialFolderIDs["SFIDPERSONAL"] = 5] = "SFIDPERSONAL";
            SpecialFolderIDs[SpecialFolderIDs["SFIDFAVORITES"] = 6] = "SFIDFAVORITES";
            SpecialFolderIDs[SpecialFolderIDs["SFIDSTARTUP"] = 7] = "SFIDSTARTUP";
            SpecialFolderIDs[SpecialFolderIDs["SFIDRECENT"] = 8] = "SFIDRECENT";
            SpecialFolderIDs[SpecialFolderIDs["SFIDSENDTO"] = 9] = "SFIDSENDTO";
            SpecialFolderIDs[SpecialFolderIDs["SFIDSTARTMENU"] = 11] = "SFIDSTARTMENU";
            SpecialFolderIDs[SpecialFolderIDs["SFIDDESKTOPDIRECTORY"] = 16] = "SFIDDESKTOPDIRECTORY";
            SpecialFolderIDs[SpecialFolderIDs["SFIDNETHOOD"] = 19] = "SFIDNETHOOD";
            SpecialFolderIDs[SpecialFolderIDs["SFIDFONTS"] = 20] = "SFIDFONTS";
            SpecialFolderIDs[SpecialFolderIDs["SFIDTEMPLATES"] = 21] = "SFIDTEMPLATES";
            SpecialFolderIDs[SpecialFolderIDs["SFIDCOMMON_STARTMENU"] = 22] = "SFIDCOMMON_STARTMENU";
            SpecialFolderIDs[SpecialFolderIDs["SFIDCOMMON_PROGRAMS"] = 23] = "SFIDCOMMON_PROGRAMS";
            SpecialFolderIDs[SpecialFolderIDs["SFIDCOMMON_STARTUP"] = 24] = "SFIDCOMMON_STARTUP";
            SpecialFolderIDs[SpecialFolderIDs["SFIDCOMMON_DESKTOPDIRECTORY"] = 25] = "SFIDCOMMON_DESKTOPDIRECTORY";
            SpecialFolderIDs[SpecialFolderIDs["SFIDAPPDATA"] = 26] = "SFIDAPPDATA";
            SpecialFolderIDs[SpecialFolderIDs["SFIDPRINTHOOD"] = 27] = "SFIDPRINTHOOD";
            SpecialFolderIDs[SpecialFolderIDs["SFIDPROGRAMS_FILES"] = 38] = "SFIDPROGRAMS_FILES";
            SpecialFolderIDs[SpecialFolderIDs["SFIDPROGRAMFILES"] = 65536] = "SFIDPROGRAMFILES";
            SpecialFolderIDs[SpecialFolderIDs["SFIDCOMMONFILES"] = 65537] = "SFIDCOMMONFILES";
        })(SpecialFolderIDs = CSReportEditor.SpecialFolderIDs || (CSReportEditor.SpecialFolderIDs = {}));
        let csEAlignConst;
        (function (csEAlignConst) {
            csEAlignConst[csEAlignConst["CSEALIGNTEXTLEFT"] = 1] = "CSEALIGNTEXTLEFT";
            csEAlignConst[csEAlignConst["CSEALIGNTEXTRIGHT"] = 2] = "CSEALIGNTEXTRIGHT";
            csEAlignConst[csEAlignConst["CSEALIGNTEXTCENTER"] = 3] = "CSEALIGNTEXTCENTER";
            csEAlignConst[csEAlignConst["CSEALIGNCTLLEFT"] = 4] = "CSEALIGNCTLLEFT";
            csEAlignConst[csEAlignConst["CSEALIGNCTLHORIZONTAL"] = 5] = "CSEALIGNCTLHORIZONTAL";
            csEAlignConst[csEAlignConst["CSEALIGNCTLRIGHT"] = 6] = "CSEALIGNCTLRIGHT";
            csEAlignConst[csEAlignConst["CSEALIGNCTLVERTICAL"] = 7] = "CSEALIGNCTLVERTICAL";
            csEAlignConst[csEAlignConst["CSEALIGNCTLTOP"] = 8] = "CSEALIGNCTLTOP";
            csEAlignConst[csEAlignConst["CSEALIGNCTLBOTTOM"] = 9] = "CSEALIGNCTLBOTTOM";
            csEAlignConst[csEAlignConst["CSEALIGNCTLWIDTH"] = 10] = "CSEALIGNCTLWIDTH";
            csEAlignConst[csEAlignConst["CSEALIGNCTLHEIGHT"] = 11] = "CSEALIGNCTLHEIGHT";
        })(csEAlignConst = CSReportEditor.csEAlignConst || (CSReportEditor.csEAlignConst = {}));
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        class cReportEditorError {
            static errGetDescription(rptErrCode) {
                switch (rptErrCode) {
                    case csRptEditorErrors.CSRPT_EDITOR_SECTION_TYPE_INVALID:
                        return "The section type of the section argument passed to function getHeightOfSectionsBellowMe is not valid.";
                    default:
                        return "There is not information for this error";
                }
            }
        }
        CSReportEditor.cReportEditorError = cReportEditorError;
        let csRptEditorErrors;
        (function (csRptEditorErrors) {
            csRptEditorErrors[csRptEditorErrors["CSRPT_EDITOR_SECTION_TYPE_INVALID"] = 2001] = "CSRPT_EDITOR_SECTION_TYPE_INVALID";
        })(csRptEditorErrors = CSReportEditor.csRptEditorErrors || (CSReportEditor.csRptEditorErrors = {}));
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Exception = CSReports.CSOAPI.Exception;
        class ReportEditorException extends Exception {
        }
        CSReportEditor.ReportEditorException = ReportEditorException;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var ListView = CSReports.CSForms.ListView;
        class FColumns extends Form {
            constructor() {
                super();
                this.C_FIELDTYPE = "t";
                this.C_INDEX = "i";
                this.field = "";
                this.fieldType = -1;
                this.fieldIndex = -1;
                this.el = U.el('db-columns-dlg');
                this.dialog = new Dialog(this.el, 'db-columns-dlg-apply', 'db-columns-dlg-cancel');
                this.lvColumns = new ListView("lvColumns", U.el("db-columns-lv-columns"));
                this.lvColumns.state.onclick = P.call(this, this.lvColumnsClick);
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                super.setDialog(this.dialog);
            }
            cmdApplyClick() {
                return true;
            }
            clearColumns() {
                this.lvColumns.clear();
            }
            fillColumns(dataSource, columns, add) {
                CSReportEditor.cGlobals.fillColumns(dataSource, columns, this.lvColumns, this.C_INDEX, this.C_FIELDTYPE, add);
            }
            setField(field) {
                this.field = field;
                for (let i = 0; i < this.lvColumns.getItems().length; i++) {
                    const item = this.lvColumns.getItems()[i];
                    if (item.getText() === field) {
                        item.setSelected(true);
                        item.setFocused(true);
                        this.lvColumns.select();
                        break;
                    }
                }
            }
            getField() {
                return this.field;
            }
            getFieldType() {
                return this.fieldType;
            }
            getIndex() {
                return this.fieldIndex;
            }
            lvColumnsClick() {
                if (this.lvColumns.selectedItems().length > 0) {
                    let item = this.lvColumns.selectedItems()[0];
                    this.field = item.getText();
                    let info = item.tag.toString();
                    this.fieldType = U.valInt(U.getInfoString(info, this.C_FIELDTYPE, "-1"));
                    this.fieldIndex = U.valInt(U.getInfoString(info, this.C_INDEX, "-1"));
                }
            }
            showModal() {
                return this.dialog.show({ title: 'Columns', height: 600, width: 500, overlay: true })
                    .then(P.call(this, (result) => {
                    if (result)
                        return {
                            success: true,
                            field: this.field,
                            fieldType: this.fieldType,
                            fieldIndex: this.fieldIndex
                        };
                    else
                        return {
                            success: false,
                            field: null,
                            fieldType: null,
                            fieldIndex: null
                        };
                }));
            }
        }
        CSReportEditor.FColumns = FColumns;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var ListView = CSReports.CSForms.ListView;
        class FConnectsAux extends Form {
            constructor() {
                super();
                this.el = U.el('connect-aux-dlg');
                this.dialog = new Dialog(this.el, 'connect-aux-dlg-apply');
                this.lvConnections = new ListView("lvConnections", U.el("connect-aux-lv-connections"));
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                super.setDialog(this.dialog);
            }
            cmdApplyClick() {
                return true;
            }
            clear() {
                this.lvConnections.clear();
                this.lvConnections.createHeaders(['Data Source', 'Str Connect']);
            }
            addConnect(dataSource, strConnect) {
                var item = this.lvConnections.add(dataSource);
                item.subItems.add(strConnect);
            }
            removeConnect(dataSource) {
                for (let i = 0; i < this.lvConnections.getItems().length; i++) {
                    if (this.lvConnections.getItems()[i].getText() === dataSource) {
                        this.lvConnections.remove(i);
                        break;
                    }
                }
            }
            getSelectedDataSource() {
                let dataSource = null;
                if (this.lvConnections.selectedItems().length > 0) {
                    dataSource = this.lvConnections.selectedItems()[0].getText();
                }
                return dataSource;
            }
            showModal() {
                return this.dialog.show({ title: 'Connections', height: 600, width: 1200, overlay: true })
                    .then(P.call(this, (result) => {
                    if (result)
                        return {
                            success: true
                        };
                    else
                        return {
                            success: false
                        };
                }));
            }
        }
        CSReportEditor.FConnectsAux = FConnectsAux;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        class FControls extends Form {
            constructor() {
                super();
                this.editor = null;
                this.C_CTRL_IMAGE = 1;
                this.C_DB_IMAGE = 0;
                this.lvwColumnSorter = null;
            }
            clear() {
            }
            addCtrls(report) {
            }
            setHandler(editor) {
                this.editor = editor;
            }
            fControls_Load(sender, e) {
            }
            lv_controls_ColumnClick(sender, e) {
            }
            lv_controls_MouseClick(sender, e) {
            }
            lv_controls_KeyUp(sender, e) {
            }
            selectControl() {
            }
            cmd_close_Click(sender, e) {
            }
            cmd_edit_Click(sender, e) {
            }
        }
        CSReportEditor.FControls = FControls;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var csRptControlType = CSReports.CSReportGlobals.csRptControlType;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var TreeView = CSReports.CSForms.TreeView;
        var Label = CSReports.CSForms.Label;
        var TextBox = CSReports.CSForms.TextBox;
        var Dialog = CSReports.CSForms.Dialog;
        class FFormula extends Form {
            constructor() {
                super();
                this.KEY_SYS_FUNCTIONS = "FS";
                this.KEY_SYS_VARS = "VS";
                this.KEY_SYS_LABELS = "VL";
                this.KEY_SYS_DB_FIELDS = "VC";
                this.FUN_ID = "I";
                this.FUN_DESCRIP = "D";
                this.FUN_NAME = "N";
                this.HELP_CONTEXT_ID = "H";
                this.IS_DB_FIELD_OR_LABEL = "FL";
                this.FOLDER_INDEX = 0;
                this.DATABSE_INDEX = 1;
                this.LABEL_INDEX = 2;
                this.FORMULA_INDEX = 3;
                this.editor = null;
                this.tvFormulas = null;
                this.txFormula = null;
                this.lbDescription = null;
                this.el = U.el('formula-dlg');
                this.dialog = new Dialog(this.el, 'formula-dlg-apply', 'formula-dlg-cancel');
                this.tvFormulas = new TreeView("tvFormulas", U.el("formula-dlg-tree"), "*");
                this.tvFormulas.state.onclick = P.call(this, this.tvFormulasNodeClick);
                this.tvFormulas.state.onDblclick = P.call(this, this.tvFormulasDoubleClick);
                this.txFormula = new TextBox(U.inputEl("formula-dlg-code"));
                this.lbDescription = new Label(U.labelEl("formula-dlg-description"));
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                super.setDialog(this.dialog);
            }
            showModal() {
                return this.dialog.show({ title: 'Formulas', height: 500, width: 800, overlay: true });
            }
            createTree() {
                this.tvFormulas.clear();
                this.tvFormulas.getNodes().add("Internal functions", this.FOLDER_INDEX, this.KEY_SYS_FUNCTIONS);
                const item = this.tvFormulas.getNodes().add("Internal variables", this.FOLDER_INDEX, this.KEY_SYS_VARS);
                item.getNodes().add("Database fields", 0, this.KEY_SYS_DB_FIELDS);
                item.getNodes().add("Labels", 0, this.KEY_SYS_LABELS);
                const report = this.editor.getReport();
                for (let _i = 0; _i < report.getFormulaTypes().count(); _i++) {
                    let f = report.getFormulaTypes().item(_i);
                    this.addFormula(f.getId(), f.getName(), f.getNameUser(), f.getDecrip(), f.getHelpContextId());
                }
                for (let _i = 0; _i < report.getControls().count(); _i++) {
                    let c = report.getControls().item(_i);
                    if (c.getControlType() === csRptControlType.RPT_CT_FIELD) {
                        this.addDBField(c.getName(), c.getField().getName());
                    }
                    else if (c.getControlType() === csRptControlType.RPT_CT_LABEL) {
                        this.addLabel(c.getName());
                    }
                }
            }
            addFormula(formulaType, name, nameUser, descrip, helpContextId) {
                const item = this.tvFormulas.getNodes().item(this.KEY_SYS_FUNCTIONS).getNodes().add(nameUser, this.FORMULA_INDEX);
                item.selectedImageIndex = item.imageIndex;
                let info = "";
                info = U.setInfoString(info, this.FUN_ID, formulaType.toString());
                info = U.setInfoString(info, this.FUN_DESCRIP, descrip);
                info = U.setInfoString(info, this.FUN_NAME, name);
                info = U.setInfoString(info, this.HELP_CONTEXT_ID, helpContextId.toString());
                item.tag = info;
            }
            addDBField(name, descrip) {
                this.addAux(name, descrip, this.KEY_SYS_DB_FIELDS, this.DATABSE_INDEX);
            }
            addLabel(name) {
                this.addAux(name, "", this.KEY_SYS_LABELS, this.LABEL_INDEX);
            }
            setFormula(formula) {
                this.txFormula.setText(formula);
            }
            expandTree() {
                this.tvFormulas.getNodes().item(0).expandAll();
                this.tvFormulas.getNodes().item(1).expandAll();
            }
            getFormula() {
                return this.txFormula.getText();
            }
            addAux(name, descrip, key, imageIndex) {
                let father = this.tvFormulas.getNodes().item(this.KEY_SYS_VARS).getNodes().item(key);
                let item = father.getNodes().add(name, imageIndex);
                item.selectedImageIndex = item.imageIndex;
                if (descrip !== "") {
                    item.setText(descrip + " ( " + name + " )");
                }
                let info = "";
                info = U.setInfoString(info, this.FUN_DESCRIP, descrip);
                info = U.setInfoString(info, this.FUN_NAME, name);
                info = U.setInfoString(info, this.IS_DB_FIELD_OR_LABEL, "1");
                item.tag = info;
            }
            tvFormulasNodeClick(node) {
                let info = node.tag;
                this.lbDescription.setText(U.getInfoString(info, this.FUN_DESCRIP, ""));
            }
            isDbOrLabel(info) {
                return U.valInt(U.getInfoString(info, this.IS_DB_FIELD_OR_LABEL, "")) === 1;
            }
            tvFormulasDoubleClick(node) {
                let info = node.tag;
                let name = U.getInfoString(info, this.FUN_NAME, "");
                if (!this.isDbOrLabel(info)) {
                    name += "()";
                }
                let i = this.txFormula.getSelectionStart();
                this.txFormula.setText(this.txFormula.getText().substring(0, i)
                    + name
                    + this.txFormula.getText().substring(i));
            }
            cmdApplyClick() {
                return this.editor.checkSyntax(this.txFormula.getText());
            }
            setHandler(editor) {
                this.editor = editor;
            }
        }
        CSReportEditor.FFormula = FFormula;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        class FFormulaReplace extends Form {
            constructor() {
                super();
            }
            getOk() {
                throw new NotImplementedException();
            }
            getTxCurrFormula() {
            }
            getTxNewFormula() {
            }
        }
        CSReportEditor.FFormulaReplace = FFormulaReplace;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var TextBox = CSReports.CSForms.TextBox;
        var OptionButton = CSReports.CSForms.OptionButton;
        var CheckBox = CSReports.CSForms.CheckBox;
        var Label = CSReports.CSForms.Label;
        var Button = CSReports.CSForms.Button;
        class FGroup extends Form {
            constructor() {
                super();
                this.editor = null;
                this.ok = false;
                this.dbFieldChanged = false;
                this.index = 0;
                this.fieldType = 0;
                this.el = U.el('group-dlg');
                this.txName = new TextBox(U.inputEl('ctrl-group-name'));
                this.txDbField = new TextBox(U.inputEl('ctrl-group-dbfield-name'));
                this.opAsc = new OptionButton(U.inputEl('ctrl-group-op-asc'));
                this.opDesc = new OptionButton(U.inputEl('ctrl-group-op-desc'));
                this.chkPrintInNewPage = new CheckBox(U.inputEl('ctrl-group-print-in-new-page'));
                this.chkReprintGroup = new CheckBox(U.inputEl('ctrl-group-reprint-group'));
                this.chkGrandTotal = new CheckBox(U.inputEl('ctrl-group-grant-total'));
                this.opDate = new OptionButton(U.inputEl('ctrl-group-op-date'));
                this.opNumber = new OptionButton(U.inputEl('ctrl-group-op-number'));
                this.opText = new OptionButton(U.inputEl('ctrl-group-op-text'));
                this.lbGroup = new Label(U.labelEl('ctrl-group-label'));
                this.dialog = new Dialog(this.el, 'group-dlg-apply', 'group-dlg-cancel');
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                new Button(U.el('ctrl-group-dbfield-name-button')).setOnClick(P.call(this, this.dbFieldClick));
                super.setDialog(this.dialog);
            }
            cmdApplyClick() {
                return true;
            }
            setHandler(editor) {
                this.editor = editor;
            }
            dbFieldClick() {
                this.editor.showHelpDbFieldForGroup().then(P.call(this, (result) => {
                    if (result) {
                        this.dbFieldChanged = true;
                    }
                }));
            }
            getAsc() {
                return this.opAsc.getChecked();
            }
            setAsc(value) {
                this.opAsc.setChecked(value);
            }
            getDesc() {
                return this.opDesc.getChecked();
            }
            setDesc(value) {
                this.opDesc.setChecked(value);
            }
            getPrintInNewPage() {
                return this.chkPrintInNewPage.getChecked();
            }
            setPrintInNewPage(value) {
                this.chkPrintInNewPage.setChecked(value);
            }
            getReprintGroup() {
                return this.chkReprintGroup.getChecked();
            }
            setReprintGroup(value) {
                this.chkReprintGroup.setChecked(value);
            }
            getGrandTotal() {
                return this.chkGrandTotal.getChecked();
            }
            setGrandTotal(value) {
                this.chkGrandTotal.setChecked(value);
            }
            getSortByDate() {
                return this.opDate.getChecked();
            }
            setSortByDate(value) {
                this.opDate.setChecked(value);
            }
            getSortByNumber() {
                return this.opNumber.getChecked();
            }
            setSortByNumber(value) {
                this.opNumber.setChecked(value);
            }
            getSortByText() {
                return this.opText.getChecked();
            }
            setSortByText(value) {
                this.opText.setChecked(value);
            }
            getOk() {
                return this.ok;
            }
            getDbField() {
            }
            getFieldType() {
                return this.fieldType;
            }
            setFieldType(rhs) {
                this.fieldType = rhs;
            }
            getIndex() {
                return this.index;
            }
            setIndex(rhs) {
                this.index = rhs;
            }
            getTxName() {
                return this.txName;
            }
            getTxDbField() {
                return this.txDbField;
            }
            getOpAsc() {
                return this.opAsc;
            }
            getOpDesc() {
                return this.opDesc;
            }
            getChkPrintInNewPage() {
                return this.chkPrintInNewPage;
            }
            getChkReprintGroup() {
                return this.chkReprintGroup;
            }
            getChkGrandTotal() {
                return this.chkGrandTotal;
            }
            getOpDate() {
                return this.opDate;
            }
            getOpNumber() {
                return this.opNumber;
            }
            getOpText() {
                return this.opText;
            }
            getLbGroup() {
                return this.lbGroup;
            }
            showModal() {
                return this.dialog.show({ title: 'Group', height: 600, width: 800, overlay: true })
                    .then(P.call(this, (result) => {
                    if (result)
                        return {
                            success: true
                        };
                    else
                        return {
                            success: false
                        };
                }));
            }
        }
        CSReportEditor.FGroup = FGroup;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportPages extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportPage);
            }
            copy(from) {
                super.baseClear();
                for (let i = 0; i < from.values.length; i++) {
                    const pageTo = super.baseAdd(null, from.keys[i]);
                    const pageFrom = from.values[i];
                    if (!pageTo.copy(pageFrom))
                        return false;
                }
            }
        }
        CSReportEngine.cReportPages = cReportPages;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportWebServer;
    (function (CSReportWebServer) {
        var U = CSReports.CSOAPI.Utils;
        var cReport = CSReports.CSReportEngine.cReport;
        var cReportPages = CSReports.CSReportEngine.cReportPages;
        var cReportLaunchInfo = CSReports.CSReportEngine.cReportLaunchInfo;
        var DatabaseEngine = CSReports.CSDatabase.DatabaseEngine;
        var JSONDataSource = CSReports.CSDatabase.JSONDataSource;
        var JSONServer = CSReports.CSDatabase.JSONServer;
        var cPrintAPI = CSReports.CSReportEngine.cPrintAPI;
        var csRptLaunchAction = CSReports.CSReportGlobals.csRptLaunchAction;
        var CMouseWait = CSReports.CSKernelClient.CMouseWait;
        var cWindow = CSReports.CSKernelClient.cWindow;
        var MessageBoxDefaultButton = CSReports.CSKernelClient.MessageBoxDefaultButton;
        var cError = CSReports.CSKernelClient.cError;
        var P = CSReports.CSKernelClient.Callable;
        var Map = CSReports.CSOAPI.Map;
        var Image = CSReports.CSDrawing.ImageX;
        var Bitmap = CSReports.CSDrawing.Bitmap;
        class ReportWeb {
            constructor() {
                this.report = null;
                this.pages = null;
                this.images = null;
                this.cancelPrinting = false;
                this.fProgress = null;
            }
            init2(request) {
                this.init(request, new cReport());
            }
            init(request, report, workerPath = null) {
                try {
                    this.webReportId = request["content"]["webReportId"].toString();
                    this.reportId = this.uid();
                    this.database = this.uid();
                    this.report = report;
                    this.report.setDatabaseEngine(DatabaseEngine.CS_REPORT_WEB);
                    const oLaunchInfo = new cReportLaunchInfo();
                    oLaunchInfo.setPrinter(cPrintAPI.getcPrinterFromDefaultPrinter(null));
                    oLaunchInfo.getPrinter().setPaperInfo(report.getPaperInfo());
                    return this.registerDataSource(request)
                        .then(P.call(this, () => {
                        if (!this.report.init(oLaunchInfo)) {
                            return;
                        }
                        this.report.getLaunchInfo().setStrConnect(this.database);
                        this.report.setPathDefault("~");
                        this.reportWorker = new Worker(workerPath || "./csreports.js");
                        this.reportWorker.onmessage = this.onmessage();
                        this.reportWorker.postMessage({
                            action: 'init'
                        });
                        this.reportWorker.postMessage({
                            action: 'register-datasource',
                            request: request,
                            database: this.database
                        });
                        return true;
                    }));
                }
                catch (ex) {
                    return cError.mngError(ex);
                }
            }
            onmessage() {
                return P.call(this, (e) => {
                    switch (e.data.action) {
                        case 'report-progress':
                            this.reportProgress(e.data.eventArgs);
                            break;
                        case 'report-generation-done':
                            break;
                        case 'worker-launch-complete-successfully':
                            CMouseWait.default();
                            this.successLaunch(true);
                            break;
                        case 'worker-launch-failed':
                            CMouseWait.default();
                            this.closeProgressDlg();
                            cError.mngError(e.data.reason, e.data.message);
                            this.launchFailed(e.data.reason);
                            break;
                        case 'get-report-start':
                            this.reportProgress(e.data.eventArgs);
                            this.pages = new cReportPages();
                            this.reportProgress(e.data.eventArgs);
                            break;
                        case 'get-report-images':
                            this.images = new Map();
                            this.images.copy(JSON.parse(e.data.images));
                            for (let i = 0; i < this.images.size(); i++) {
                                const item = this.images.item(i);
                                this.images.update(i, new Image(Bitmap.loadImageFromArray(item._bitmap.imageData), item.key));
                            }
                            break;
                        case 'get-report-uint-images':
                            this.images.add(new Image(Bitmap.loadImageFromArray(e.data.imageData), e.data.key), e.data.key);
                            break;
                        case 'get-report-pages':
                            this.reportProgress(e.data.eventArgs);
                            const pages = new cReportPages();
                            pages.copy(JSON.parse(e.data.pages));
                            this.pages.concat(pages);
                            break;
                        case 'get-report-done':
                            this.pages.getValues().forEach((page) => {
                                const fields = [...page.getHeader().getValues(), ...page.getDetail().getValues(), ...page.getFooter().getValues()];
                                fields.forEach(P.call(this, (field) => {
                                    if (field.getImage() !== null
                                        && field.getImage() !== undefined
                                        && field.getImage().key !== null) {
                                        const key = field.getImage().key;
                                        field.setImage(this.images.item(key));
                                    }
                                }));
                            });
                            this.report.setPages(this.pages);
                            const reportPrint = new CSReports.CSReportPaint.cReportPrint();
                            reportPrint.setHidePreviewWindow(true);
                            this.report.getLaunchInfo().setReportPrint(reportPrint);
                            reportPrint.setReport(this.report);
                            this.loadImages().then(P.call(this, () => {
                                this.successGetReport(true);
                                this.reportDone();
                            }));
                            break;
                    }
                });
            }
            loadImages() {
                const toLoad = [];
                this.images.forEach((_, image) => toLoad.push(image.loadImage()));
                return Promise.all(toLoad);
            }
            makeReport() {
                if (this.report === null)
                    return P._(false);
                this.report.getLaunchInfo().setAction(csRptLaunchAction.CS_RPT_LAUNCH_PREVIEW);
                return this.launchReport();
            }
            launchReport() {
                let mouse = new CMouseWait();
                return new Promise((resolve, reject) => {
                    this.showProgressDlg().then(P.call(this, () => {
                        try {
                            const report = this.report.clone();
                            this.report.getLaunchInfo().setReportPrint(null);
                            report.getLaunchInfo().copy(JSON.parse(JSON.stringify(this.report.getLaunchInfo())));
                            report.getLaunchInfo().getPrinter().setPaperInfo(report.getPaperInfo());
                            report.getLaunchInfo().setShowPrintersDialog(true);
                            this.removeCircularReferences(report);
                            this.successLaunch = resolve;
                            this.launchFailed = reject;
                            this.reportWorker.postMessage({
                                action: 'launch',
                                launchInfo: JSON.stringify(report.getLaunchInfo()),
                                report: JSON.stringify(report)
                            });
                        }
                        catch (ex) {
                            cError.mngError(ex);
                            mouse.dispose();
                            this.closeProgressDlg();
                            reject(ex);
                        }
                    }));
                });
            }
            removeCircularReferences(report) {
                report.getControls().forEach((k, c) => c.setSectionLine(null));
                const sections = [
                    report.getHeaders(),
                    report.getGroupsHeaders(),
                    report.getDetails(),
                    report.getGroupsFooters(),
                    report.getFooters()
                ];
                sections.forEach((coll) => coll.forEach((k, s) => s.getSectionLines().forEach((k, sl) => sl.getControls().forEach((k, c) => c.setSectionLine(null)))));
                sections.forEach((coll) => coll.forEach((k, s) => s.getSectionLines().forEach((k, sl) => sl.getControls().setSectionLine(null))));
                report.zip();
            }
            showProgressDlg() {
                this.cancelPrinting = false;
                if (this.fProgress === null) {
                    this.fProgress = new CSReportWebServer.FProgress();
                }
                this.fProgress.show();
                this.fProgress.bringToFront();
                return new Promise((resolve) => {
                    setTimeout(resolve, 1000);
                });
            }
            registerDataSource(request) {
                const dataSources = request["content"]["data"]["data"];
                for (let i = 0; i < dataSources.length; i++) {
                    const dataSource = dataSources[i];
                    const ds = new JSONDataSource(dataSource["name"].toString(), dataSource["data"]);
                    JSONServer.registerDataSource(ds, this.database + "." + ds.getName());
                }
                return this.setImagesInDataSources(dataSources);
            }
            getImage(images, dataSources, indexRows, indexField, indexRow) {
                let key = "k" + indexRows.toString() + indexField.toString() + indexRow.toString();
                if (images.containsKey(key)) {
                    return images.item(key);
                }
                else {
                    const image = new Image(Bitmap.loadImageFromArray(dataSources[indexRows].data.rows[indexRow].values[indexField]), key);
                    images.add(image, key);
                    return image;
                }
            }
            setImagesInDataSources(dataSources) {
                const images = new Map();
                let p = P._(false);
                for (let indexRows = 0; indexRows < dataSources.length; indexRows++) {
                    const imageColIndex = [];
                    for (let indexField = 0; indexField < dataSources[indexRows].data.columns.length; indexField++) {
                        let typeCode = dataSources[indexRows].data.columns[indexField].columnType;
                        if (typeCode === 'bytea') {
                            imageColIndex.push(indexField);
                        }
                    }
                    for (let indexRow = 0; indexRow < dataSources[indexRows].data.rows.length; indexRow++) {
                        for (let indexField = 0; indexField < imageColIndex.length; indexField++) {
                            const image = this.getImage(images, dataSources, indexRows, indexField, indexRow);
                            if (typeof dataSources[indexRows].data.rows[indexRow].values[indexField] === 'string') {
                                p = p
                                    .then(() => image.loadImage())
                                    .then(() => {
                                    dataSources[indexRows].data.rows[indexRow].values[indexField] = {
                                        width: image.getSize().width,
                                        height: image.getSize().height,
                                        image: dataSources[indexRows].data.rows[indexRow].values[indexField]
                                    };
                                    return true;
                                });
                            }
                        }
                    }
                }
                return p.then(() => true);
            }
            reportDone() {
                CMouseWait.default();
                this.closeProgressDlg();
            }
            closeProgressDlg() {
                if (this.fProgress !== null && !this.fProgress.isDisposed()) {
                    this.fProgress.close();
                }
                this.fProgress = null;
            }
            reportProgress(eventArgs) {
                let task = eventArgs.task;
                let page = eventArgs.page;
                let currRecord = eventArgs.currRecord;
                let recordCount = eventArgs.recordCount;
                if (this.cancelPrinting) {
                    cWindow.ask("Confirm you want to cancel the execution of this report?", MessageBoxDefaultButton.Button2)
                        .then(answer => {
                        if (answer) {
                            eventArgs.cancel = true;
                            this.closeProgressDlg();
                            return;
                        }
                        else {
                            this.cancelPrinting = false;
                        }
                    });
                }
                if (this.fProgress === null)
                    return;
                if (page > 0) {
                    this.fProgress.getLbCurrPage().setText(page.toString());
                }
                if (task !== "") {
                    this.fProgress.getLbTask().setText(task);
                }
                if (currRecord > 0) {
                    this.fProgress.getLbCurrRecord().setText(currRecord.toString());
                }
                if (recordCount > 0 && U.val(this.fProgress.getLbRecordCount().getText()) !== recordCount) {
                    this.fProgress.getLbRecordCount().setText(recordCount.toString());
                }
                let percent = 0;
                if (recordCount > 0 && currRecord > 0) {
                    percent = currRecord / recordCount;
                    let value = Math.trunc(percent * 100);
                    if (value > 100)
                        value = 100;
                    this.fProgress.getPrgBar().setValue(value);
                }
            }
            uid() {
                return Date.now().toString(36) + Math.random().toString(36).substring(2);
            }
            getPages() {
                return new Promise((resolve, reject) => {
                    this.successGetReport = resolve;
                    this.getReportFailed = reject;
                    this.reportWorker.postMessage({
                        action: 'get-report'
                    });
                });
            }
            previewFirstPage(previewControl) {
                const reportPrint = this.report.getLaunchInfo().getReportPrint();
                reportPrint.setPreviewControl(previewControl);
                reportPrint.previewReport();
            }
            createPDF() {
                const reportPrint = this.report.getLaunchInfo().getReportPrint();
                this.report.getLaunchInfo().setCopies(1);
                reportPrint.createPDF();
            }
        }
        CSReportWebServer.ReportWeb = ReportWeb;
    })(CSReportWebServer = CSReports.CSReportWebServer || (CSReports.CSReportWebServer = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cColumnsInfo extends Map {
            constructor() {
                super(null, false, CSReportEngine.cColumnInfo);
            }
            add(c, key) {
                try {
                    if (c === null) {
                        c = new CSReportEngine.cColumnInfo();
                    }
                    if (key === "") {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
        }
        CSReportEngine.cColumnsInfo = cColumnsInfo;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var cError = CSReports.CSKernelClient.cError;
        var U = CSReports.CSOAPI.Utils;
        var cPrintAPI = CSReports.CSReportEngine.cPrintAPI;
        var csRptSectionType = CSReports.CSReportGlobals.csRptSectionType;
        var cWindow = CSReports.CSKernelClient.cWindow;
        var csECtlAlignConst = CSReports.CSReportGlobals.csECtlAlignConst;
        var Color = CSReports.CSDrawing.Color;
        var Font = CSReports.CSDrawing.Font;
        var P = CSReports.CSKernelClient.Callable;
        var Map = CSReports.CSOAPI.Map;
        var ReportWeb = CSReports.CSReportWebServer.ReportWeb;
        var ServerConnection = CSReports.CSDatabase.ServerConnection;
        var cReportConnect = CSReports.CSReportEngine.cReportConnect;
        var csDataSourceType = CSReports.CSReportGlobals.csDataSourceType;
        var Panel = CSReports.CSForms.Panel;
        var PictureBox = CSReports.CSForms.PictureBox;
        var TabBar = CSReports.CSForms.TabBar;
        var TabPage = CSReports.CSForms.TabPage;
        var ListView = CSReports.CSForms.ListView;
        var TreeView = CSReports.CSForms.TreeView;
        var ReportPreview = CSReports.CSForms.ReportPreview;
        class FMain {
            constructor() {
                this.paperSize = 0;
                this.paperSizeWidth = 0;
                this.paperSizeHeight = 0;
                this.orientation = 0;
                this.printerName = "";
                this.driverName = "";
                this.port = "";
                this.sourceEditor = null;
                this.wasDoubleClick = false;
                this.C_CTRL_IMAGE = 1;
                this.C_DB_IMAGE = 0;
                this.C_IMG_FOLDER = 0;
                this.C_IMG_CONTROL = 1;
                this.C_IMG_FORMULA = 2;
                this.C_IMG_DATABASE_FIELD = 3;
                this.C_FIELD_TYPE = "t";
                this.C_INDEX = "i";
                this.contextMenuEditor = null;
                this.editorIndex = 0;
                this.lv_controls = null;
                this.lv_properties = null;
                this.lv_fields = null;
                this.tv_controls = null;
                this.propertyDlg = null;
                this.debugData = new Map();
                this.previewReports = new Map();
                this.pageSetup = new CSReportEditor.FPageSetup();
                this.columnsDlg = new CSReportEditor.FColumns();
                this.searchDlg = new CSReportEditor.FSearch();
                this.groupDlg = new CSReportEditor.FGroup();
                this.connectAuxDlg = new CSReportEditor.FConnectsAux();
                this.serverConnection = new ServerConnection();
                this.popupMenuControl = null;
                this.cmCtrlCopy = null;
                this.cmCtrlDelete = null;
                this.cmCtrlSendBack = null;
                this.cmCtrlBringFront = null;
                this.cmCtrlPaste = null;
                this.cmCtrlPasteEx = null;
                this.popupMenuSection = null;
                this.cmsecAddLine = null;
                this.cmsecDeleteLine = null;
                this.cmsecDelete = null;
                this.cmsecMoveGroup = null;
                this.mnuEditMoveLocked = null;
                this.toolbarButtonLock = null;
                this.cb_zoom = null;
                U.setSepDecimal();
                let printer = cPrintAPI.getcPrinterFromDefaultPrinter(this.printDlg);
                this.printerName = printer.getDeviceName();
                this.driverName = printer.getDriverName();
                this.port = printer.getPort();
                this.paperSize = printer.getPaperInfo().getPaperSize();
                this.orientation = printer.getPaperInfo().getOrientation();
                this.paperSizeWidth = printer.getPaperInfo().getPaperSize();
                this.paperSizeHeight = printer.getPaperInfo().getPaperSize();
                this.loadRecentListFromUserSettings();
                this.mainView = U.el("main-view");
                this.tabReports = new TabBar("tabReports", U.el("tabReports"));
                this.lv_controls = new ListView("lvControls", U.el("sidebar-lv-controls"));
                this.lv_controls.state.onclick = P.call(this, this.lvControlsItemClick);
                this.lv_properties = new ListView("lvControls", U.el("sidebar-lv-properties"));
                this.lv_fields = new ListView("lvFields", U.el("sidebar-lv-database"));
                this.tv_controls = new TreeView("tvControls", U.el("sidebar-tv-controls"), "*");
                this.tv_controls.state.onclick = P.call(this, this.tvControlsNodeClick);
                this.cb_zoom = U.el("cb_zoom");
                this.propertyDlg = new CSReportEditor.PropertyDlg();
                const fontsNode = U.el('ctrl-font');
                Font.availableFonts().then((fonts) => fonts.forEach((font) => fontsNode.add(new Option(font))));
                document.onclick = P.call(this, this.hideContextMenu);
                this.mnuEditMoveLocked = U.el("mnuEditMoveLocked");
                this.toolbarButtonLock = U.el("toolbar-button-lock");
                document.onkeyup = P.call(this, this.keyUp);
                document.onkeydown = P.call(this, this.keyDown);
                this.setPopUpMenus();
            }
            setPopUpMenus() {
                this.popupMenuControl = U.el("popup-menu-control");
                this.cmCtrlCopy = U.el("cmctrl-copy");
                this.cmCtrlDelete = U.el("cmctrl-delete");
                this.cmCtrlSendBack = U.el("cmctrl-send-back");
                this.cmCtrlBringFront = U.el("cmctrl-bring-front");
                this.cmCtrlPaste = U.el("cmctrl-paste");
                this.cmCtrlPasteEx = U.el("cmctrl-paste-ex");
                this.cmCtrlCopy.onclick = P.call(this, this.copy);
                this.cmCtrlDelete.onclick = P.call(this, this.delete);
                this.cmCtrlSendBack.onclick = P.call(this, this.sendBack);
                this.cmCtrlBringFront.onclick = P.call(this, this.bringFront);
                this.cmCtrlPaste.onclick = P.call(this, this.pasteClick);
                this.cmCtrlPasteEx.onclick = P.call(this, this.pasteSpecialClick);
                this.popupMenuSection = U.el("popup-menu-section");
                this.cmsecAddLine = U.el("cmsec-add-line");
                this.cmsecDeleteLine = U.el("cmsec-delete-line");
                this.cmsecDelete = U.el("cmsec-delete");
                this.cmsecMoveGroup = U.el("cmsec-move-group");
                this.cmsecAddLine.onclick = P.call(this, this.addSectionLineClick);
                this.cmsecDeleteLine.onclick = P.call(this, this.deleteSectionLineClick);
                this.cmsecDelete.onclick = P.call(this, this.deleteSectionClick);
                this.cmsecMoveGroup.onclick = P.call(this, this.moveGroupClick);
            }
            init() {
                this.newReportClick();
            }
            getReportCopySource() {
                return this.sourceEditor;
            }
            createEditor() {
                const tabPageNode = document.createElement('div');
                tabPageNode.className = "editor";
                this.mainView.appendChild(tabPageNode);
                const pnEditorNode = document.createElement('div');
                pnEditorNode.className = "editor-container";
                tabPageNode.appendChild(pnEditorNode);
                const picRuleNode = document.createElement('div');
                picRuleNode.className = "rule";
                pnEditorNode.appendChild(picRuleNode);
                const picReportNode = document.createElement('div');
                picReportNode.className = "report";
                pnEditorNode.appendChild(picReportNode);
                let pnEditor = new Panel("pnEditor" + this.editorIndex, pnEditorNode);
                let picRule = new PictureBox("pnRule" + this.editorIndex, picRuleNode);
                let picReport = new PictureBox("pnReport" + this.editorIndex, picReportNode);
                this.editorIndex++;
                picRule.setWidth(70);
                picRule.setBacgroundColor(new Color("#f7f8f9"));
                picReport.setBacgroundColor(Color.White);
                pnEditor.getControls().add(picRule);
                pnEditor.getControls().add(picReport);
                let tab = new TabPage("tbpEditor" + this.editorIndex, tabPageNode);
                tab.getControls().add(pnEditor);
                tab.setText("New Report");
                this.tabReports.getPages().add(tab);
                const editor = new CSReportEditor.cEditor(this, pnEditor, picRule, picReport, tab);
                tab.onClose = () => {
                    editor.close().then((canClose) => {
                        if (canClose) {
                            pnEditor.dispose();
                            picRule.dispose();
                            picReport.dispose();
                            try {
                                tabPageNode.parentNode.removeChild(tabPageNode);
                            }
                            catch (ex) {
                                cError.mngError(ex);
                            }
                        }
                    });
                };
                tab.onActive = () => {
                    CSReportEditor.cMainEditor.setDocActive(editor);
                };
                return editor;
            }
            createPreview(editor) {
                const tabPageNode = document.createElement('div');
                tabPageNode.className = "editor";
                this.mainView.appendChild(tabPageNode);
                const previewNode = document.createElement('div');
                previewNode.className = "editor-container";
                tabPageNode.appendChild(previewNode);
                let reportPreview = new ReportPreview("reportPreview", previewNode);
                let tab = new TabPage("tbpPreview" + this.editorIndex, tabPageNode);
                tab.getControls().add(reportPreview);
                tab.setText("Preview Report");
                this.tabReports.getPages().add(tab);
                const previewTab = new CSReportEditor.PreviewTab(this, reportPreview, tab);
                editor.setPreviewTab(previewTab);
                tab.onClose = () => {
                    editor.getPreviewTab().close().then(() => {
                        reportPreview.dispose();
                        try {
                            tabPageNode.parentNode.removeChild(tabPageNode);
                        }
                        catch (ex) {
                            cError.mngError(ex);
                        }
                    });
                };
                tab.onActive = () => {
                    CSReportEditor.cMainEditor.setDocActive(editor.getPreviewTab());
                };
                return reportPreview;
            }
            setEditAlignTextState(status) {
            }
            setEditAlignCtlState(status) {
            }
            setMenuAux(enabled) {
            }
            addToRecentList(fileName) {
            }
            getMRUFileName() {
            }
            loadRecentListFromUserSettings() {
            }
            loadRecentList(recentList) {
            }
            recentClick() {
            }
            saveRecentList() {
            }
            setStatus(status) {
            }
            setBarText(text) {
            }
            setDisconnectedReport(isDisconnectedReport) {
                let maybeEditor = CSReportEditor.cMainEditor.getDocActive();
                if (maybeEditor === null || !maybeEditor.isEditor)
                    return;
                maybeEditor.getReport().setReportDisconnected(isDisconnectedReport);
            }
            setStatusBarText(msg) {
            }
            setReportCopySource(editor) {
                this.sourceEditor = editor;
            }
            getPaperSize() {
                return this.paperSize;
            }
            getOrientation() {
                return this.orientation;
            }
            newReportClick() {
                let editor = this.createEditor();
                editor.init().then(() => editor.newReport(null));
            }
            openReportClick() {
                try {
                    let editor = this.createEditor();
                    editor.init();
                    editor.openDocument().then(P.call(this, (success) => {
                        if (success)
                            this.addToRecentList(editor.getFileName());
                    }));
                }
                catch (ex) {
                    cError.mngError(ex);
                }
            }
            saveAsReportClick() {
                this.saveReport(true);
            }
            pageSetupClick() {
                let maybeEditor = CSReportEditor.cMainEditor.getDocActive();
                if (maybeEditor === null || !maybeEditor.isEditor)
                    return;
                const editor = maybeEditor;
                this.pageSetup.initDialog(editor.getPaperSize(), editor.getCustomHeight(), editor.getCustomWidth(), editor.getOrientation(), P.call(this, this.pageSetupApplyClick));
                this.pageSetup.showModal();
            }
            pageSetupApplyClick() {
                let maybeEditor = CSReportEditor.cMainEditor.getDocActive();
                if (maybeEditor === null || !maybeEditor.isEditor)
                    return;
                const editor = maybeEditor;
                this.paperSize = this.pageSetup.getPaperSize();
                this.paperSizeHeight = this.pageSetup.getCustomHeight();
                this.paperSizeWidth = this.pageSetup.getCustomWidth();
                this.orientation = this.pageSetup.getOrientation();
                if (editor !== null && editor.isEditor()) {
                    editor.setPaperSize(this.paperSize);
                    editor.setOrientation(this.orientation);
                    editor.setCustomHeight(this.paperSizeHeight);
                    editor.setCustomWidth(this.paperSizeWidth);
                    editor.refreshReport();
                }
            }
            saveReportClick() {
                this.saveReport(false);
            }
            setConnectionClick() {
                this.serverConnection.editSettings();
            }
            setDataSourceClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    this.serverConnection.selectDataSource().then(P.call(this, (result) => {
                        if (result.success) {
                            editor.setDataSource(result.dataSource.getStringConnection());
                        }
                    }));
                }
            }
            setAdditionalDataSourcesClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.showConnectsAux();
                }
            }
            deleteAdditionalDataSourceClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    let rptConnect = new cReportConnect();
                    rptConnect.setDataSource(this.getConnectAuxDlg().getSelectedDataSource());
                    editor.deleteConnection(rptConnect);
                }
            }
            addAdditionalDataSourceClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    this.serverConnection.selectDataSource().then(P.call(this, (result) => {
                        if (result.success) {
                            let rptConnect = new cReportConnect();
                            rptConnect.setDataSource(result.dataSource.name);
                            rptConnect.setDataSourceType(csDataSourceType.CS_DT_PROCEDURE);
                            editor.addConnection(rptConnect, this.serverConnection);
                        }
                    }));
                }
            }
            setParamsAndExecuteClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.setParamsAndExecute(this.serverConnection).then(P.call(this, (results) => {
                        if (results.filter(r => !r.success).length > 0)
                            return;
                        const dataSources = results.map(r => { return { data: r.dataSource.recordset, name: r.dataSource.name }; });
                        const content = {
                            action: 'preview',
                            data: {
                                code: results[0].dataSource.name,
                                data: dataSources,
                                file: results[0].dataSource.name + '.csr',
                                name: results[0].dataSource.name,
                                params: editor.getReport().getConnect().getParameters().map(p => { return { name: p.getName(), value: p.getValue() }; }),
                                title: results[0].dataSource.name,
                                type: '-',
                                url: '-'
                            },
                            webReportId: '-'
                        };
                        this.debugData.remove(editor.getId());
                        this.debugData.add({ name: results[0].dataSource.name, content: content }, editor.getId());
                    }));
                }
            }
            printReportClick() {
                let maybeEditor = CSReportEditor.cMainEditor.getDocActive();
                if (maybeEditor === null || !maybeEditor.isEditor())
                    return;
                const editor = maybeEditor;
                let p = P._(true);
                let previewReport = this.previewReports.item(editor.getId());
                if (previewReport === null) {
                    previewReport = new ReportWeb();
                    this.previewReports.add(previewReport, editor.getId());
                    p = previewReport.init(this.debugData.item(editor.getId()), editor.getReport());
                }
                p.then((result) => {
                    if (!result)
                        return false;
                    return previewReport.makeReport();
                })
                    .then((result) => {
                    if (!result)
                        return false;
                    return previewReport.getPages();
                })
                    .then((result) => {
                    if (!result)
                        return false;
                    previewReport.createPDF();
                })
                    .catch((ignore) => {
                });
            }
            debugReportClick() {
                let maybeEditor = CSReportEditor.cMainEditor.getDocActive();
                if (maybeEditor === null || !maybeEditor.isEditor())
                    return;
                const editor = maybeEditor;
                let p = P._(true);
                let previewReport = this.previewReports.item(editor.getId());
                if (previewReport === null) {
                    previewReport = new ReportWeb();
                    this.previewReports.add(previewReport, editor.getId());
                    p = previewReport.init(this.debugData.item(editor.getId()), editor.getReport());
                }
                p.then((result) => {
                    if (!result)
                        return false;
                    return previewReport.makeReport();
                })
                    .then((result) => {
                    if (!result)
                        return false;
                    return previewReport.getPages();
                })
                    .then((result) => {
                    if (!result)
                        return false;
                    const previewControl = this.createPreview(editor);
                    previewReport.previewFirstPage(previewControl);
                })
                    .catch((ignore) => {
                });
            }
            loadDataClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    this.openFileWithDialog().then(P.call(this, (fc) => {
                        try {
                            fc.content = JSON.parse(fc.content);
                            this.debugData.add(fc, editor.getId());
                            const columns = editor.getReport().getConnect().getColumns();
                            const dataColumns = fc.content.data.data[0].data.columns;
                            for (let i = 0; i < dataColumns.length; i++) {
                                const column = columns.add(null, "");
                                column.setColumnType(dataColumns[i].columnType);
                                column.setName(dataColumns[i].name);
                                column.setPosition(i);
                            }
                        }
                        catch (ex) {
                            cError.mngError(ex);
                        }
                    }));
                }
            }
            openFileWithDialog() {
                let file = new CSReports.CSKernelFile.cFile();
                file.init("OpenFileWithDialog");
                return file.userOpenFile();
            }
            showPopMenuSection(editor, deleteDisabled, showGroups, p, event) {
                setTimeout(P.call(this, () => {
                    this.popupMenuSection.style.display = "block";
                    this.popupMenuSection.style.top = `${event.pageY}px`;
                    this.popupMenuSection.style.left = `${event.pageX}px`;
                }), 100);
                this.setEnabledMenu(this.cmsecDelete, !deleteDisabled);
                this.setVisibleMenu(this.cmsecMoveGroup, showGroups);
                this.contextMenuEditor = editor;
            }
            hideContextMenu(_) {
                this.popupMenuControl.style.display = "none";
                this.popupMenuSection.style.display = "none";
            }
            showPopMenuControl(editor, clickInCtrl, pasteEnabled, p, event) {
                setTimeout(P.call(this, () => {
                    this.popupMenuControl.style.display = "block";
                    this.popupMenuControl.style.top = `${event.pageY}px`;
                    this.popupMenuControl.style.left = `${event.pageX}px`;
                }), 100);
                this.setEnabledMenu(this.cmCtrlCopy, clickInCtrl);
                this.setEnabledMenu(this.cmCtrlDelete, clickInCtrl);
                this.setEnabledMenu(this.cmCtrlSendBack, clickInCtrl);
                this.setEnabledMenu(this.cmCtrlBringFront, clickInCtrl);
                this.setEnabledMenu(this.cmCtrlPaste, pasteEnabled);
                this.setEnabledMenu(this.cmCtrlPasteEx, pasteEnabled);
                this.contextMenuEditor = editor;
            }
            setEnabledMenu(menu, enabled) {
                if (!enabled) {
                    menu.style.pointerEvents = "none";
                    menu.style.cursor = "default";
                    menu.style.color = "#ccc";
                }
                else {
                    menu.style.pointerEvents = "auto";
                    menu.style.cursor = "pointer";
                    menu.style.color = "#fff";
                }
            }
            setVisibleMenu(menu, isVisible) {
                if (!isVisible) {
                    menu.style.display = "none";
                }
                else {
                    menu.style.display = "block";
                }
            }
            showDbFields(field, editor) {
                this.columnsDlg.clearColumns();
                let report = editor.getReport();
                let connect = report.getConnect();
                this.columnsDlg.fillColumns(connect.getDataSource(), connect.getColumns(), false);
                for (let _i = 0; _i < report.getConnectsAux().count(); _i++) {
                    connect = report.getConnectsAux().item(_i);
                    this.columnsDlg.fillColumns(connect.getDataSource(), connect.getColumns(), true);
                }
                this.columnsDlg.setField(field);
                return this.columnsDlg.showModal();
            }
            mnuViewTreeViewCtrls_Click(sender, e) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.showControlsTree();
                }
            }
            mnuViewControls_Click(sender, e) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.showControls();
                }
            }
            mnuViewToolbar_Click(sender, e) {
                this.showToolbox();
            }
            tsbControls_Click(sender, e) {
                this.showToolbox();
            }
            showToolbox() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.showToolbox();
                }
            }
            getGroupDlg() {
                return this.groupDlg;
            }
            getConnectAuxDlg() {
                return this.connectAuxDlg;
            }
            searchClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    this.searchDlg.setHandler(editor);
                    this.searchDlg.show();
                }
            }
            setZoom(zoom) {
                this.cb_zoom.value = zoom;
            }
            zoomClick(e) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    let zoom = U.valInt(e.target.value) / 100;
                    editor.setZoom(zoom);
                }
            }
            showControls(editor) {
                this.lv_controls.clear();
                if (editor !== null && editor.isEditor()) {
                    CSReportEditor.cGlobals.addCtrls(editor.getReport(), this.lv_controls, this.C_CTRL_IMAGE, this.C_DB_IMAGE);
                }
            }
            showControlsTree(editor) {
                this.wasDoubleClick = false;
                this.tv_controls.clear();
                if (editor !== null && editor.isEditor()) {
                    CSReportEditor.cGlobals.addCtrls2(editor.getReport(), this.tv_controls, this.C_IMG_FOLDER, this.C_IMG_FORMULA, this.C_IMG_CONTROL, this.C_IMG_DATABASE_FIELD);
                }
            }
            clearProperties() {
                this.lv_properties.clear();
            }
            showProperties(editor, key) {
                this.lv_properties.clear();
                this.lv_properties.createHeaders(['Property', 'Value']);
                if (editor !== null && editor.isEditor()) {
                    this.setObjectDescription(this.getControlOrSection(editor, key));
                }
            }
            getPropertyDlg() {
                return this.propertyDlg;
            }
            getControlOrSection(editor, key) {
                if (key && key.length > 1) {
                    if (key.substring(0, 1) === "S") {
                        return editor.getSectionOrSectionLineFromKey(key.substring(1));
                    }
                    else {
                        return editor.getReport().getControls().item(key);
                    }
                }
                else {
                    return null;
                }
            }
            setObjectDescription(anObject, n) {
                if (anObject === null)
                    return;
                let tabs = " ".repeat(n * 2);
                const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(anObject));
                methods.forEach(methodName => {
                    if (methodName.length > 3
                        && methodName.substring(0, 3) === "get"
                        && methodName.substring(0, 4) !== "get_"
                        && anObject[methodName].length === 0
                        && methodName !== "getSectionLine") {
                        let item = this.lv_properties.add(tabs + methodName.substring(3), this.C_IMG_CONTROL);
                        item.subItems.add(anObject[methodName].call(anObject));
                        if (item.subItems.item(1).getText() === "...")
                            item.setImageIndex(this.C_IMG_FOLDER);
                    }
                });
            }
            getValue(value, n) {
            }
            getMethods(obj) {
            }
            showFields(editor) {
                this.lv_fields.clear();
                if (editor !== null && editor.isEditor()) {
                    let connect = editor.getReport().getConnect();
                    CSReportEditor.cGlobals.fillColumns(connect.getDataSource(), connect.getColumns(), this.lv_fields, this.C_INDEX, this.C_FIELD_TYPE, false);
                }
            }
            lv_controls_ColumnClick(sender, e) {
            }
            lv_controls_MouseClick(sender, e) {
                this.selectControl();
            }
            lv_controls_KeyUp(sender, e) {
                this.selectControl();
            }
            selectControl() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor === null || !editor.isEditor())
                    return;
                if (this.lv_controls.selectedItems().length > 0 && editor !== null) {
                    let info = this.lv_controls.selectedItems()[0].tag.toString();
                    editor.selectCtrl(info);
                }
            }
            tvControlsNodeClick(node) {
                this.selectControl2(node);
            }
            lvControlsItemClick(item) {
                this.selectControl3(item);
            }
            selectControl2(node) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor === null || !editor.isEditor())
                    return;
                if (node !== null
                    && node.tag !== undefined
                    && node.tag !== null) {
                    let info = node.tag.toString();
                    if (info.length > 0) {
                        let infoType = info.substring(0, 1);
                        if ("@SL".indexOf(infoType) === -1) {
                            editor.selectCtrl(info);
                        }
                        else if (infoType === "S" || infoType === "L") {
                            editor.selectSection(info.substring(1));
                        }
                    }
                }
            }
            selectControl3(item) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor === null || !editor.isEditor())
                    return;
                if (item !== null
                    && item.tag !== undefined
                    && item.tag !== null) {
                    let info = item.tag.toString();
                    if (info.length > 0) {
                        let infoType = info.substring(0, 1);
                        if ("@SL".indexOf(infoType) === -1) {
                            editor.selectCtrl(info);
                        }
                        else if (infoType === "S" || infoType === "L") {
                            editor.selectSection(info.substring(1));
                        }
                    }
                }
            }
            editAddHeaderClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addSection(csRptSectionType.HEADER);
                }
            }
            editAddGroupClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addGroup();
                }
            }
            editAddFooterClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addSection(csRptSectionType.FOOTER);
                }
            }
            editAddLabelClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addLabel();
                }
            }
            editAddLineClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addLineLabel();
                }
            }
            editAddDbControlClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addDBField();
                }
            }
            editAddImageClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addImage();
                }
            }
            editAddChartClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addChart();
                }
            }
            helpAboutClick() {
                cWindow.msgInfo("Version 1.0.0"
                    + "\r\n\r\nhttps://github.com/javiercrowsoft/CSReports.js", "CrowSoft Report Editor");
            }
            addSectionLineClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.addSectionLine();
                }
            }
            deleteReportObject(isSectionLine) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.deleteObj(isSectionLine);
                }
            }
            deleteSectionClick() {
                this.deleteReportObject(false);
            }
            deleteSectionLineClick() {
                this.deleteReportObject(true);
            }
            moveGroupClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.moveGroup();
                }
            }
            alignText(align) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.textAlign(align);
                }
            }
            alignLeftClick() {
                this.alignText(CSReports.CSReportGlobals.HorizontalAlignment.Left);
            }
            aligntCenterClick() {
                this.alignText(CSReports.CSReportGlobals.HorizontalAlignment.Center);
            }
            alignRightClick() {
                this.alignText(CSReports.CSReportGlobals.HorizontalAlignment.Right);
            }
            boldClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.setFontBold();
                }
            }
            saveReport(saveAs) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.saveDocument(saveAs, CSReportEditor.cMainEditor.runningInBrowser());
                    this.addToRecentList(editor.getFileName());
                }
            }
            mnuPrinterSettings_Click(sender, e) {
            }
            mnuHideGrid_Click(sender, e) {
            }
            mnuGridLines_Click(sender, e) {
            }
            mnuGridPoints_Click(sender, e) {
            }
            mnuOptionsTool_Click(sender, e) {
            }
            copy() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.copy();
                }
            }
            paste(dontMove) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.paste(dontMove);
                }
            }
            pasteClick() {
                this.paste(false);
            }
            pasteSpecialClick() {
                this.paste(true);
            }
            delete() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.deleteObj(false);
                }
            }
            printReport() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.printReport();
                }
            }
            tsbPrint_Click(sender, e) {
                this.printReport();
            }
            mnuPrintReport_Click(sender, e) {
                this.printReport();
            }
            bringFront() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.bringToFront();
                }
            }
            sendBack() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.sendToBack();
                }
            }
            editMoveLockedClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.moveNoMove();
                    if (editor.moveIsLock()) {
                        this.mnuEditMoveLocked.textContent = "Unlock";
                        this.toolbarButtonLock.src = 'images/toolbar/lock-red.png';
                    }
                    else {
                        this.mnuEditMoveLocked.textContent = "Lock";
                        this.toolbarButtonLock.src = 'images/toolbar/lock.png';
                    }
                }
            }
            editMoveVerticalClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.moveVertical();
                }
            }
            editMoveHorizontalClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.moveHorizontal();
                }
            }
            editMoveFreeClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.moveAll();
                }
            }
            ctrlAlignLeftClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignLeft);
                }
            }
            ctrlAlignRightClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignRight);
                }
            }
            ctrlAlignTopClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignTop);
                }
            }
            ctrlAlignBottomClick() {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignBottom);
                }
            }
            tsbCtrlSameHeight_Click(sender, e) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignHeight);
                }
            }
            tsbCtrlSameWidth_Click(sender, e) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignWidth);
                }
            }
            ctrlSameWidthClick(sender, e) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignWidth);
                }
            }
            ctrlSameHeightClick(sender, e) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.controlsAlign(csECtlAlignConst.csECtlAlignHeight);
                }
            }
            keyUp(ev) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.keyUp(ev);
                }
            }
            keyDown(ev) {
                let editor = CSReportEditor.cMainEditor.getDocActive();
                if (editor !== null && editor.isEditor()) {
                    editor.keyDown(ev);
                }
            }
            editStepSizeClick() { }
            printDialog() {
                return undefined;
            }
            close() {
            }
        }
        CSReportEditor.FMain = FMain;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var TextBox = CSReports.CSForms.TextBox;
        var ComboBox = CSReports.CSForms.ComboBox;
        var OptionButton = CSReports.CSForms.OptionButton;
        var csReportPaperType = CSReports.CSReportGlobals.csReportPaperType;
        var csRptPageOrientation = CSReports.CSReportGlobals.csRptPageOrientation;
        class FPageSetup extends Form {
            constructor() {
                super();
                this.customHeight = null;
                this.customWidth = null;
                this.orientation = 1;
                this.paperSize = csReportPaperType.CS_RPT_PAPER_TYPE_A4;
                this.el = U.el('page-setup-dlg');
                this.dialog = new Dialog(this.el, 'page-setup-dlg-apply', 'page-setup-dlg-cancel');
                this.dialog.onApply = P.call(this, this.cmdApplyClick);
                super.setDialog(this.dialog);
                this.txHeight = new TextBox(U.inputEl("page-setup-height"));
                this.txWidth = new TextBox(U.inputEl("page-setup-width"));
                this.opLandscape = new OptionButton(U.inputEl("page-setup-landscape"));
                this.opPortrait = new OptionButton(U.inputEl("page-setup-portrait"));
                this.cbPaperSize = new ComboBox(U.selectEl("page-setup-paper-size"));
                this.cbPaperSize.setOnChange(P.call(this, this.cbPaperSizeSelectedIndexChanged));
            }
            initDialog(paperSize, customHeight, customWidth, orientation, pageSetupApplyClick) {
                this.customHeight = customHeight;
                this.customWidth = customWidth;
                this.orientation = orientation;
                this.paperSize = paperSize;
                this.pageSetupApplyClick = pageSetupApplyClick;
                U.listSetListIndexForId(this.cbPaperSize, this.paperSize);
                this.txHeight.setText(this.customHeight.toString());
                this.txWidth.setText(this.customWidth.toString());
                if (this.orientation === csRptPageOrientation.LANDSCAPE) {
                    this.opLandscape.setChecked(true);
                }
                else {
                    this.opPortrait.setChecked(true);
                }
            }
            getPaperSize() {
                return this.paperSize;
            }
            getCustomHeight() {
                return this.customHeight;
            }
            getCustomWidth() {
                return this.customWidth;
            }
            getOrientation() {
                return this.orientation;
            }
            showModal() {
                return this.dialog.show({ title: 'Page Setup', height: 600, width: 500, overlay: true });
            }
            cmdApplyClick() {
                this.customHeight = U.val(this.txHeight.getText());
                this.customWidth = U.val(this.txWidth.getText());
                this.paperSize = U.valInt(U.listID(this.cbPaperSize));
                this.orientation = this.opLandscape.getChecked() ? csRptPageOrientation.LANDSCAPE : csRptPageOrientation.PORTRAIT;
                this.pageSetupApplyClick();
                return true;
            }
            cbPaperSizeSelectedIndexChanged() {
                let enabled = U.valInt(U.listID(this.cbPaperSize)) === csReportPaperType.CS_RPT_PAPER_USER;
                this.txHeight.setEnabled(enabled);
                this.txWidth.setEnabled(enabled);
            }
        }
        CSReportEditor.FPageSetup = FPageSetup;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        class FProgress extends Form {
            getLbCurrPage() {
            }
            getLbTask() {
            }
            getLbCurrRecord() {
            }
            getLbRecordCount() {
            }
            getPrgBar() {
            }
        }
        CSReportEditor.FProgress = FProgress;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        class FProperties extends Form {
            constructor() {
                super();
                this.editor = null;
                this.ok = null;
                this.done = null;
                this.index = 0;
                this.fieldType = 0;
                this.formulaHide = "";
                this.formulaValue = "";
                this.formulaName = "";
                this.isAccounting = null;
                this.mouse = null;
                this.textChanged = null;
                this.tagChanged = null;
                this.fontChanged = null;
                this.foreColorChanged = null;
                this.backColorChanged = null;
                this.formatChanged = null;
                this.leftChanged = null;
                this.topChanged = null;
                this.heightChanged = null;
                this.widthChanged = null;
                this.symbolChanged = null;
                this.transparentChanged = null;
                this.strikeChanged = null;
                this.underlineChanged = null;
                this.wordWrapChanged = null;
                this.italicChanged = null;
                this.boldChanged = null;
                this.alignChanged = null;
                this.fontSizeChanged = null;
                this.canGrowChanged = null;
                this.formulaHideChanged = null;
                this.formulaValueChanged = null;
                this.bSetFormulaHideChanged = null;
                this.bSetFormulaValueChanged = null;
                this.idxGroupChanged = null;
                this.whenEvalChanged = null;
                this.dbFieldChanged = null;
                this.pictureChanged = null;
                this.borderTypeChanged = null;
                this.border3DChanged = null;
                this.border3DShadowChanged = null;
                this.borderRoundedChanged = null;
                this.borderWidthChanged = null;
                this.borderColorChanged = null;
                this.chartFieldVal1Changed = null;
                this.chartFieldVal2Changed = null;
                this.chartFieldLbl1Changed = null;
                this.chartFieldLbl2Changed = null;
                this.chartSizeChanged = null;
                this.chartThicknessChanged = null;
                this.chartColorSerie1Changed = null;
                this.chartColorSerie2Changed = null;
                this.chartFormatTypeChanged = null;
                this.chartLinesTypeChanged = null;
                this.chartTypeChanged = null;
                this.chartShowLinesChanged = null;
                this.chartShowValuesChanged = null;
                this.chartTopChanged = null;
                this.chartSortChanged = null;
                this.chartFieldGroupChanged = null;
                this.chartGroupValueChanged = null;
                this.isFreeCtrlChanged = null;
                this.exportColIdxChanged = null;
                this.chartIndex = null;
                this.chartFieldType = null;
                this.chartGroupIndex = 0;
                this.chartGroupFieldType = 0;
            }
            getPictureChanged() {
                return this.pictureChanged;
            }
            setPictureChanged(rhs) {
                this.pictureChanged = rhs;
            }
            getOk() {
                return this.ok;
            }
            getIndex() {
                return this.index;
            }
            getChartGroupIndex() {
                return this.chartGroupIndex;
            }
            getChartIndex(idx) {
                return this.chartIndex[idx];
            }
            getFieldType() {
                return this.fieldType;
            }
            getChartFieldType(idx) {
                return this.chartFieldType[idx];
            }
            getChartGroupFieldType() {
                return this.chartGroupFieldType;
            }
            setIndex(rhs) {
                this.index = rhs;
            }
            setChartGroupIndex(rhs) {
                this.chartGroupIndex = rhs;
            }
            setChartIndex(idx, rhs) {
                this.chartIndex[idx] = rhs;
            }
            setFieldType(rhs) {
                this.fieldType = rhs;
            }
            setChartGroupFieldType(rhs) {
                this.chartGroupFieldType = rhs;
            }
            setChartFieldType(idx, rhs) {
                this.chartFieldType[idx] = rhs;
            }
            getFormulaHide() {
                return this.formulaHide;
            }
            setFormulaHide(rhs) {
                this.formulaHide = rhs;
            }
            getFormulaValue() {
                return this.formulaValue;
            }
            setFormulaValue(rhs) {
                this.formulaValue = rhs;
            }
            getFormulaName() {
                return this.formulaName;
            }
            setFormulaName(rhs) {
                this.formulaName = rhs;
            }
            getIsAccounting() {
                return this.isAccounting;
            }
            setIsAccounting(rhs) {
                this.isAccounting = rhs;
            }
            getTextChanged() {
                return this.textChanged;
            }
            setTextChanged(rhs) {
                this.textChanged = rhs;
            }
            getTagChanged() {
                return this.tagChanged;
            }
            setTagChanged(rhs) {
                this.tagChanged = rhs;
            }
            getFontChanged() {
                return this.fontChanged;
            }
            setFontChanged(rhs) {
                this.fontChanged = rhs;
            }
            getForeColorChanged() {
                return this.foreColorChanged;
            }
            setForeColorChanged(rhs) {
                this.foreColorChanged = rhs;
            }
            getBackColorChanged() {
                return this.backColorChanged;
            }
            setBackColorChanged(rhs) {
                this.backColorChanged = rhs;
            }
            getFormatChanged() {
                return this.formatChanged;
            }
            setFormatChanged(rhs) {
                this.formatChanged = rhs;
            }
            getLeftChanged() {
                return this.leftChanged;
            }
            setLeftChanged(rhs) {
                this.leftChanged = rhs;
            }
            getTopChanged() {
                return this.topChanged;
            }
            setTopChanged(rhs) {
                this.topChanged = rhs;
            }
            getHeightChanged() {
                return this.heightChanged;
            }
            setHeightChanged(rhs) {
                this.heightChanged = rhs;
            }
            getWidthChanged() {
                return this.widthChanged;
            }
            setWidthChanged(rhs) {
                this.widthChanged = rhs;
            }
            getSymbolChanged() {
                return this.symbolChanged;
            }
            setSymbolChanged(rhs) {
                this.symbolChanged = rhs;
            }
            getTransparentChanged() {
                return this.transparentChanged;
            }
            setTransparentChanged(rhs) {
                this.transparentChanged = rhs;
            }
            getStrikeChanged() {
                return this.strikeChanged;
            }
            setStrikeChanged(rhs) {
                this.strikeChanged = rhs;
            }
            getUnderlineChanged() {
                return this.underlineChanged;
            }
            setUnderlineChanged(rhs) {
                this.underlineChanged = rhs;
            }
            getWordWrapChanged() {
                return this.wordWrapChanged;
            }
            setWordWrapChanged(rhs) {
                this.wordWrapChanged = rhs;
            }
            getItalicChanged() {
                return this.italicChanged;
            }
            setItalicChanged(rhs) {
                this.italicChanged = rhs;
            }
            getBoldChanged() {
                return this.boldChanged;
            }
            setBoldChanged(rhs) {
                this.boldChanged = rhs;
            }
            getAlignChanged() {
                return this.alignChanged;
            }
            setAlignChanged(rhs) {
                this.alignChanged = rhs;
            }
            getFontSizeChanged() {
                return this.fontSizeChanged;
            }
            setFontSizeChanged(rhs) {
                this.fontSizeChanged = rhs;
            }
            getCanGrowChanged() {
                return this.canGrowChanged;
            }
            setCanGrowChanged(rhs) {
                this.canGrowChanged = rhs;
            }
            getFormulaHideChanged() {
                return this.formulaHideChanged;
            }
            setFormulaHideChanged(rhs) {
                this.formulaHideChanged = rhs;
            }
            getFormulaValueChanged() {
                return this.formulaValueChanged;
            }
            setFormulaValueChanged(rhs) {
                this.formulaValueChanged = rhs;
            }
            getWhenEvalChanged() {
                return this.whenEvalChanged;
            }
            setWhenEvalChanged(rhs) {
                this.whenEvalChanged = rhs;
            }
            getIdxGroupChanged() {
                return this.idxGroupChanged;
            }
            setIdxGroupChanged(rhs) {
                this.idxGroupChanged = rhs;
            }
            getDbFieldChanged() {
                return this.dbFieldChanged;
            }
            setDbFieldChanged(rhs) {
                this.dbFieldChanged = rhs;
            }
            getSetFormulaHideChanged() {
                return this.bSetFormulaHideChanged;
            }
            setSetFormulaHideChanged(rhs) {
                this.bSetFormulaHideChanged = rhs;
            }
            getSetFormulaValueChanged() {
                return this.bSetFormulaValueChanged;
            }
            setSetFormulaValueChanged(rhs) {
                this.bSetFormulaValueChanged = rhs;
            }
            getBorderTypeChanged() {
                return this.borderTypeChanged;
            }
            setBorderTypeChanged(rhs) {
                this.borderTypeChanged = rhs;
            }
            getBorder3DChanged() {
                return this.border3DChanged;
            }
            setBorder3DChanged(rhs) {
                this.border3DChanged = rhs;
            }
            getBorder3DShadowChanged() {
                return this.border3DShadowChanged;
            }
            setBorder3DShadowChanged(rhs) {
                this.border3DShadowChanged = rhs;
            }
            getBorderRoundedChanged() {
                return this.borderRoundedChanged;
            }
            setBorderRoundedChanged(rhs) {
                this.borderRoundedChanged = rhs;
            }
            getBorderWidthChanged() {
                return this.borderWidthChanged;
            }
            setBorderWidthChanged(rhs) {
                this.borderWidthChanged = rhs;
            }
            getBorderColorChanged() {
                return this.borderColorChanged;
            }
            setBorderColorChanged(rhs) {
                this.borderColorChanged = rhs;
            }
            getChartFieldVal1Changed() {
                return this.chartFieldVal1Changed;
            }
            setChartFieldVal1Changed(rhs) {
                this.chartFieldVal1Changed = rhs;
            }
            getChartFieldVal2Changed() {
                return this.chartFieldVal2Changed;
            }
            setChartFieldVal2Changed(rhs) {
                this.chartFieldVal2Changed = rhs;
            }
            getChartFieldLbl1Changed() {
                return this.chartFieldLbl1Changed;
            }
            setChartFieldLbl1Changed(rhs) {
                this.chartFieldLbl1Changed = rhs;
            }
            getChartFieldGroupChanged() {
                return this.chartFieldGroupChanged;
            }
            setChartFieldGroupChanged(rhs) {
                this.chartFieldGroupChanged = rhs;
            }
            getChartGroupValueChanged() {
                return this.chartGroupValueChanged;
            }
            setChartGroupValueChanged(rhs) {
                this.chartGroupValueChanged = rhs;
            }
            getChartFieldLbl2Changed() {
                return this.chartFieldLbl2Changed;
            }
            setChartFieldLbl2Changed(rhs) {
                this.chartFieldLbl2Changed = rhs;
            }
            getChartSizeChanged() {
                return this.chartSizeChanged;
            }
            setChartSizeChanged(rhs) {
                this.chartSizeChanged = rhs;
            }
            getChartThicknessChanged() {
                return this.chartThicknessChanged;
            }
            setChartThicknessChanged(rhs) {
                this.chartThicknessChanged = rhs;
            }
            getChartColorSerie1Changed() {
                return this.chartColorSerie1Changed;
            }
            setChartColorSerie1Changed(rhs) {
                this.chartColorSerie1Changed = rhs;
            }
            getChartColorSerie2Changed() {
                return this.chartColorSerie2Changed;
            }
            setChartColorSerie2Changed(rhs) {
                this.chartColorSerie2Changed = rhs;
            }
            getChartFormatTypeChanged() {
                return this.chartFormatTypeChanged;
            }
            setChartFormatTypeChanged(rhs) {
                this.chartFormatTypeChanged = rhs;
            }
            getChartLinesTypeChanged() {
                return this.chartLinesTypeChanged;
            }
            setChartLinesTypeChanged(rhs) {
                this.chartLinesTypeChanged = rhs;
            }
            getChartTypeChanged() {
                return this.chartTypeChanged;
            }
            setChartTypeChanged(rhs) {
                this.chartTypeChanged = rhs;
            }
            getChartShowLinesChanged() {
                return this.chartShowLinesChanged;
            }
            setChartShowLinesChanged(rhs) {
                this.chartShowLinesChanged = rhs;
            }
            getChartShowValuesChanged() {
                return this.chartShowValuesChanged;
            }
            setChartShowValuesChanged(rhs) {
                this.chartShowValuesChanged = rhs;
            }
            getChartTopChanged() {
                return this.chartTopChanged;
            }
            setChartTopChanged(rhs) {
                this.chartTopChanged = rhs;
            }
            getChartSortChanged() {
                return this.chartSortChanged;
            }
            setChartSortChanged(rhs) {
                this.chartSortChanged = rhs;
            }
            getIsFreeCtrlChanged() {
                return this.isFreeCtrlChanged;
            }
            setIsFreeCtrlChanged(rhs) {
                this.isFreeCtrlChanged = rhs;
            }
            getExportColIdxChanged() {
                return this.exportColIdxChanged;
            }
            setExportColIdxChanged(rhs) {
                this.exportColIdxChanged = rhs;
            }
            cb_align_Click(sender, e) {
                this.alignChanged = true;
            }
            cb_borderType_Click(sender, e) {
                this.borderTypeChanged = true;
            }
            chk_borderRounded_Click(sender, e) {
                this.borderRoundedChanged = true;
            }
            chk_formulaHide_Click(sender, e) {
                this.bSetFormulaHideChanged = true;
            }
            chk_formulaValue_Click(sender, e) {
                this.bSetFormulaValueChanged = true;
            }
            cmd_formulaHide_Click(sender, e) {
            }
            cmd_formulaValue_Click(sender, e) {
            }
            op_afterPrint_Click(sender, e) {
                this.whenEvalChanged = true;
            }
            op_beforePrint_Click(sender, e) {
                this.whenEvalChanged = true;
            }
            tx_border3D_LostFocus(sender, e) {
            }
            cmd_border3D_click(sender, e) {
                try {
                }
                catch (ignore) { }
            }
            tx_borderColor_LostFocus(sender, e) {
            }
            cmd_borderColor_Click(sender, e) {
                try {
                }
                catch (ignore) { }
            }
            tx_borderShadow_LostFocus(sender, e) {
            }
            cmd_borderShadow_Click(sender, e) {
                try {
                }
                catch (ignore) { }
            }
            tx_BorderWidth_TextChanged(sender, e) {
                this.borderWidthChanged = true;
            }
            tx_ChartGroupValue_TextChanged(sender, e) {
                this.chartGroupValueChanged = true;
            }
            tx_ChartTop_TextChanged(sender, e) {
                this.chartTopChanged = true;
            }
            cmd_dbFieldGroupValue_Click(sender, e) {
            }
            cmd_dbFieldLbl1_Click(sender, e) {
            }
            cmd_dbFieldLbl2_Click(sender, e) {
            }
            cmd_dbFieldVal1_Click(sender, e) {
            }
            cmd_dbFieldVal2_Click(sender, e) {
            }
            tx_foreColor_LostFocus(sender, e) {
            }
            tx_backColor_LostFocus(sender, e) {
            }
            resetChangedFlags() {
                this.textChanged = false;
                this.tagChanged = false;
                this.fontChanged = false;
                this.foreColorChanged = false;
                this.backColorChanged = false;
                this.formatChanged = false;
                this.leftChanged = false;
                this.topChanged = false;
                this.heightChanged = false;
                this.widthChanged = false;
                this.symbolChanged = false;
                this.transparentChanged = false;
                this.strikeChanged = false;
                this.underlineChanged = false;
                this.wordWrapChanged = false;
                this.italicChanged = false;
                this.boldChanged = false;
                this.alignChanged = false;
                this.fontSizeChanged = false;
                this.canGrowChanged = false;
                this.formulaHideChanged = false;
                this.formulaValueChanged = false;
                this.idxGroupChanged = false;
                this.whenEvalChanged = false;
                this.dbFieldChanged = false;
                this.bSetFormulaHideChanged = false;
                this.bSetFormulaValueChanged = false;
                this.pictureChanged = false;
                this.borderTypeChanged = false;
                this.border3DChanged = false;
                this.border3DShadowChanged = false;
                this.borderRoundedChanged = false;
                this.borderWidthChanged = false;
                this.borderColorChanged = false;
                this.chartFieldGroupChanged = false;
                this.chartFieldLbl1Changed = false;
                this.chartFieldLbl2Changed = false;
                this.chartFieldVal1Changed = false;
                this.chartFieldVal2Changed = false;
                this.chartSizeChanged = false;
                this.chartThicknessChanged = false;
                this.chartColorSerie1Changed = false;
                this.chartColorSerie2Changed = false;
                this.chartFormatTypeChanged = false;
                this.chartLinesTypeChanged = false;
                this.chartTypeChanged = false;
                this.chartShowLinesChanged = false;
                this.chartShowValuesChanged = false;
                this.chartTopChanged = false;
                this.chartTopChanged = false;
                this.chartFieldGroupChanged = false;
                this.chartGroupValueChanged = false;
                this.isFreeCtrlChanged = false;
                this.exportColIdxChanged = false;
            }
            hideTabField() {
            }
            hideTabImage() {
            }
            hideTabChart() {
            }
            getDbFieldGroupValue() {
                throw new NotImplementedException();
            }
            setDbFieldGroupValue(sField) {
            }
            fProperties_Load(sender, e) {
            }
            initChart() {
            }
            pFillColors(cb_list) {
            }
            cmd_cancel_Click(sender, e) {
            }
            cmd_foreColor_Click(sender, e) {
            }
            cmd_backColor_Click(sender, e) {
            }
            picColor(txColor, shColor) {
            }
            cmd_font_Click(sender, e) {
            }
            cmd_borderColor_Click_1(sender, e) {
            }
            cmd_borderColor3d_Click(sender, e) {
            }
            cmd_borderShadowColor_Click(sender, e) {
            }
            setHandler(editor) {
                this.editor = editor;
            }
            cmd_dbField_Click(sender, e) {
                if (this.editor.showHelpDbField()) {
                    this.dbFieldChanged = true;
                }
            }
            cmd_apply_Click(sender, e) {
            }
            tx_name_TextChanged(sender, e) {
            }
            tx_text_TextChanged(sender, e) {
                this.textChanged = true;
            }
            tx_tag_TextChanged(sender, e) {
                this.tagChanged = true;
            }
            tx_font_TextChanged(sender, e) {
                this.fontChanged = true;
            }
            tx_fontSize_TextChanged(sender, e) {
                this.fontSizeChanged = true;
            }
            cb_align_SelectedIndexChanged(sender, e) {
                this.alignChanged = true;
            }
            tx_foreColor_TextChanged(sender, e) {
                this.foreColorChanged = true;
            }
            tx_backColor_TextChanged(sender, e) {
                this.backColorChanged = true;
            }
            tx_format_TextChanged(sender, e) {
                this.formatChanged = true;
            }
            tx_symbol_TextChanged(sender, e) {
                this.symbolChanged = true;
            }
            chk_fontBold_CheckedChanged(sender, e) {
                this.boldChanged = true;
            }
            chk_fontUnderline_CheckedChanged(sender, e) {
                this.underlineChanged = true;
            }
            chk_fontItalic_CheckedChanged(sender, e) {
                this.italicChanged = true;
            }
            chk_fontStrike_CheckedChanged(sender, e) {
                this.strikeChanged = true;
            }
            tx_left_TextChanged(sender, e) {
                this.leftChanged = true;
            }
            tx_top_TextChanged(sender, e) {
                this.topChanged = true;
            }
            tx_height_TextChanged(sender, e) {
                this.heightChanged = true;
            }
            tx_width_TextChanged(sender, e) {
                this.widthChanged = true;
            }
            chk_canGrow_CheckedChanged(sender, e) {
                this.canGrowChanged = true;
            }
            chk_wordWrap_CheckedChanged(sender, e) {
                this.wordWrapChanged = true;
            }
            chk_isFreeCtrl_CheckedChanged(sender, e) {
                this.isFreeCtrlChanged = true;
            }
            tx_exportColIdx_TextChanged(sender, e) {
                this.exportColIdxChanged = true;
            }
            cb_borderType_SelectedIndexChanged(sender, e) {
                this.borderTypeChanged = true;
            }
            tx_borderColor_TextChanged(sender, e) {
                this.borderColorChanged = true;
            }
            tx_border3D_TextChanged(sender, e) {
                this.border3DChanged = true;
            }
            tx_borderShadow_TextChanged(sender, e) {
                this.border3DShadowChanged = true;
            }
            tx_borderWidth_TextChanged_1(sender, e) {
                this.borderWidthChanged = true;
            }
            chk_borderRounded_CheckedChanged(sender, e) {
                this.borderRoundedChanged = true;
            }
            cb_type_SelectedIndexChanged(sender, e) {
                this.chartTypeChanged = true;
            }
            cb_formatType_SelectedIndexChanged(sender, e) {
                this.chartFormatTypeChanged = true;
            }
            cb_linesType_SelectedIndexChanged(sender, e) {
                this.chartLinesTypeChanged = true;
            }
            cb_chartSize_SelectedIndexChanged(sender, e) {
                this.chartSizeChanged = true;
            }
            tx_chartTop_TextChanged_1(sender, e) {
                this.chartTopChanged = true;
            }
            cb_chartThickness_SelectedIndexChanged(sender, e) {
                this.chartThicknessChanged = true;
            }
            chk_showBarValues_CheckedChanged(sender, e) {
                this.chartShowValuesChanged = true;
            }
            chk_showOutlines_CheckedChanged(sender, e) {
                this.chartShowLinesChanged = true;
            }
            chk_sort_CheckedChanged(sender, e) {
                this.chartSortChanged = true;
            }
            tx_dbFieldGroupValue_TextChanged(sender, e) {
                this.chartFieldGroupChanged = true;
            }
            tx_chartGroupValue_TextChanged_1(sender, e) {
                this.chartGroupValueChanged = true;
            }
            tx_dbFieldVal1_TextChanged(sender, e) {
                this.chartFieldVal1Changed = true;
            }
            tx_dbFieldLbl1_TextChanged(sender, e) {
                this.chartFieldLbl1Changed = true;
            }
            cb_colorSerie1_SelectedIndexChanged(sender, e) {
                this.chartColorSerie1Changed = true;
            }
            tx_dbFieldVal2_TextChanged(sender, e) {
                this.chartFieldVal2Changed = true;
            }
            tx_dbFieldLbl2_TextChanged(sender, e) {
                this.chartFieldLbl2Changed = true;
            }
            cb_colorSerie2_SelectedIndexChanged(sender, e) {
                this.chartColorSerie2Changed = true;
            }
            getTxText() {
            }
            getPicImage() {
            }
            getCbType() {
                return undefined;
            }
            getCbFormatType() {
                return undefined;
            }
            getCbChartSize() {
                return undefined;
            }
            getCbChartThickness() {
                return undefined;
            }
            getCbLinesType() {
                return undefined;
            }
            getTxChartTop() {
            }
            getTxDbFieldGroupValue() {
            }
            getTxChartGroupValue() {
            }
            getChkShowOutlines() {
            }
            getChkSort() {
            }
            getChkShowBarValues() {
            }
            getTxDbFieldLbl1() {
            }
            getTxDbFieldVal1() {
            }
            getCbColorSerie1() {
                return undefined;
            }
            getTxDbFieldVal2() {
            }
            getCbColorSerie2() {
                return undefined;
            }
            getTxDbField() {
            }
            getTxName() {
            }
            getLbControl() {
            }
            getChkFormulaHide() {
            }
            getChkFormulaValue() {
            }
            getTxExportColIdx() {
            }
            getChkIsFreeCtrl() {
            }
            getTxTag() {
            }
            getTxIdxGroup() {
            }
            getOpBeforePrint() {
            }
            getOpAfterPrint() {
            }
            getChkCanGrow() {
            }
            getTxFormat() {
            }
            getTxSymbol() {
            }
            getChkWordWrap() {
            }
            getTxBorderColor() {
            }
            getTxBorder3D() {
            }
            getTxBorderShadow() {
            }
            getChkBorderRounded() {
            }
            getTxBorderWidth() {
            }
            getCbBorderType() {
                return undefined;
            }
            getTxFont() {
            }
            getShForeColor() {
            }
            getTxForeColor() {
            }
            getChkFontBold() {
            }
            getChkFontItalic() {
            }
            getTxFontSize() {
            }
            getChkFontUnderline() {
            }
            getChkFontStrike() {
            }
            getTxLeft() {
            }
            getTxTop() {
            }
            getTxWidth() {
            }
            getTxHeight() {
            }
            getTxBackColor() {
            }
            getShBackColor() {
            }
            getChkTransparent() {
            }
            getTxDbFieldLbl2() {
            }
            getCbAlign() {
                return undefined;
            }
        }
        CSReportEditor.FProperties = FProperties;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var U = CSReports.CSOAPI.Utils;
        var P = CSReports.CSKernelClient.Callable;
        var cWindow = CSReports.CSKernelClient.cWindow;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var TextBox = CSReports.CSForms.TextBox;
        var ListView = CSReports.CSForms.ListView;
        var csRptControlType = CSReports.CSReportGlobals.csRptControlType;
        let csObjType;
        (function (csObjType) {
            csObjType[csObjType["iTypeFormulaH"] = 1] = "iTypeFormulaH";
            csObjType[csObjType["iTypeFormulaV"] = 0] = "iTypeFormulaV";
            csObjType[csObjType["iTypeCtrl"] = 2] = "iTypeCtrl";
            csObjType[csObjType["iTypeDbField"] = 3] = "iTypeDbField";
            csObjType[csObjType["iTypeSecG"] = 4] = "iTypeSecG";
            csObjType[csObjType["iTypeSec"] = 5] = "iTypeSec";
            csObjType[csObjType["iTypeSecLn"] = 6] = "iTypeSecLn";
            csObjType[csObjType["iTypeText"] = 7] = "iTypeText";
        })(csObjType || (csObjType = {}));
        class FSearch extends Form {
            constructor() {
                super();
                this.editor = null;
                this.el = U.el('search-dlg');
                this.dialog = new Dialog(this.el, 'search-dlg-edit', 'search-dlg-close');
                this.dialog.onApply = P.call(this, this.cmdEditClick);
                this.txSearchText = new TextBox(U.inputEl("search-text"));
                this.txSearchText.setOnKeyDown(P.call(this, this.searchTextKeyDown));
                this.lvControls = new ListView("lvControls", U.el("search-lv-rows"));
                this.lvControls.createHeaders(['Name', 'Found in']);
                this.lvControls.state.onclick = P.call(this, this.lvControlsClick);
                super.setDialog(this.dialog);
            }
            cmdEditClick() {
                return true;
            }
            show() {
                this.dialog.show({ title: 'Columns', height: 600, width: 900, overlay: false });
            }
            clear() {
                this.lvControls.clear();
            }
            searchTextKeyDown(e) {
                if (e.key === 'Enter') {
                    this.clear();
                    if (this.txSearchText.getText().trim() === "") {
                        cWindow.msgInfo("You must input some text to search");
                    }
                    else {
                        const report = this.editor.getReport();
                        this.searchInSections(report.getHeaders(), csObjType.iTypeSec);
                        this.searchInSections(report.getGroupsHeaders(), csObjType.iTypeSecG);
                        this.searchInSections(report.getDetails(), csObjType.iTypeSec);
                        this.searchInSections(report.getGroupsFooters(), csObjType.iTypeSecG);
                        this.searchInSections(report.getFooters(), csObjType.iTypeSec);
                    }
                }
            }
            searchInSections(sections, objType) {
                let sec;
                let secLn;
                let ctrl;
                let toSearch;
                toSearch = this.txSearchText.getText().toLowerCase();
                for (let i = 0; i < sections.count(); i++) {
                    sec = sections.item(i);
                    if (sec.getName().toLowerCase().indexOf(toSearch) > -1) {
                        this.addToSearchResult(sec.getName(), objType, objType, "S" + sec.getKey());
                    }
                    if (sec.getFormulaHide().getText().toLowerCase().indexOf(toSearch) > -1) {
                        this.addToSearchResultAt(sec.getName(), objType, csObjType.iTypeFormulaH, "S" + sec.getKey(), sec.getFormulaHide().getText());
                    }
                    for (let j = 0; j < sec.getSectionLines().count(); j++) {
                        secLn = sec.getSectionLines().item(j);
                        if (secLn.getFormulaHide().getText().toLowerCase().indexOf(toSearch) > -1) {
                            this.addToSearchResultAt(sec.getName() + " - Line " + secLn.getIndex().toString(), csObjType.iTypeSecLn, csObjType.iTypeFormulaH, "S" + sec.getKey(), secLn.getFormulaHide().getText());
                        }
                        for (var t = 0; t < secLn.getControls().count(); t++) {
                            ctrl = secLn.getControls().item(t);
                            if (ctrl.getName().toLowerCase().indexOf(toSearch) > -1) {
                                this.addToSearchResult(ctrl.getName(), csObjType.iTypeCtrl, csObjType.iTypeCtrl, ctrl.getKey());
                            }
                            if (ctrl.getControlType() === csRptControlType.RPT_CT_FIELD
                                || ctrl.getControlType() === csRptControlType.RPT_CT_DB_IMAGE) {
                                if (ctrl.getField().getName().toLowerCase().indexOf(toSearch) > -1) {
                                    this.addToSearchResultAt(ctrl.getName(), csObjType.iTypeCtrl, csObjType.iTypeDbField, ctrl.getKey(), ctrl.getField().getName());
                                }
                            }
                            else {
                                if (ctrl.getLabel().getText().toLowerCase().indexOf(toSearch) > -1) {
                                    this.addToSearchResultAt(ctrl.getName(), csObjType.iTypeCtrl, csObjType.iTypeText, ctrl.getKey(), ctrl.getLabel().getText());
                                }
                            }
                            if (ctrl.getFormulaValue().getText().toLowerCase().indexOf(toSearch) > -1) {
                                this.addToSearchResultAt(ctrl.getName(), csObjType.iTypeCtrl, csObjType.iTypeFormulaV, ctrl.getKey(), ctrl.getFormulaValue().getText());
                            }
                            if (ctrl.getFormulaHide().getText().toLowerCase().indexOf(toSearch) > -1) {
                                this.addToSearchResultAt(ctrl.getName(), csObjType.iTypeCtrl, csObjType.iTypeFormulaH, ctrl.getKey(), ctrl.getFormulaHide().getText());
                            }
                        }
                    }
                }
            }
            addToSearchResult(name, objType, objType2, key) {
                this.addToSearchResultAt(name, objType, objType2, key, "");
            }
            addToSearchResultAt(name, objType, objType2, key, where) {
                let item = this.lvControls.add(name);
                item.setImageIndex(objType === objType2 ? objType : objType2);
                item.subItems.add(where);
                item.tag = key;
            }
            setHandler(editor) {
                this.editor = editor;
            }
            lvControlsClick(item) {
                this.selectControl(item);
            }
            selectControl(item) {
                if (item) {
                    let info = item.tag.toString();
                    if (info.length && info.charAt(0) === 'S') {
                        this.editor.selectSection(info.substring(1));
                    }
                    else {
                        this.editor.selectCtrl(info);
                    }
                }
            }
        }
        CSReportEditor.FSearch = FSearch;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        var RefWrapper = CSReports.CSKernelClient.RefWrapper;
        class FSecProperties extends Form {
            constructor() {
                super();
                this.editor = null;
                this.ok = false;
                this.hasFormulaHideChanged = false;
                this.hasFormulaHide = false;
                this.formulaHideChanged = false;
                this.formulaHide = "";
                this.formulaName = "";
            }
            setHandler(editor) {
                this.editor = editor;
            }
            getFormulaName() {
                return this.formulaName;
            }
            getFormulaHide() {
                return this.formulaHide;
            }
            setFormulaHide(rhs) {
                this.formulaHide = rhs;
            }
            getFormulaHideChanged() {
                return this.formulaHideChanged;
            }
            setFormulaHideChanged(rhs) {
                this.formulaHideChanged = rhs;
            }
            getHasFormulaHideChanged() {
                return this.hasFormulaHideChanged;
            }
            getOk() {
                return this.ok;
            }
            fSecProperties_Load(sender, e) {
            }
            cmd_apply_Click(sender, e) {
                this.ok = true;
                this.hide();
            }
            cmd_cancel_Click(sender, e) {
                this.ok = false;
                this.hide();
            }
            cmd_formulaHide_Click(sender, e) {
                this.formulaName = "Ocultar";
                let fh = new RefWrapper(this.formulaHide);
            }
            showDialog() {
            }
            close() {
            }
            getChkFormulaHide() {
            }
            getTxName() {
            }
            getLbSectionName() {
            }
        }
        CSReportEditor.FSecProperties = FSecProperties;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        class FSimpleConnect extends Form {
            constructor() {
                super();
                this.ok = false;
            }
            setServer(value) {
            }
            setDataBase(value) {
            }
            setUser(value) {
            }
            setPassword(value) {
            }
            getUser() {
                return "";
            }
            setConnectTypeToNT() {
            }
            setConnectTypeToSQL() {
            }
            getOk() {
                return this.ok;
            }
            getStrConnect() {
                let strConnect;
                return strConnect;
            }
            cmd_apply_Click(sender, e) {
            }
            cmd_cancel_Click(sender, e) {
                this.ok = false;
            }
            op_sqlConnection_CheckedChanged(sender, e) {
                this.setEnabledUserAndPassword();
            }
            op_trustedConnection_CheckedChanged(sender, e) {
                this.setEnabledUserAndPassword();
            }
            setEnabledUserAndPassword() {
            }
            fSimpleConnect_Load(sender, e) {
            }
        }
        CSReportEditor.FSimpleConnect = FSimpleConnect;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        class FToolbox extends Form {
            constructor() {
                super();
                this.editor = null;
                this.C_CTRL_IMAGE = 0;
                this.C_LABEL_IMAGE = 1;
                this.C_FORMULA_FOLDER_IMAGE = 2;
                this.C_FORMULA_IMAGE = 3;
                this.C_CONTROL_NAME = "C";
                this.C_FORMULA_NAME = "F";
                this.C_FIELD_INDEX = "FC";
                this.C_FIELD_TYPE = "FT";
            }
            clear() {
            }
            addLbFormula(controlName) {
            }
            addFormula(name, controlName, formulaName) {
            }
            addField(name, fieldType, fieldIndex) {
            }
            addLabels(name) {
            }
            setHandler(editor) {
            }
        }
        CSReportEditor.FToolbox = FToolbox;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEditor;
    (function (CSReportEditor) {
        var Form = CSReports.CSForms.Form;
        class FTreeViewCtrls extends Form {
            constructor() {
                super(...arguments);
                this.editor = null;
                this.C_IMG_FOLDER = 0;
                this.C_IMG_FORMULA = 3;
                this.C_IMG_CONTROL = 2;
                this.C_IMG_DATBASE_FIELD = 1;
                this.formulaName = "";
            }
            getFormulaName() {
                return this.formulaName;
            }
            clear() {
            }
            addCtrls() {
            }
            setHandler(editor) {
                this.editor = editor;
            }
            fTreeViewCtrls_Load(sender, e) {
            }
            tv_formulas_NodeMouseClick(sender, e) {
            }
            selectAndShowInfo(node) {
            }
            tv_formulas_NodeMouseDoubleClick(sender, e) {
            }
            tv_controls_KeyUp(sender, e) {
            }
            getControl(key) {
                return this.editor.getReport().getControls().item(key);
            }
            getObjectDescription(anObject) {
            }
            getObjectDescriptionAt(anObject, n) {
            }
            getValue(value, n) {
            }
            getMethods(obj) {
            }
            cmd_edit_Click(sender, e) {
            }
            cmd_close_Click(sender, e) {
            }
        }
        CSReportEditor.FTreeViewCtrls = FTreeViewCtrls;
    })(CSReportEditor = CSReports.CSReportEditor || (CSReports.CSReportEditor = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class FindAccessFileEventArgs {
            FindAccessFileEventArgs(file) {
                this.file = file;
            }
            getFile() {
                return this.file;
            }
            isCancel() {
                return this.cancel;
            }
        }
        CSReportEngine.FindAccessFileEventArgs = FindAccessFileEventArgs;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class ProgressEventArgs {
            constructor(task, page, currRecord, recordCount) {
                this.cancel = false;
                this.task = task;
                this.page = page;
                this.currRecord = currRecord;
                this.recordCount = recordCount;
            }
        }
        CSReportEngine.ProgressEventArgs = ProgressEventArgs;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class Rectangle {
        }
        CSReportEngine.Rectangle = Rectangle;
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }
        CSReportEngine.Point = Point;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Exception = CSReports.CSOAPI.Exception;
        class ReportArgumentMissingException extends Exception {
        }
        CSReportEngine.ReportArgumentMissingException = ReportArgumentMissingException;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Exception = CSReports.CSOAPI.Exception;
        class ReportException extends Exception {
            constructor(errorCode, message) {
                super(message);
            }
        }
        CSReportEngine.ReportException = ReportException;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class ReportLaunchInfoNoDefined extends CSReportEngine.ReportException {
        }
        CSReportEngine.ReportLaunchInfoNoDefined = ReportLaunchInfoNoDefined;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class ReportNotDefinedFunctionException extends CSReportEngine.ReportException {
        }
        CSReportEngine.ReportNotDefinedFunctionException = ReportNotDefinedFunctionException;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        var cXmlProperty = CSReports.CSXml.cXmlProperty;
        class cColumnInfo {
            constructor() {
                this.name = "";
                this.position = 0;
                this.key = "";
            }
            getKey() {
                return this.key;
            }
            setKey(key) {
                this.key = key;
            }
            getName() {
                return this.name;
            }
            setName(name) {
                this.name = name;
            }
            getColumnType() {
                return this.columnType;
            }
            setColumnType(type) {
                this.columnType = type;
            }
            getPosition() {
                return this.position;
            }
            setPosition(position) {
                this.position = position;
            }
            copy(from) {
                this.columnType = from.columnType;
                this.position = from.position;
                this.name = from.name;
                this.key = from.key;
                return true;
            }
            load(xDoc, nodeObj) {
                this.columnType = xDoc.getNodeProperty(nodeObj, "TypeColumn").getValueInt(eTypes.eInteger);
                this.position = xDoc.getNodeProperty(nodeObj, "Position").getValueInt(eTypes.eInteger);
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                this.key = xDoc.getNodeProperty(nodeObj, "Key").getValueString(eTypes.eText);
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = new cXmlProperty();
                xProperty.setName(this.key);
                let nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty = new cXmlProperty();
                xProperty.setName("Key");
                xProperty.setValue(eTypes.eText, this.key);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty = new cXmlProperty();
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty = new cXmlProperty();
                xProperty.setName("Position");
                xProperty.setValue(eTypes.eInteger, this.position);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty = new cXmlProperty();
                xProperty.setName("TypeColumn");
                xProperty.setValue(eTypes.eInteger, this.columnType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
        }
        CSReportEngine.cColumnInfo = cColumnInfo;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cImage {
            static serialiseBitmap(arg0, vBytes) {
                throw new Error("Method not implemented.");
            }
            static deSerialiseBitmap(vBytes) {
                throw new Error("Method not implemented.");
            }
        }
        CSReportEngine.cImage = cImage;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        var DatabaseGlobals = CSReports.CSDatabase.DatabaseGlobals;
        class cParameter {
            constructor() {
                this.name = "";
                this.columnType = null;
                this.value = "";
                this.position = 0;
                this.key = "";
                this.hasDefault = null;
                this.default = "";
                this.isNullable = null;
                this.maxLength = 0;
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getColumnType() {
                return this.columnType;
            }
            setColumnType(rhs) {
                this.columnType = rhs;
            }
            getValue() {
                return this.value;
            }
            setValue(rhs) {
                this.value = rhs;
            }
            getPosition() {
                return this.position;
            }
            setPosition(rhs) {
                this.position = rhs;
            }
            getHasDefault() {
                return this.hasDefault;
            }
            setHasDefault(rhs) {
                this.hasDefault = rhs;
            }
            getDefaultValue() {
                return this.default;
            }
            setDefaultValue(rhs) {
                this.default = rhs;
            }
            getIsNullable() {
                return this.isNullable;
            }
            setIsNullable(rhs) {
                this.isNullable = rhs;
            }
            getMaxLength() {
                return this.maxLength;
            }
            setMaxLength(rhs) {
                this.maxLength = rhs;
            }
            copy(from) {
                this.columnType = from.columnType;
                this.value = from.value;
                this.position = from.position;
                this.name = from.name;
                this.maxLength = from.maxLength;
                this.key = from.key;
                this.isNullable = from.isNullable;
                this.hasDefault = from.hasDefault;
                this.default = from.default;
                return true;
            }
            load(xDoc, nodeObj) {
                this.columnType = DatabaseGlobals.getDataTypeFromAdo(xDoc.getNodeProperty(nodeObj, "TypeColumn").getValueInt(eTypes.eInteger));
                this.value = xDoc.getNodeProperty(nodeObj, "Value").getValueString(eTypes.eText);
                this.position = xDoc.getNodeProperty(nodeObj, "Position").getValueInt(eTypes.eInteger);
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                this.maxLength = xDoc.getNodeProperty(nodeObj, "MaxLength").getValueInt(eTypes.eInteger);
                this.key = xDoc.getNodeProperty(nodeObj, "Key").getValueString(eTypes.eText);
                this.isNullable = xDoc.getNodeProperty(nodeObj, "IsNullable").getValueBool(eTypes.eBoolean);
                this.hasDefault = xDoc.getNodeProperty(nodeObj, "HasDefault").getValueBool(eTypes.eBoolean);
                this.default = xDoc.getNodeProperty(nodeObj, "Default").getValueString(eTypes.eText);
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName(this.key);
                let nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Key");
                xProperty.setValue(eTypes.eText, this.key);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Position");
                xProperty.setValue(eTypes.eInteger, this.position);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("TypeColumn");
                xProperty.setValue(eTypes.eInteger, DatabaseGlobals.getAdoTypeFromDataType(this.columnType));
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Value");
                xProperty.setValue(eTypes.eText, this.value);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("MaxLength");
                xProperty.setValue(eTypes.eInteger, this.maxLength);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("IsNullable");
                xProperty.setValue(eTypes.eBoolean, this.isNullable);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("HasDefault");
                xProperty.setValue(eTypes.eBoolean, this.hasDefault);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Default");
                xProperty.setValue(eTypes.eText, this.default);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
        }
        CSReportEngine.cParameter = cParameter;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cParameters extends Map {
            constructor() {
                super(null, false, CSReportEngine.cParameter);
            }
            add(c, key) {
                try {
                    if (c === null) {
                        c = new CSReportEngine.cParameter();
                    }
                    if (key === "") {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
        }
        CSReportEngine.cParameters = cParameters;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cPrintWMI {
            static getPrinterInfoValueFromWMI(propertyName, printerInfo, defaultValue) {
                return "";
            }
            static getPrinterInfoValueFromWMI2(printerName, propertyName, defaultValue) {
                return this.getPrinterInfoValueFromWMI(propertyName, this.getPrinterInfoFromWMI(printerName), defaultValue);
            }
            static getPrinterConfigInfoValueFromWMI(propertyName, printerInfo, defaultValue) {
                return this.getPrinterInfoValueFromWMI(propertyName, printerInfo, defaultValue.toString());
            }
            static getPrinterConfigInfoValueFromWMI2(printerName, propertyName, defaultValue) {
                return this.getPrinterInfoValueFromWMI(propertyName, cPrintWMI.getPrinterConfigInfoFromWMI(printerName), defaultValue);
            }
            static getPrinterInfoFromWMI(printerName) {
                return this.getInfoFromWMI("Win32_Printer", printerName);
            }
            static getPrinterConfigInfoFromWMI(printerName) {
                return this.getInfoFromWMI("Win32_PrinterConfiguration", printerName);
            }
            static getInfoFromWMI(tableName, objectName) {
                return null;
            }
        }
        CSReportEngine.cPrintWMI = cPrintWMI;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csRptChartFormat = CSReports.CSReportGlobals.csRptChartFormat;
        var csRptChartType = CSReports.CSReportGlobals.csRptChartType;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        var eTypes = CSReports.CSKernelClient.eTypes;
        var cWebChart = CSReports.CSChartServer.cWebChart;
        var cError = CSReports.CSKernelClient.cError;
        var U = CSReports.CSOAPI.Utils;
        class cReportChart {
            constructor() {
                this.series = new CSReportEngine.cReportChartSeries();
                this.chartLineStyle = null;
                this.chartBarOutline = null;
                this.chartShowValues = null;
                this.pieThickness = null;
                this.pieDiameter = null;
                this.imageFormat = csRptChartFormat.PNG;
                this.copyright = "";
                this.chartTitle = "";
                this.chartType = null;
                this.top = 0;
                this.chartCreated = null;
                this.groupFieldName = "";
                this.groupValue = "";
                this.groupFieldIndex = 0;
                this.sort = null;
                this.width = 700;
                this.height = 280;
                this.image = null;
            }
            getSeries() {
                return this.series;
            }
            setSeries(rhs) {
                this.series = rhs;
            }
            getGridLines() {
                return this.chartLineStyle;
            }
            setGridLines(value) {
                this.chartLineStyle = value;
            }
            getOutlineBars() {
                return this.chartBarOutline;
            }
            setOutlineBars(value) {
                this.chartBarOutline = value;
            }
            getShowValues() {
                return this.chartShowValues;
            }
            setShowValues(value) {
                this.chartShowValues = value;
            }
            getThickness() {
                return this.pieThickness;
            }
            setThickness(value) {
                this.pieThickness = value;
            }
            getDiameter() {
                return this.pieDiameter;
            }
            setDiameter(value) {
                this.pieDiameter = value;
            }
            getFormat() {
                return this.imageFormat;
            }
            setFormat(value) {
                this.imageFormat = value;
            }
            getCopyRight() {
                return this.copyright;
            }
            setCopyRight(value) {
                this.copyright = value;
            }
            getGroupFieldName() {
                return this.groupFieldName;
            }
            setGroupFieldName(value) {
                this.groupFieldName = value;
            }
            getGroupValue() {
                return this.groupValue;
            }
            setGroupValue(value) {
                this.groupValue = value;
            }
            getGroupFieldIndex() {
                return this.groupFieldIndex;
            }
            setGroupFieldIndex(value) {
                this.groupFieldIndex = value;
            }
            getChartTitle() {
                return this.chartTitle;
            }
            setChartTitle(rhs) {
                this.chartTitle = rhs;
            }
            getSort() {
                return this.sort;
            }
            setSort(rhs) {
                this.sort = rhs;
            }
            getChartType() {
                return this.chartType;
            }
            setChartType(rhs) {
                this.chartType = rhs;
            }
            getTop() {
                return this.top;
            }
            setTop(rhs) {
                this.top = rhs;
            }
            getChartCreated() {
                return this.chartCreated;
            }
            setChartCreated(rhs) {
                this.chartCreated = rhs;
            }
            getImage() {
                return this.image;
            }
            makeChartFromRs(rs, fileName) {
                cError.setSilent(true);
                return this.make(rs.getRows(), "###,###,##0.00", true, fileName);
            }
            copy(from) {
                if (from !== null) {
                    this.chartLineStyle = from.chartLineStyle;
                    this.chartBarOutline = from.chartBarOutline;
                    this.chartShowValues = from.chartShowValues;
                    this.pieThickness = from.pieThickness;
                    this.pieDiameter = from.pieDiameter;
                    this.imageFormat = from.imageFormat;
                    this.copyright = from.copyright;
                    this.chartTitle = from.chartTitle;
                    this.chartType = from.chartType;
                    this.top = from.top;
                    this.groupValue = from.groupValue;
                    this.groupFieldName = from.groupFieldName;
                    this.groupFieldIndex = from.groupFieldIndex;
                    this.sort = from.sort;
                    let index = 0;
                    for (let i = 0; i < from.series.values.length; i++) {
                        index = index + 1;
                        if (!this.getSeries().add(null, "").copy(from.series.values[i])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, "Chart");
                if (nodeObj !== null) {
                    this.chartLineStyle = xDoc.getNodeProperty(nodeObj, "LineStyle").getValueInt(eTypes.eInteger);
                    this.chartBarOutline = xDoc.getNodeProperty(nodeObj, "BarOutline").getValueBool(eTypes.eBoolean);
                    this.chartShowValues = xDoc.getNodeProperty(nodeObj, "ShowValues").getValueBool(eTypes.eBoolean);
                    this.pieThickness = xDoc.getNodeProperty(nodeObj, "PieThickness").getValueInt(eTypes.eInteger);
                    this.pieDiameter = xDoc.getNodeProperty(nodeObj, "PieDiameter").getValueInt(eTypes.eInteger);
                    this.imageFormat = xDoc.getNodeProperty(nodeObj, "ImageFormat").getValueInt(eTypes.eInteger);
                    this.copyright = xDoc.getNodeProperty(nodeObj, "Copyright").getValueString(eTypes.eText);
                    this.chartTitle = xDoc.getNodeProperty(nodeObj, "ChartTitle").getValueString(eTypes.eText);
                    this.chartType = xDoc.getNodeProperty(nodeObj, "ChartType").getValueInt(eTypes.eInteger);
                    this.top = xDoc.getNodeProperty(nodeObj, "Top").getValueInt(eTypes.eInteger);
                    this.groupValue = xDoc.getNodeProperty(nodeObj, "GroupValue").getValueString(eTypes.eText);
                    this.groupFieldName = xDoc.getNodeProperty(nodeObj, "GroupFieldName").getValueString(eTypes.eText);
                    this.groupFieldIndex = xDoc.getNodeProperty(nodeObj, "GroupFieldIndex").getValueInt(eTypes.eInteger);
                    this.sort = xDoc.getNodeProperty(nodeObj, "Sort").getValueBool(eTypes.eBoolean);
                    let nodeObjAux = null;
                    let nodeObjSeries = null;
                    let index = 0;
                    nodeObj = xDoc.getNodeFromNode(nodeObj, "Series");
                    if (xDoc.nodeHasChild(nodeObj)) {
                        nodeObjSeries = xDoc.getNodeChild(nodeObj);
                        while (nodeObjSeries !== null) {
                            index = index + 1;
                            nodeObjAux = nodeObjSeries;
                            if (!this.getSeries().add(null, "").load(xDoc, nodeObjAux, index)) {
                                return false;
                            }
                            nodeObjSeries = xDoc.getNextNode(nodeObjSeries);
                        }
                    }
                }
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Chart");
                let nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("LineStyle");
                xProperty.setValue(eTypes.eInteger, this.chartLineStyle);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("BarOutline");
                xProperty.setValue(eTypes.eBoolean, this.chartBarOutline);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ShowValues");
                xProperty.setValue(eTypes.eBoolean, this.chartShowValues);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("PieThickness");
                xProperty.setValue(eTypes.eInteger, this.pieThickness);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("PieDiameter");
                xProperty.setValue(eTypes.eInteger, this.pieDiameter);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ImageFormat");
                xProperty.setValue(eTypes.eInteger, this.imageFormat);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Copyright");
                xProperty.setValue(eTypes.eText, this.copyright);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ChartTitle");
                xProperty.setValue(eTypes.eText, this.chartTitle);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ChartType");
                xProperty.setValue(eTypes.eInteger, this.chartType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Top");
                xProperty.setValue(eTypes.eInteger, this.top);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("GroupFieldName");
                xProperty.setValue(eTypes.eText, this.groupFieldName);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("GroupFieldIndex");
                xProperty.setValue(eTypes.eInteger, this.groupFieldIndex);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("GroupValue");
                xProperty.setValue(eTypes.eText, this.groupValue);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Sort");
                xProperty.setValue(eTypes.eBoolean, this.sort);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Series");
                nodeObj = xDoc.addNodeToNode(nodeObj, xProperty);
                let serie = null;
                let index = 0;
                for (let _i = 0; _i < this.series.count(); _i++) {
                    serie = this.series.item(_i);
                    index = index + 1;
                    serie.save(xDoc, nodeObj, index);
                }
                return true;
            }
            make(rows, strFormat, bIsForWeb, fileName) {
                if (rows === null) {
                    return false;
                }
                let chart = new cWebChart();
                chart.newChartType(this.chartType, this.chartTitle);
                this.fill(chart, rows, strFormat);
                chart.setPrimaryColor(this.series.item(0).getColor());
                chart.setPrimaryLabel(ReportGlobals.getRealName(this.series.item(0).getValueFieldName()));
                if (this.series.count() > 1) {
                    chart.setAlternateColor(this.series.item(1).getColor());
                    chart.setAlternateLabel(ReportGlobals.getRealName(this.series.item(1).getValueFieldName()));
                }
                chart.setGridLines(this.chartLineStyle);
                chart.setOutlineBars(this.chartBarOutline);
                chart.setShowValues(this.chartShowValues);
                chart.setShowLegend((this.chartType === csRptChartType.BAR) ? false : this.chartShowValues);
                chart.setThickness(this.pieThickness);
                chart.setDiameter(this.pieDiameter);
                chart.setCopyRight(this.copyright);
                chart.renderWebChartImage(this.width, this.height);
                this.image = chart.getImage();
                this.chartCreated = true;
                chart.dispose();
                return true;
            }
            getWidth() {
                return this.width;
            }
            getHeight() {
                return this.height;
            }
            getSeriesValues(rows, v, valueIndex, labelIndex, bOthers) {
                let i = 0;
                let j = 0;
                let q = 0;
                let value = 0;
                let bFound = false;
                let bCompare = false;
                let newTop = 0;
                if (this.groupFieldIndex >= 0) {
                    for (j = 0; j < rows.length; j++) {
                        if (ReportGlobals.valVariant(rows[j][this.groupFieldIndex]) === this.groupValue) {
                            newTop++;
                        }
                    }
                    if (newTop > 0) {
                        newTop--;
                    }
                    if (newTop > v.length) {
                        this.redimPreserve(v, newTop);
                    }
                }
                if (this.sort) {
                    if (this.groupFieldIndex >= 0) {
                        for (j = 0; j < rows.length; j++) {
                            if (ReportGlobals.valVariant(rows[j][this.groupFieldIndex]) === this.groupValue) {
                                v[0].value = ReportGlobals.valVariant(rows[j][valueIndex]);
                                v[0].label = ReportGlobals.valVariant(rows[j][labelIndex]);
                                v[0].idx = j;
                                break;
                            }
                        }
                    }
                    else {
                        v[0].value = ReportGlobals.valVariant(rows[0][valueIndex]);
                        v[0].label = ReportGlobals.valVariant(rows[0][labelIndex]);
                        v[0].idx = 0;
                    }
                    for (j = 0; j < rows.length; j++) {
                        if (this.groupFieldIndex >= 0) {
                            bCompare = ReportGlobals.valVariant(rows[j][this.groupFieldIndex]) === this.groupValue;
                        }
                        else {
                            bCompare = true;
                        }
                        if (bCompare) {
                            value = U.val(ReportGlobals.valVariant(rows[j][valueIndex]));
                            if (value > v[0].value) {
                                v[0].value = value;
                                v[0].label = ReportGlobals.valVariant(rows[j][labelIndex]);
                                v[0].idx = j;
                            }
                        }
                    }
                    for (i = 1; i < v.length; i++) {
                        v[i].idx = -1;
                        for (j = 0; j < rows.length; j++) {
                            if (this.groupFieldIndex >= 0) {
                                bCompare = ReportGlobals.valVariant(rows[j][this.groupFieldIndex]) === this.groupValue;
                            }
                            else {
                                bCompare = true;
                            }
                            if (bCompare) {
                                value = U.val(ReportGlobals.valVariant(rows[j][valueIndex]));
                                if ((value > v[i].value || v[i].idx === -1)
                                    && value <= v[i - 1].value && j !== v[i - 1].idx) {
                                    bFound = false;
                                    for (q = 0; q <= i; q++) {
                                        if (j === v[q].idx) {
                                            bFound = true;
                                            break;
                                        }
                                    }
                                    if (!bFound) {
                                        v[i].value = value;
                                        v[i].label = ReportGlobals.valVariant(rows[j][labelIndex]).toString();
                                        v[i].idx = j;
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    i = 0;
                    for (j = 0; j < rows.length; j++) {
                        if (this.groupFieldIndex >= 0) {
                            if (ReportGlobals.valVariant(rows[j][this.groupFieldIndex]) === this.groupValue) {
                                if (this.pGetSerieValuesAux(rows, v, valueIndex, labelIndex, i, j, false)) {
                                    break;
                                }
                            }
                        }
                        else {
                            if (this.pGetSerieValuesAux(rows, v, valueIndex, labelIndex, i, j, false)) {
                                break;
                            }
                        }
                    }
                    if (bOthers) {
                        if (rows.length > v.length) {
                            let n = 0;
                            let k = 0;
                            let bHaveToRedim = false;
                            bHaveToRedim = true;
                            n = v.length + 1;
                            for (j = 0; j < rows.length; j++) {
                                if (this.groupFieldIndex >= 0) {
                                    if (ReportGlobals.valVariant(rows[j][this.groupFieldIndex]) === this.groupValue) {
                                        if (k >= n) {
                                            if (bHaveToRedim) {
                                                this.redimPreserve(v, n);
                                                bHaveToRedim = false;
                                            }
                                            this.pGetSerieValuesAux(rows, v, valueIndex, labelIndex, v.length, j, true);
                                        }
                                        else {
                                            k = k + 1;
                                        }
                                    }
                                }
                                else {
                                    if (bHaveToRedim) {
                                        this.redimPreserve(v, n);
                                        bHaveToRedim = false;
                                    }
                                    this.pGetSerieValuesAux(rows, v, valueIndex, labelIndex, v.length, j, true);
                                }
                            }
                        }
                    }
                }
            }
            pGetSerieValuesAux(rows, v, valueIndex, labelIndex, i, j, bAdd) {
                if (bAdd) {
                    v[i].value = v[i].value + ReportGlobals.valVariant(rows[j][valueIndex]);
                }
                else {
                    v[i].value = ReportGlobals.valVariant(rows[j][valueIndex]);
                }
                v[i].label = ReportGlobals.valVariant(rows[j][labelIndex]);
                v[i].idx = j;
                i = i + 1;
                return i > v.length;
            }
            fill(chart, rows, strFormat) {
                let i = 0;
                let values = [];
                let serie = null;
                let idxSerie = 0;
                if (this.top === 0) {
                    this.top = 50;
                }
                if (rows.length < 0) {
                    return;
                }
                if (rows.length < this.top) {
                    values = U.newArrayOfObjects(rows.length, () => new t_SerieValue());
                }
                else {
                    values = U.newArrayOfObjects(this.top, () => new t_SerieValue());
                }
                for (let _i = 0; _i < this.series.count(); _i++) {
                    serie = this.series.item(_i);
                    idxSerie = idxSerie + 1;
                    if (idxSerie > 2) {
                        return;
                    }
                    this.getSeriesValues(rows, values, serie.getValueIndex(), serie.getLabelIndex(), this.chartType === csRptChartType.PIE);
                    for (i = 0; i < values.length; i++) {
                        if (values[i].idx !== -1) {
                            if (idxSerie === 1) {
                                let item = chart.getItems().add(null);
                                item.setPrimaryValue(values[i].value);
                                item.setPrimaryLabel(ReportGlobals.format(values[i].label, strFormat));
                                item.setPieLabel(ReportGlobals.format(values[i].label, strFormat));
                                item.setAlternateValue(0);
                            }
                            else if (idxSerie === 2) {
                                let item = chart.getItems().item(i);
                                item.setAlternateValue(values[i].value);
                                item.setPieLabel(ReportGlobals.format(values[i].label, strFormat));
                                item.setAlternateLabel(ReportGlobals.format(values[i].label, strFormat));
                            }
                        }
                    }
                    if ((values.length > this.top - 1) && this.chartType === csRptChartType.PIE) {
                        let item = chart.getItems().item(chart.getItems().count() - 1);
                        item.setPrimaryLabel("Otros");
                        item.setPieLabel("Otros");
                    }
                }
                if (chart.getItems().count() > 0) {
                    chart.getItems().item(0).setExplode(true);
                }
            }
            redimPreserve(vSeries, size) {
                if (size === 0) {
                    vSeries = [];
                }
                else {
                    if (vSeries === null || vSeries.length === 0) {
                        vSeries = U.newArrayOfObjects(size, () => new t_SerieValue());
                    }
                    else {
                        if (vSeries.length < size) {
                            vSeries = vSeries.concat(U.newArrayOfObjects(size - vSeries.length, () => new t_SerieValue()));
                        }
                        else if (vSeries.length > size) {
                            vSeries = vSeries.slice(0, size);
                        }
                    }
                }
            }
            toString() {
                return "type: " + this.chartType;
            }
        }
        CSReportEngine.cReportChart = cReportChart;
        class t_SerieValue {
            constructor() {
                this.label = null;
                this.value = null;
                this.idx = null;
            }
        }
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportChartSeries extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportChartSequence);
            }
            add(value, key) {
                if (value === null || value === undefined) {
                    value = new CSReportEngine.cReportChartSequence();
                }
                return this.baseAdd(value, key);
            }
        }
        CSReportEngine.cReportChartSeries = cReportChartSeries;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportScript;
    (function (CSReportScript) {
        var Map = CSReports.CSOAPI.Map;
        class cReportCompilerGlobals extends Map {
            constructor() {
                super(null, false, CSReportScript.cReportCompilerVar);
                this.mode = eReportCompilerMode.EVAL;
            }
            getMode() {
                return this.mode;
            }
            setMode(mode) {
                this.mode = mode;
            }
            addVar(varName) {
                try {
                    this.add(new CSReportScript.cReportCompilerVar(), varName);
                    return this.getVar(varName);
                }
                catch (ignore) {
                    return null;
                }
            }
            getVar(varName) {
                try {
                    return this.item(varName);
                }
                catch (ignore) {
                    return null;
                }
            }
        }
        CSReportScript.cReportCompilerGlobals = cReportCompilerGlobals;
        let eReportCompilerMode;
        (function (eReportCompilerMode) {
            eReportCompilerMode[eReportCompilerMode["EVAL"] = 0] = "EVAL";
            eReportCompilerMode[eReportCompilerMode["RESULT"] = 1] = "RESULT";
        })(eReportCompilerMode = CSReportScript.eReportCompilerMode || (CSReportScript.eReportCompilerMode = {}));
    })(CSReportScript = CSReports.CSReportScript || (CSReports.CSReportScript = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var cReportCompilerGlobals = CSReports.CSReportScript.cReportCompilerGlobals;
        var csRptErrors = CSReports.CSReportGlobals.csRptErrors;
        var csRptFormulaType = CSReports.CSReportGlobals.csRptFormulaType;
        var cError = CSReports.CSKernelClient.cError;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        var U = CSReports.CSOAPI.Utils;
        var eReportCompilerMode = CSReports.CSReportScript.eReportCompilerMode;
        var cDateUtils = CSReports.CSKernelClient.cDateUtils;
        var cNumberToString = CSReports.CSKernelNumberToString.cNumberToString;
        var RefWrapper = CSReports.CSKernelClient.RefWrapper;
        class cReportCompiler {
            constructor() {
                this.formulaTypes = new CSReportEngine.cReportFormulaTypes();
                this.report = null;
                this.variables = new CSReportEngine.cReportVariables();
                this.formula = null;
                this.fint = null;
                this.objGlobals = new cReportCompilerGlobals();
                this.collTextReplace = new Map();
                this.ctrlName = "";
                this.bCompile = null;
                this.idxFormula = -1;
            }
            getReport() {
                return this.report;
            }
            setReport(rhs) {
                this.report = rhs;
            }
            clearVariables() {
                this.variables.clear();
            }
            initGlobalObject() {
                this.objGlobals.clear();
                this.collTextReplace.clear();
            }
            checkSyntax(formula) {
                try {
                    this.formula = formula;
                    this.formula.getFormulasInt().clear();
                    let code = formula.getText();
                    this.formula.setTextC(code);
                    this.checkSyntax2(code);
                    return true;
                }
                catch (ex) {
                    cError.mngError(ex);
                    this.formula = null;
                    this.fint = null;
                    return false;
                }
            }
            initVariable(formula) {
                for (let i = 0; i < formula.getFormulasInt().count(); i++) {
                    let fint = formula.getFormulasInt().item(i);
                    for (let j = 0; j < fint.getVariables().count(); j++) {
                        let variable = fint.getVariables().item(j);
                        let typeCode = typeof variable.getValue();
                        switch (typeCode) {
                            case "number":
                                variable.setValue(0);
                                break;
                            case "string":
                                variable.setValue("");
                                break;
                            case "object":
                                if (variable.getValue() === null)
                                    break;
                                if (variable.getValue().constructor.name === CSReportEngine.cStructTime.constructor.name) {
                                    let st = variable.getValue();
                                    st.setHour(0);
                                    st.setMinute(0);
                                    st.setSecond(0);
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
            evalGroupFunctions(formula) {
                let fint = null;
                for (let _i = 0; _i < formula.getFormulasInt().count(); _i++) {
                    fint = formula.getFormulasInt().item(_i);
                    switch (fint.getFormulaType()) {
                        case csRptFormulaType.CSRPTF_GROUP_TOTAL:
                            this.evalGroupTotal(fint);
                            break;
                        case csRptFormulaType.CSRPTF_GROUP_MAX:
                            this.evalGroupMax(fint);
                            break;
                        case csRptFormulaType.CSRPTF_GROUP_MIN:
                            this.evalGroupMin(fint);
                            break;
                        case csRptFormulaType.CSRPTF_GROUP_AVERAGE:
                            this.evalGroupAverage(fint);
                            break;
                        case csRptFormulaType.CSRPTF_GROUP_PERCENT:
                            this.evalGroupPercent(fint);
                            break;
                        case csRptFormulaType.CSRPTF_GROUP_COUNT:
                            this.evalGroupCount(fint);
                            break;
                        case csRptFormulaType.CSRPTF_GROUP_LINE_NUMBER:
                            this.evalGroupLineNumber(fint);
                            break;
                    }
                }
            }
            resultFunction(formula) {
                this.objGlobals.setMode(eReportCompilerMode.RESULT);
                this.ctrlName = formula.getControlName();
                let vResult = [];
                let fint = null;
                for (let i = 0; i < formula.getFormulasInt().count(); i++) {
                    fint = formula.getFormulasInt().item(i);
                    vResult[i] = this.pResultFunctionInt(fint);
                }
                let code = formula.getTextC().replaceAll(cReportCompiler.KEY_FUNC_INT, "");
                code = code.replaceAll(" ", "");
                if (U.isNumber(code)) {
                    if (vResult.length > 0) {
                        formula.setLastResult(vResult[0]);
                        formula.setHaveToEval(false);
                        return formula.getLastResult();
                    }
                    else {
                        return code;
                    }
                }
                else {
                    code = formula.getTextC();
                    let parameters = "";
                    for (let i = 0; i < vResult.length; i++) {
                        if (vResult[i] === null) {
                            return null;
                        }
                        let parameter = "p__" + i + "__";
                        parameters += parameter + ",";
                        code = code.replaceAll(cReportCompiler.KEY_FUNC_INT + ReportGlobals.format(i + 1, "000"), parameter);
                        let paramValue = this.objGlobals.getVar(parameter);
                        if (paramValue === null) {
                            paramValue = this.objGlobals.addVar(parameter);
                        }
                        paramValue.setValue(vResult[i]);
                    }
                    if (parameters.length > 0) {
                        parameters = parameters.substring(0, parameters.length - 1);
                        code = this.insertParametersIntoFunction(code, parameters);
                    }
                    formula.setLastResult(this.executeScriptCode(code, formula));
                    formula.setHaveToEval(false);
                    return formula.getLastResult();
                }
            }
            insertParametersIntoFunction(code, parameters) {
                let n = code.indexOf("(") + 1;
                return code.substring(0, n) + parameters + code.substring(n);
            }
            pEvalFunctionGroup(fint) {
                let value = 0;
                let total = 0;
                if (fint.getVariables().count() > 0) {
                    if (fint.getParameters().item(ReportGlobals.KEY_INDEX_COL2) === null) {
                        value = 0;
                    }
                    else {
                        let columnIndex = U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_COL2).getValue());
                        value = U.val(this.report.getValueFromRs(columnIndex).toString());
                    }
                    let variable = fint.getVariables().item(cReportCompiler.GROUP_PERCENT_T);
                    total = U.val(variable.getValue().toString());
                    value = U.divideByZero(value, total);
                    variable.setValue(value);
                }
            }
            evalFunctionGroup(formula) {
                let fint = null;
                for (let i = 0; i < formula.getFormulasInt().count(); i++) {
                    fint = formula.getFormulasInt().item(i);
                    this.pEvalFunctionGroup(fint);
                }
            }
            evalFunction(formula) {
                let codeC = "";
                this.objGlobals.setMode(eReportCompilerMode.EVAL);
                this.evalGroupFunctions(formula);
                CSReportEngine.cReportError.gDebugSection = formula.getSectionName();
                CSReportEngine.cReportError.gDebugSectionLine = formula.getSectionLineIndex();
                CSReportEngine.cReportError.gDebugControl = formula.getControlName();
                this.formula = formula;
                this.pCompile(formula.getText(), false, codeC);
                if (formula.getFormulasInt().count() > 0) {
                    if (U.isNumber(codeC)) {
                        this.pEvalSyntax("", codeC, false, formula);
                    }
                    else {
                        if (codeC.trim().substring(0, 8).toLowerCase() === "function") {
                            this.pEvalSyntax("", codeC, false, formula);
                        }
                    }
                }
                else {
                    this.pEvalSyntax("", codeC, false, formula);
                }
                this.formula = null;
            }
            pCompile(code, bCompile, codeC) {
                this.bCompile = bCompile;
                this.idxFormula = -1;
                code = this.pColonToPipe(code);
                return this.pCompileAux(code, new RefWrapper(codeC));
            }
            pColonToPipe(code) {
                return code.replaceAll(",", "|");
            }
            pipeToColon(code) {
                return code.replaceAll("|", ",");
            }
            pIsFunction(word) {
                let f = null;
                for (let _i = 0; _i < this.formulaTypes.count(); _i++) {
                    f = this.formulaTypes.item(_i);
                    if (word.toLowerCase() === f.getName().toLowerCase()) {
                        return true;
                    }
                }
                return false;
            }
            pAddFormulaInt(functionName, code) {
                this.fint = this.formula.getFormulasInt().add();
                return this.pEvalSyntax(functionName, code, true, null);
            }
            pEvalFunctionInt(fint) {
                switch (fint.getFormulaType()) {
                    case csRptFormulaType.CSRPTF_AVERAGE:
                        this.evalAverage(fint);
                        break;
                    case csRptFormulaType.CSRPTF_SUM:
                        this.evalSum(fint);
                        break;
                    case csRptFormulaType.CSRPTF_SUM_TIME:
                        this.evalSumTime(fint);
                        break;
                    case csRptFormulaType.CSRPTF_MAX:
                        this.evalMax(fint);
                        break;
                    case csRptFormulaType.CSRPTF_MIN:
                        this.evalMin(fint);
                        break;
                    case csRptFormulaType.CSRPTF_COUNT:
                        this.evalCount(fint);
                        break;
                    case csRptFormulaType.CSRPTF_NUMBER_TO_STRING:
                        this.evalNumberToString(fint);
                        break;
                    case csRptFormulaType.CSRPTF_IS_EQUAL:
                        this.evalIsEqual(fint);
                        break;
                    case csRptFormulaType.CSRPTF_IS_NOT_EQUAL:
                        this.evalIsNotEqual(fint);
                        break;
                    case csRptFormulaType.CSRPTF_IS_GREATER_THAN:
                        this.evalIsGreaterThan(fint);
                        break;
                    case csRptFormulaType.CSRPTF_IS_LESS_THAN:
                        this.evalIsLessThan(fint);
                        break;
                    case csRptFormulaType.CSRPTF_CALCULATE:
                        break;
                    case csRptFormulaType.CSRPTF_DECLARE_VAR:
                        this.evalDeclareVar(fint);
                        break;
                    case csRptFormulaType.CSRPTF_GET_VAR:
                        break;
                    case csRptFormulaType.CSRPTF_GET_PARAM:
                        break;
                    case csRptFormulaType.CSRPTF_SET_VAR:
                        this.evalSetVar(fint);
                        break;
                    case csRptFormulaType.CSRPTF_GET_BARCODE:
                        this.evalGetBarcode(fint);
                        break;
                    case csRptFormulaType.CSRPTF_ADD_TO_VAR:
                        this.evalAddToVar(fint);
                        break;
                    case csRptFormulaType.CSRPTF_GET_DATA_FROM_RS_AD:
                        this.evalGetDataFromRsAd(fint);
                        break;
                    case csRptFormulaType.CSRPTF_GET_DATA_FROM_RS:
                        this.evalGetDataFromRs(fint);
                        break;
                    case csRptFormulaType.CSRPTF_IS_IN_RS:
                        this.evalIsInRs(fint);
                        break;
                }
            }
            pResultFunctionInt(fint) {
                switch (fint.getFormulaType()) {
                    case csRptFormulaType.CSRPTF_AVERAGE:
                        return this.resultAverage(fint);
                    case csRptFormulaType.CSRPTF_SUM:
                        return this.resultSum(fint);
                    case csRptFormulaType.CSRPTF_GET_STRING:
                        return this.resultGetString(fint);
                    case csRptFormulaType.CSRPTF_SUM_TIME:
                        return this.resultSumTime(fint);
                    case csRptFormulaType.CSRPTF_MAX:
                        return this.resultMax(fint);
                    case csRptFormulaType.CSRPTF_MIN:
                        return this.resultMin(fint);
                    case csRptFormulaType.CSRPTF_COUNT:
                        return this.resultCount(fint);
                    case csRptFormulaType.CSRPTF_NUMBER_TO_STRING:
                        return this.resultNumberToString(fint);
                    case csRptFormulaType.CSRPTF_IS_EQUAL:
                        return this.resultIsEqual(fint);
                    case csRptFormulaType.CSRPTF_IS_NOT_EQUAL:
                        return this.resultIsNotEqual(fint);
                    case csRptFormulaType.CSRPTF_IS_GREATER_THAN:
                        return this.resultIsGreaterThan(fint);
                    case csRptFormulaType.CSRPTF_IS_LESS_THAN:
                        return this.resultIsLessThan(fint);
                    case csRptFormulaType.CSRPTF_PAGE_NUMBER:
                        return this.resultPageNumber();
                    case csRptFormulaType.CSRPTF_TOTAL_PAGES:
                        return this.resultTotalPages();
                    case csRptFormulaType.CSRPTF_VAL:
                        return this.resultValue(fint);
                    case csRptFormulaType.CSRPTF_LENGTH:
                        return this.resultLength(fint);
                    case csRptFormulaType.CSRPTF_TEXT_REPLACE:
                        return this.resultTextReplace(fint);
                    case csRptFormulaType.CSRPTF_CALCULATE:
                        return this.resultCalculate(fint);
                    case csRptFormulaType.CSRPTF_DECLARE_VAR:
                        break;
                    case csRptFormulaType.CSRPTF_GET_VAR:
                        return this.resultGetVar(fint);
                    case csRptFormulaType.CSRPTF_GET_PARAM:
                        return this.resultGetParam(fint);
                    case csRptFormulaType.CSRPTF_SET_VAR:
                        break;
                    case csRptFormulaType.CSRPTF_ADD_TO_VAR:
                        break;
                    case csRptFormulaType.CSRPTF_GET_DATA_FROM_RS_AD:
                        return this.resultGetDataFromRsAd(fint);
                    case csRptFormulaType.CSRPTF_GET_DATA_FROM_RS:
                        return this.resultGetDataFromRs(fint);
                    case csRptFormulaType.CSRPTF_GROUP_TOTAL:
                        return this.resultGroupTotal(fint);
                    case csRptFormulaType.CSRPTF_GROUP_MAX:
                        return this.resultGroupMax(fint);
                    case csRptFormulaType.CSRPTF_GROUP_MIN:
                        return this.resultGroupMin(fint);
                    case csRptFormulaType.CSRPTF_GROUP_AVERAGE:
                        return this.resultGroupAverage(fint);
                    case csRptFormulaType.CSRPTF_GROUP_PERCENT:
                        return this.resultGroupPercent(fint);
                    case csRptFormulaType.CSRPTF_GROUP_COUNT:
                        return this.resultGroupCount(fint);
                    case csRptFormulaType.CSRPTF_GROUP_LINE_NUMBER:
                        return this.resultGroupLineNumber(fint);
                    case csRptFormulaType.CSRPTF_IS_IN_RS:
                        return this.resultIsInRs(fint);
                    case csRptFormulaType.CSRPTF_GET_BARCODE:
                        return this.resultGetBarcode(fint);
                }
                return null;
            }
            pEvalSyntax(functionName, code, bParam, formula) {
                let i = 0;
                let s = "";
                code = this.removeReturns(code);
                if (functionName.length > 0) {
                    return this.pCheckInternalFunction(functionName, code);
                }
                else if (code.length === 0) {
                    return "";
                }
                else if (code === "\"\"") {
                    return "";
                }
                else if (U.isNumber(code)) {
                    return code;
                }
                else if (cDateUtils.isDate(code)) {
                    return code;
                }
                else if (this.pIsTime(code)) {
                    return code;
                }
                else if (!bParam) {
                    this.executeScriptCode(code, formula);
                    return code;
                }
                else {
                    let vParams = null;
                    let parameters = code.trim();
                    if (parameters.length > 2) {
                        debugger;
                        parameters = parameters.substring(2, parameters.length - 2);
                        parameters = parameters.trim();
                        vParams = parameters.split('|');
                    }
                    try {
                        for (i = 0; i < vParams.length; i++) {
                            try {
                                if (!U.isNumber(vParams[i])) {
                                    if (!this.pIsControl(vParams[i])) {
                                        s = cReportCompiler.TEMP_FUNCTION_B + vParams[i] + cReportCompiler.TEMP_FUNCTION_E;
                                        vParams[i] = this.executeScriptCode(s, formula).toString();
                                    }
                                }
                                code = vParams[i] + "|";
                            }
                            catch (ignore) {
                            }
                        }
                        return U.removeLastColon(code);
                    }
                    catch (ignore) {
                    }
                }
                return null;
            }
            pIsTime(code) {
                code = code.trim();
                if (code.indexOf(":", 0) === 0) {
                    return false;
                }
                let vTime = code.split(':');
                if (vTime.length !== 1) {
                    return false;
                }
                return U.isNumber(vTime[0]) && U.isNumber(vTime[1]);
            }
            checkSyntax2(code) {
                this.pCompile(code, true, "");
            }
            executeScriptCode(code, formula) {
                try {
                    code = this.pipeToColon(code);
                    if (formula.getCompiledScript() === null) {
                        formula.setCompiledScript(CSReportEngine.cReportScriptEngine.compileCode(code, formula));
                    }
                    return CSReportEngine.cReportScriptEngine.eval(formula.getCompiledScript(), this.objGlobals);
                }
                catch (ex) {
                    let msg = ex.stack + "\n\n" + ex.message + "\n\nCode:\n=====\n\n" + code + "\n\n";
                    throw new CSReportEngine.ReportException(csRptErrors.ERROR_IN_SCRIPT, msg);
                }
            }
            pIsControl(param) {
                for (let i = 0; i < this.report.getControls().count(); i++) {
                    let ctrl = this.report.getControls().item(i);
                    if (ctrl.getName().toUpperCase() === param.toUpperCase()) {
                        return true;
                    }
                }
                return false;
            }
            pGetControl(param) {
                let ctrl = null;
                for (let _i = 0; _i < this.report.getControls().count(); _i++) {
                    ctrl = this.report.getControls().item(_i);
                    if (ctrl.getName().toUpperCase() === param.toUpperCase()) {
                        return ctrl;
                    }
                }
                return null;
            }
            pGetSubName(code) {
                let pos = 0;
                let i = 0;
                let c = "";
                pos = code.indexOf(" ", 0) + 1;
                i = pos;
                while (i < code.length) {
                    c = code.substring(i, 1);
                    if (this.pIsSeparator(c)) {
                        break;
                    }
                    i++;
                }
                debugger;
                return code.substring(pos, i - pos);
            }
            pGetParameter(parameters, paramIndex, funName) {
                let param = "";
                let vParam = null;
                vParam = parameters.split('|');
                if (paramIndex > vParam.length + 1) {
                    throw new CSReportEngine.ReportArgumentMissingException(CSReportEngine.cReportError.errGetDescription(csRptErrors.CS_RPT_ERR_MISSING_PARAM, [paramIndex.toString(), funName]));
                }
                else {
                    param = vParam[paramIndex];
                }
                return param.replaceAll(")", "").trim();
            }
            pCheckInternalFunction(functionName, code) {
                let name = functionName;
                let parameters = code.trim();
                if (parameters.length > 2) {
                    parameters = parameters.substring(1, parameters.length - 1);
                }
                let tc = this.formula.getTextC();
                let r = tc.toLowerCase().indexOf(name.toLowerCase(), 0);
                let q = tc.toLowerCase().indexOf(")", r) + 1;
                this.formula.setTextC((tc.substring(0, r)).toString()
                    + cReportCompiler.KEY_FUNC_INT
                    + ReportGlobals.format(this.formula.getFormulasInt().count(), "000")
                    + tc.substring(q));
                let idFunction = this.pGetIdFunction(name);
                this.fint.setFormulaType(idFunction);
                switch (idFunction) {
                    case csRptFormulaType.CSRPTF_PAGE_NUMBER:
                        if (this.report === null) {
                            return 0;
                        }
                        else {
                            return this.report.getCurrenPage();
                        }
                    case csRptFormulaType.CSRPTF_TEXT_REPLACE:
                        return "";
                    case csRptFormulaType.CSRPTF_TOTAL_PAGES:
                        return this.report.getTotalPages();
                    case csRptFormulaType.CSRPTF_AVERAGE:
                    case csRptFormulaType.CSRPTF_SUM:
                    case csRptFormulaType.CSRPTF_MAX:
                    case csRptFormulaType.CSRPTF_MIN:
                    case csRptFormulaType.CSRPTF_LENGTH:
                    case csRptFormulaType.CSRPTF_VAL:
                        this.pCheckParameters(1, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_GROUP_TOTAL:
                    case csRptFormulaType.CSRPTF_GROUP_MAX:
                    case csRptFormulaType.CSRPTF_GROUP_MIN:
                    case csRptFormulaType.CSRPTF_GROUP_AVERAGE:
                        this.pCheckParameters(2, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_GROUP_COUNT:
                    case csRptFormulaType.CSRPTF_GROUP_PERCENT:
                        this.pCheckParameters(3, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_GET_STRING:
                        this.pCheckParameters(1, parameters, name);
                        return "\"\"";
                    case csRptFormulaType.CSRPTF_SUM_TIME:
                        this.pCheckParameters(2, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_COUNT:
                        return 0;
                    case csRptFormulaType.CSRPTF_NUMBER_TO_STRING:
                        this.pCheckParameters(2, parameters, name);
                        return "\"\"";
                    case csRptFormulaType.CSRPTF_IS_EQUAL:
                    case csRptFormulaType.CSRPTF_IS_NOT_EQUAL:
                    case csRptFormulaType.CSRPTF_IS_GREATER_THAN:
                    case csRptFormulaType.CSRPTF_IS_LESS_THAN:
                    case csRptFormulaType.CSRPTF_IS_IN_RS:
                        this.pCheckParameters(2, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_CALCULATE:
                    case csRptFormulaType.CSRPTF_GET_DATA_FROM_RS_AD:
                    case csRptFormulaType.CSRPTF_GET_DATA_FROM_RS:
                        this.pCheckParameters(4, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_DECLARE_VAR:
                    case csRptFormulaType.CSRPTF_GET_VAR:
                        this.pCheckParameters(1, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_GET_PARAM:
                        this.pCheckParameters(1, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_ADD_TO_VAR:
                    case csRptFormulaType.CSRPTF_SET_VAR:
                        this.pCheckParameters(2, parameters, name);
                        return 0;
                    case csRptFormulaType.CSRPTF_GET_BARCODE:
                        this.pCheckParameters(1, parameters, name);
                        return "\"\"";
                    default:
                        throw new CSReportEngine.ReportNotDefinedFunctionException(csRptErrors.CS_RPT_ERR_UNDEFINED_FUNCTION, CSReportEngine.cReportError.errGetDescription(csRptErrors.CS_RPT_ERR_UNDEFINED_FUNCTION, [name]));
                }
            }
            resultGetString(fint) {
                let param = "";
                param = fint.getParameters().item(0).getValue();
                if (param === "\"\"") {
                    return param;
                }
                else {
                    if (this.pIsControl(param)) {
                        return "\"" + this.report.getValueString(param).replaceAll("\"", "\"\"") + "\"";
                    }
                    else {
                        return "\"" + param.replaceAll("\"", "\"\"") + "\"";
                    }
                }
            }
            resultSumTime(fint) {
                if (fint.getVariables().count() === 0) {
                    return "";
                }
                let st = fint.getVariables().item(cReportCompiler.SUM_TIME).getValue();
                if (U.val(fint.getParameters().item(1).getValue()) !== 0) {
                    return ReportGlobals.format(st.getHour(), "00")
                        + ":" + ReportGlobals.format(st.getMinute(), "00")
                        + ":" + ReportGlobals.format(st.getSecond(), "00");
                }
                else {
                    return ReportGlobals.format(st.getHour(), "00")
                        + ":" + ReportGlobals.format(st.getMinute(), "00");
                }
            }
            resultSum(fint) {
                if (fint.getVariables().count() === 0) {
                    return 0;
                }
                return parseFloat(fint.getVariables().item(cReportCompiler.SUM).getValue());
            }
            resultGetDataFromRsAd(fint) {
                return null;
            }
            resultGetDataFromRs(fint) {
                return null;
            }
            resultGetVar(fint) {
                let varName = "";
                varName = fint.getParameters().item(0).getValue();
                if (this.variables.item(varName) === null) {
                    throw new CSReportEngine.ReportArgumentMissingException(CSReportEngine.cReportError.errGetDescription(csRptErrors.CS_RPT_ERR_MISSING_PARAM, [varName, "_getVar()"]));
                }
                return this.variables.item(varName).getValue();
            }
            resultGetParam(fint) {
                let param = null;
                let paramName = "";
                paramName = fint.getParameters().item(0).getValue();
                for (let _i = 0; _i < this.report.getConnect().getParameters().count(); _i++) {
                    param = this.report.getConnect().getParameters().item(_i);
                    if (param.getName().toLowerCase() === paramName.toLowerCase()) {
                        break;
                    }
                }
                if (param === null) {
                    throw new CSReportEngine.ReportArgumentMissingException(CSReportEngine.cReportError.errGetDescription(csRptErrors.CS_RPT_ERR_MISSING_PARAM, [paramName, "_getParameter()"]));
                }
                return param.getValue();
            }
            resultMax(fint) {
                if (fint.getVariables().count() === 0) {
                    return 0;
                }
                return fint.getVariables().item(cReportCompiler.MAX).getValue();
            }
            resultMin(fint) {
                if (fint.getVariables().count() === 0) {
                    return 0;
                }
                return fint.getVariables().item(cReportCompiler.MIN).getValue();
            }
            resultCount(fint) {
                if (fint.getVariables().count() === 0) {
                    return null;
                }
                return fint.getVariables().item(cReportCompiler.COUNT).getValue();
            }
            resultNumberToString(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.NUMBER_TO_STRING).getValue();
                }
                else {
                    return "";
                }
            }
            resultGetBarcode(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GET_BARCODE).getValue();
                }
                else {
                    return "";
                }
            }
            resultIsEqual(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.IS_EQUAL).getValue();
                }
                else {
                    return 0;
                }
            }
            resultIsNotEqual(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.IS_NOT_EQUAL).getValue();
                }
                else {
                    return 0;
                }
            }
            resultIsGreaterThan(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.IS_GREATER_THAN).getValue();
                }
                else {
                    return 0;
                }
            }
            resultIsLessThan(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.IS_LESS_THAN).getValue();
                }
                else {
                    return 0;
                }
            }
            resultAverage(fint) {
                if (fint.getVariables().count() === 0) {
                    return 0;
                }
                let sum = fint.getVariables().item(cReportCompiler.AVERAGE_SUM).getValue();
                let count = fint.getVariables().item(cReportCompiler.AVERAGE_COUNT).getValue();
                return sum / count;
            }
            resultCalculate(fint) {
                let control = fint.getParameters().item(1).getValue();
                let value1 = parseFloat(this.report.getValue(fint.getParameters().item(0).getValue(), true).toString());
                let value2;
                if (control !== "\"\"") {
                    value2 = parseFloat(this.report.getValue(control, true).toString());
                }
                else {
                    value2 = parseFloat(fint.getParameters().item(2).getValue());
                }
                let operation = U.parseInt(fint.getParameters().item(3).getValue());
                switch (operation) {
                    case 1:
                        return value1 + value2;
                    case 2:
                        return value1 - value2;
                    case 3:
                        return value1 * value2;
                    case 4:
                        return U.divideByZero(value1, value2);
                    case 5:
                        return Math.pow(value1, value2);
                    default:
                        return 0;
                }
            }
            resultLength(fint) {
                return this.report.getValueString(fint.getParameters().item(0).getValue()).length;
            }
            resultTextReplace(fint) {
                let text = "";
                let collCtrlsToReplace;
                let ctrl = this.pGetControl(this.ctrlName);
                if (ctrl === null) {
                    return "";
                }
                text = ctrl.getLabel().getText();
                try {
                    collCtrlsToReplace = this.collTextReplace[this.ctrlName];
                }
                catch (ignore) {
                    let lenText = 0;
                    let pos = 0;
                    let endPos = 0;
                    collCtrlsToReplace = [];
                    lenText = text.length;
                    let i = 0;
                    while (i < lenText) {
                        pos = text.indexOf(cReportCompiler.MACRO_CTRL, i + 1);
                        if (pos > 0) {
                            endPos = text.indexOf(cReportCompiler.MACRO_CTRL, pos + 1);
                            if (endPos > 0) {
                                debugger;
                                collCtrlsToReplace.push(text.substring(pos + 2, endPos - pos - 2));
                            }
                            i = endPos + 1;
                        }
                        else {
                            i = lenText + 1;
                        }
                    }
                    this.collTextReplace.add(this.ctrlName, collCtrlsToReplace);
                }
                let ctrlValue = null;
                for (let i = 0; i < collCtrlsToReplace.Count; i++) {
                    ctrlValue = this.pGetControl(collCtrlsToReplace[i]);
                    if (ctrlValue !== null) {
                        text = text.replaceAll(cReportCompiler.MACRO_CTRL + collCtrlsToReplace[i] + cReportCompiler.MACRO_CTRL, this.report.getValue(ctrlValue.getName(), false).toString());
                    }
                }
                return text;
            }
            resultValue(fint) {
                return this.report.getValue(fint.getParameters().item(0).getValue(), true);
            }
            resultPageNumber() {
                return this.report.getCurrenPage();
            }
            resultTotalPages() {
                return this.report.getTotalPages();
            }
            resultGroupTotal(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GROUP_TOTAL).getValue();
                }
                else {
                    return 0;
                }
            }
            resultGroupMax(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GROUP_MAX).getValue();
                }
                else {
                    return 0;
                }
            }
            resultGroupMin(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GROUP_MIN).getValue();
                }
                else {
                    return 0;
                }
            }
            resultGroupAverage(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GROUP_AVERAGE).getValue();
                }
                else {
                    return 0;
                }
            }
            resultGroupPercent(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GROUP_PERCENT).getValue();
                }
                else {
                    return 0;
                }
            }
            resultGroupCount(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GROUP_COUNT).getValue();
                }
                else {
                    return 0;
                }
            }
            resultGroupLineNumber(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.GROUP_LINE_NUMBER).getValue();
                }
                else {
                    return 0;
                }
            }
            resultIsInRs(fint) {
                if (fint.getVariables().count() > 0) {
                    return fint.getVariables().item(cReportCompiler.IS_IN_RS).getValue();
                }
                else {
                    return 0;
                }
            }
            evalAverage(fint) {
                if (fint.getVariables().item(cReportCompiler.AVERAGE_SUM) === null) {
                    fint.getVariables().add(null, cReportCompiler.AVERAGE_SUM);
                    fint.getVariables().add(null, cReportCompiler.AVERAGE_COUNT);
                }
                let item = fint.getVariables().item(cReportCompiler.AVERAGE_SUM);
                item.setValue(item.getValue()
                    + this.pGetNumber(this.report.getValue(fint.getParameters().item(0).getValue(), true)));
                item = fint.getVariables().item(cReportCompiler.AVERAGE_COUNT);
                item.setValue(item.getValue() + 1);
            }
            pGetNumber(number) {
                let strNumber = number.toString();
                let rtn = 0;
                let sepDecimal = "";
                if (U.isNumber(strNumber)) {
                    sepDecimal = U.getSepDecimal();
                    if (sepDecimal !== ".") {
                        strNumber = strNumber.replaceAll(".", sepDecimal);
                    }
                    rtn = U.val(strNumber);
                }
                return rtn;
            }
            evalSum(fint) {
                if (fint.getVariables().item(cReportCompiler.SUM) === null) {
                    fint.getVariables().add(null, cReportCompiler.SUM).setValue(0);
                }
                let item = fint.getVariables().item(cReportCompiler.SUM);
                item.setValue(parseFloat(item.getValue())
                    + this.pGetNumber(this.report.getValue(fint.getParameters().item(0).getValue(), true)));
            }
            evalDeclareVar(fint) {
                let varName = "";
                varName = fint.getParameters().item(0).getValue();
                if (this.variables.item(varName) === null) {
                    this.variables.add(null, varName);
                }
            }
            evalSetVar(fint) {
                let varName = fint.getParameters().item(0).getValue();
                if (this.variables.item(varName) === null) {
                    throw new CSReportEngine.ReportArgumentMissingException(CSReportEngine.cReportError.errGetDescription(csRptErrors.CS_RPT_ERR_MISSING_PARAM, [varName, "_setVar"]));
                }
                let item = this.variables.item(varName);
                item.setValue(fint.getParameters().item(1).getValue());
            }
            evalGetDataFromRsAd(fint) {
            }
            evalGetDataFromRs(fint) {
            }
            evalAddToVar(fint) {
                let varName = fint.getParameters().item(0).getValue();
                if (this.variables.item(varName) === null) {
                    throw new CSReportEngine.ReportArgumentMissingException(CSReportEngine.cReportError.errGetDescription(csRptErrors.CS_RPT_ERR_MISSING_PARAM, [varName, "_evalAddToVar"]));
                }
                let item = this.variables.item(varName);
                item.setValue(item.getValue()
                    + this.pGetNumber(fint.getParameters().item(1).getValue()));
            }
            evalSumTime(fint) {
                if (fint.getVariables().item(cReportCompiler.SUM_TIME) === null) {
                    fint.getVariables().add(null, cReportCompiler.SUM_TIME).setValue(new CSReportEngine.cStructTime());
                }
                let item = fint.getVariables().item(cReportCompiler.SUM_TIME);
                this.pSumTimes(item.getValue(), new Date(Date.parse(this.report.getValue(fint.getParameters().item(0).getValue(), true).toString())));
            }
            evalMax(fint) {
                if (fint.getVariables().item(cReportCompiler.MAX) === null) {
                    fint.getVariables().add(null, cReportCompiler.MAX);
                }
                let item = fint.getVariables().item(cReportCompiler.MAX);
                let value = this.report.getValue(fint.getParameters().item(0).getValue());
                if (typeof value === "string") {
                    if (item.getValue().toString().localeCompare(value.toString()) < 0) {
                        item.setValue(value);
                    }
                }
                else {
                    if (item.getValue() < value) {
                        item.setValue(value);
                    }
                }
            }
            evalMin(fint) {
                if (fint.getVariables().item(cReportCompiler.MIN) === null) {
                    fint.getVariables().add(null, cReportCompiler.MIN);
                }
                let item = fint.getVariables().item(cReportCompiler.MIN);
                let value = this.report.getValue(fint.getParameters().item(0).getValue());
                if (typeof value === "string") {
                    if (item.getValue().toString().localeCompare(value.toString()) > 0) {
                        item.setValue(value);
                    }
                }
                else {
                    if (item.getValue() > value) {
                        item.setValue(value);
                    }
                }
            }
            evalCount(fint) {
                if (fint.getVariables().item(cReportCompiler.COUNT) === null) {
                    fint.getVariables().add(null, cReportCompiler.COUNT);
                }
                let item = fint.getVariables().item(cReportCompiler.COUNT);
                item.setValue(item.getValue() + 1);
            }
            evalNumberToString(fint) {
                if (fint.getVariables().item(cReportCompiler.NUMBER_TO_STRING) === null) {
                    fint.getVariables().add(null, cReportCompiler.NUMBER_TO_STRING);
                }
                let item = fint.getVariables().item(cReportCompiler.NUMBER_TO_STRING);
                let iNumber = this.pGetNumber(this.report.getValue(fint.getParameters().item(0).getValue(), true));
                let iLanguage = U.valInt(fint.getParameters().item(1).getValue());
                switch (iLanguage) {
                    case cReportCompiler.SPANISH:
                        item.setValue(cNumberToString.spanishNumberToString(iNumber));
                        break;
                    case cReportCompiler.ENGLISH:
                        item.setValue(cNumberToString.englishNumberToString(iNumber));
                        break;
                    case cReportCompiler.FRENCH:
                        item.setValue(cNumberToString.frenchNumberToString(iNumber));
                        break;
                }
            }
            evalIsEqual(fint) {
                if (fint.getVariables().item(cReportCompiler.IS_EQUAL) === null) {
                    fint.getVariables().add(null, cReportCompiler.IS_EQUAL);
                }
                let item = fint.getVariables().item(cReportCompiler.IS_EQUAL);
                let strValue = this.report.getValue(fint.getParameters().item(0).getValue(), true).toString();
                let strConstValue = fint.getParameters().item(1).getValue();
                item.setValue(strValue === strConstValue);
            }
            evalIsNotEqual(fint) {
                if (fint.getVariables().item(cReportCompiler.IS_NOT_EQUAL) === null) {
                    fint.getVariables().add(null, cReportCompiler.IS_NOT_EQUAL);
                }
                let item = fint.getVariables().item(cReportCompiler.IS_NOT_EQUAL);
                let strValue = this.report.getValue(fint.getParameters().item(0).getValue(), true);
                let strConstValue = fint.getParameters().item(1).getValue();
                item.setValue(strValue !== strConstValue);
            }
            evalIsGreaterThan(fint) {
                if (fint.getVariables().item(cReportCompiler.IS_GREATER_THAN) === null) {
                    fint.getVariables().add(null, cReportCompiler.IS_GREATER_THAN);
                }
                let item = fint.getVariables().item(cReportCompiler.IS_GREATER_THAN);
                let value = this.report.getValue(fint.getParameters().item(0).getValue(), true);
                let constValue = fint.getParameters().item(1).getValue();
                if (typeof value === "string") {
                    let strValue = value.toString();
                    let strConstValue = constValue.toString();
                    if (strValue.toString().localeCompare(strConstValue.toString()) > 0) {
                        item.setValue(true);
                    }
                    else {
                        item.setValue(false);
                    }
                }
                else {
                    if (value.toString() > constValue) {
                        item.setValue(true);
                    }
                    else {
                        item.setValue(false);
                    }
                }
            }
            evalIsLessThan(fint) {
                if (fint.getVariables().item(cReportCompiler.IS_LESS_THAN) === null) {
                    fint.getVariables().add(null, cReportCompiler.IS_LESS_THAN);
                }
                let item = fint.getVariables().item(cReportCompiler.IS_LESS_THAN);
                let value = this.report.getValue(fint.getParameters().item(0).getValue(), true);
                let constValue = fint.getParameters().item(1).getValue();
                if (typeof value === "string") {
                    let strValue = value.toString();
                    let strConstValue = constValue.toString();
                    if (strValue.toString().localeCompare(strConstValue.toString()) < 0) {
                        item.setValue(true);
                    }
                    else {
                        item.setValue(false);
                    }
                }
                else {
                    if (value.toString() < constValue) {
                        item.setValue(true);
                    }
                    else {
                        item.setValue(false);
                    }
                }
            }
            evalGroupTotal(fint) {
                if (fint.getVariables().item(cReportCompiler.GROUP_TOTAL) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_TOTAL);
                }
                let item = fint.getVariables().item(cReportCompiler.GROUP_TOTAL);
                if (fint.getParameters().item(ReportGlobals.KEY_INDEX_COL) === null) {
                    item.setValue(0);
                }
                else {
                    item.setValue(this.report.getGroupTotal(U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_COL).getValue()), U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).getValue())));
                }
            }
            evalGroupMax(fint) {
                if (fint.getVariables().item(cReportCompiler.GROUP_MAX) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_MAX);
                }
                let item = fint.getVariables().item(cReportCompiler.GROUP_MAX);
                if (fint.getParameters().item(ReportGlobals.KEY_INDEX_COL) === null) {
                    item.setValue(0);
                }
                else {
                    item.setValue(this.report.getGroupMax(U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_COL).getValue()), U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).getValue())));
                }
            }
            evalGroupMin(fint) {
                if (fint.getVariables().item(cReportCompiler.GROUP_MIN) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_MIN);
                }
                let item = fint.getVariables().item(cReportCompiler.GROUP_MIN);
                if (fint.getParameters().item(ReportGlobals.KEY_INDEX_COL) === null) {
                    item.setValue(0);
                }
                else {
                    item.setValue(this.report.getGroupMin(U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_COL).getValue()), U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).getValue())));
                }
            }
            evalGroupAverage(fint) {
                if (fint.getVariables().item(cReportCompiler.GROUP_AVERAGE) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_AVERAGE);
                }
                let item = fint.getVariables().item(cReportCompiler.GROUP_AVERAGE);
                if (fint.getParameters().item(ReportGlobals.KEY_INDEX_COL) === null) {
                    item.setValue(0);
                }
                else {
                    item.setValue(this.report.getGroupAverage(U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_COL).getValue()), U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).getValue())));
                }
            }
            evalGroupPercent(fint) {
                if (fint.getVariables().item(cReportCompiler.GROUP_PERCENT_T) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_PERCENT_T);
                }
                if (fint.getVariables().item(cReportCompiler.GROUP_PERCENT) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_PERCENT);
                }
                let item = fint.getVariables().item(cReportCompiler.GROUP_PERCENT_T);
                if (fint.getParameters().item(ReportGlobals.KEY_INDEX_COL) === null) {
                    item.setValue(0);
                }
                else {
                    item.setValue(this.report.getGroupTotal(U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_COL).getValue()), U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).getValue())));
                }
                this.pEvalFunctionGroup(fint);
            }
            evalGroupCount(fint) {
                if (fint.getVariables().item(cReportCompiler.GROUP_COUNT) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_COUNT);
                }
                let item = fint.getVariables().item(cReportCompiler.GROUP_COUNT);
                if (fint.getParameters().item(ReportGlobals.KEY_INDEX_COL) === null) {
                    item.setValue(0);
                }
                else {
                    item.setValue(this.report.getGroupCount(U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_COL).getValue()), U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).getValue())));
                }
            }
            evalGroupLineNumber(fint) {
                if (fint.getVariables().item(cReportCompiler.GROUP_LINE_NUMBER) === null) {
                    fint.getVariables().add(null, cReportCompiler.GROUP_LINE_NUMBER);
                }
                let item = fint.getVariables().item(cReportCompiler.GROUP_LINE_NUMBER);
                item.setValue(this.report.getGroupLineNumber(U.parseInt(fint.getParameters().item(ReportGlobals.KEY_INDEX_GROUP).getValue())));
            }
            evalIsInRs(fint) {
                if (fint.getVariables().item(cReportCompiler.IS_IN_RS) === null) {
                    fint.getVariables().add(null, cReportCompiler.IS_IN_RS);
                }
                let item = fint.getVariables().item(cReportCompiler.IS_IN_RS);
                item.setValue(true);
            }
            evalGetBarcode(fint) {
                if (fint.getVariables().item(cReportCompiler.GET_BARCODE) === null) {
                    fint.getVariables().add(null, cReportCompiler.GET_BARCODE);
                }
                let item = fint.getVariables().item(cReportCompiler.GET_BARCODE);
                let barcodeGen = new CSReports.CSReportBarcode.cReportBarcode();
                let value = fint.getParameters().item(0).getValue();
                let barcode = barcodeGen.encodeTo128(value);
                if (barcode.contains(""))
                    barcode = barcodeGen.code128a(value);
                item.setValue(barcode);
            }
            pCheckParameters(cantParams, parameters, name) {
                for (let i = 0; i < cantParams; i++) {
                    let param = this.pGetParameter(parameters, i, name);
                    if (param.length === 0) {
                        throw new CSReportEngine.ReportArgumentMissingException(CSReportEngine.cReportError.errGetDescription(csRptErrors.CS_RPT_ERR_MISSING_PARAM, [i.toString(), name]));
                    }
                    this.fint.getParameters().add2(param);
                }
            }
            pGetIdFunction(name) {
                let f = null;
                name = name.toLowerCase();
                for (let _i = 0; _i < this.formulaTypes.count(); _i++) {
                    f = this.formulaTypes.item(_i);
                    if (name === f.getName().toLowerCase()) {
                        return f.getId();
                    }
                }
                return 0;
            }
            pIsSeparator(c) {
                return " |:+()/-*=\r\n".indexOf(c, 0) > -1 && c !== "";
            }
            removeReturns(code) {
                let c = "";
                for (let i = 0; i < code.length; i++) {
                    c = code.charAt(i);
                    if (c !== " " && c !== "\r" && c !== "\n") {
                        code = code.substring(i);
                        break;
                    }
                }
                return code;
            }
            pSumTimes(st, date2) {
                let s2 = date2.getSeconds();
                let n2 = date2.getMinutes();
                let h2 = date2.getHours();
                let s = (st.getSecond() + s2) % 60;
                let n = ((st.getSecond() + s2) / 60);
                n = n + (st.getMinute() + n2) % 60;
                let h = ((st.getMinute() + n2) / 60);
                h = h + st.getHour() + h2;
                st.setSecond(s);
                st.setMinute(n);
                st.setHour(h);
            }
            pCompileAux(code, codeC) {
                let codeCallFunction = "";
                let codeCallFunctionC = new RefWrapper("");
                let functionName = "";
                let word = "";
                let start = new RefWrapper(0);
                let nLenCode = code.length;
                codeC.set("");
                do {
                    word = this.pGetWord(code, start);
                    let refFunctionName = new RefWrapper(functionName);
                    if (this.pIsFunctionAux(word, refFunctionName)) {
                        functionName = refFunctionName.get();
                        codeCallFunction = this.pGetCallFunction(code, start);
                        if (!this.pCompileAux(codeCallFunction, codeCallFunctionC)) {
                            return false;
                        }
                        codeC.set(codeC.get() + this.pExecFunction(functionName, codeCallFunctionC.get()));
                    }
                    else {
                        codeC.set(codeC.get() + word);
                    }
                } while (start.get() < nLenCode);
                return true;
            }
            pGetWord(code, start) {
                let nLenCode = code.length;
                let n = start.get();
                let c = code.charAt(n);
                let word = "";
                do {
                    word += c;
                    n += 1;
                    if (this.pIsSeparator(c))
                        break;
                    c = code.charAt(n);
                } while (!this.pIsSeparator(c) && n < nLenCode);
                start.set(n);
                return word;
            }
            pIsFunctionAux(word, functionName) {
                if (!this.pIsFunction(word)) {
                    return false;
                }
                functionName.set(word);
                return true;
            }
            pGetCallFunction(code, start) {
                let c;
                let word = "";
                let n = start.get();
                let nLenCode = code.length;
                let nInner = new RefWrapper(-1);
                do {
                    c = code.charAt(n);
                    word = word + c;
                    n = n + 1;
                } while (!this.pIsEndCallFunction(c, nInner) && n < nLenCode);
                start.set(n);
                return word;
            }
            pIsEndCallFunction(c, nInner) {
                let rslt = false;
                if (c === ")") {
                    if (nInner.get() === 0) {
                        rslt = true;
                    }
                    else {
                        nInner.set(nInner.get() - 1);
                    }
                }
                else if (c === "(") {
                    nInner.set(nInner.get() + 1);
                }
                return rslt;
            }
            pExecFunction(functionName, parameters) {
                if (this.bCompile) {
                    return this.pAddFormulaInt(functionName, parameters).toString();
                }
                else {
                    this.idxFormula = this.idxFormula + 1;
                    let fint = this.formula.getFormulasInt().item(this.idxFormula);
                    this.pSetParams(fint, parameters);
                    this.pEvalFunctionInt(fint);
                    let value = this.pResultFunctionInt(fint);
                    if (value !== null) {
                        return this.getNumericVal(value.toString());
                    }
                    else {
                        return "";
                    }
                }
            }
            pSetParams(fint, parameters) {
                let vParams = null;
                let i = 0;
                parameters = parameters.trim();
                if (parameters.length > 2) {
                    parameters = parameters.substring(1, parameters.length - 1);
                    parameters = parameters.trim();
                    vParams = parameters.split('|');
                    for (i = 0; i < vParams.length; i++) {
                        fint.getParameters().item(i).setValue(vParams[i].trim());
                    }
                }
            }
            getNumericVal(value) {
                let decimalDigit = 0;
                decimalDigit = value.indexOf(",", 0);
                if (decimalDigit > 0) {
                    value = value.replaceAll(",", ".");
                }
                return value;
            }
        }
        cReportCompiler.TEMP_FUNCTION_B = "Option explicit";
        cReportCompiler.TEMP_FUNCTION_E = "\r\n";
        cReportCompiler.MACRO_CTRL = "@@";
        cReportCompiler.AVERAGE_SUM = "AverageSum";
        cReportCompiler.AVERAGE_COUNT = "AverageCount";
        cReportCompiler.SUM = "Sum";
        cReportCompiler.SUM_TIME = "SumTime";
        cReportCompiler.MAX = "Max";
        cReportCompiler.MIN = "Min";
        cReportCompiler.COUNT = "Count";
        cReportCompiler.NUMBER_TO_STRING = "NumberToString";
        cReportCompiler.GET_BARCODE = "GetBarcode";
        cReportCompiler.GET_DATA_FROM_RS_AD = "GetDataFromRsAd";
        cReportCompiler.IS_EQUAL = "IsEqual";
        cReportCompiler.IS_NOT_EQUAL = "IsNotEqual";
        cReportCompiler.IS_GREATER_THAN = "IsGreaterThan";
        cReportCompiler.IS_LESS_THAN = "IsLessThan";
        cReportCompiler.GET_DATA_FROM_RS = "GetDataFromRs";
        cReportCompiler.GROUP_TOTAL = "GroupTotal";
        cReportCompiler.GROUP_MIN = "GroupMin";
        cReportCompiler.GROUP_MAX = "GroupMax";
        cReportCompiler.GROUP_AVERAGE = "GroupAverage";
        cReportCompiler.GROUP_PERCENT = "GroupPercent";
        cReportCompiler.GROUP_PERCENT_T = "GroupPercentT";
        cReportCompiler.GROUP_COUNT = "GroupCount";
        cReportCompiler.GROUP_LINE_NUMBER = "GroupLineNumber";
        cReportCompiler.IS_IN_RS = "IsInRs";
        cReportCompiler.SPANISH = 1;
        cReportCompiler.ENGLISH = 2;
        cReportCompiler.FRENCH = 3;
        cReportCompiler.KEY_FUNC_INT = "$$$";
        CSReportEngine.cReportCompiler = cReportCompiler;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportConnectsAux extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportConnect);
            }
            save(xDoc, nodeFather) {
                let connect = null;
                if (nodeFather === null) {
                    let xProperty = new CSReports.CSXml.cXmlProperty();
                    xProperty.setName(cReportConnectsAux.RPT_CONNECTS_AUX);
                    nodeFather = xDoc.addNode(xProperty);
                }
                for (let _i = 0; _i < this.count(); _i++) {
                    connect = this.item(_i);
                    connect.save(xDoc, nodeFather);
                }
            }
            copy(from) {
                for (let i = 0; i < from.values.length; i++) {
                    if (!this.add(null).copy(from.values[i])) {
                        return false;
                    }
                }
                return true;
            }
            load(xDoc, nodeFather) {
                let nodeObj = null;
                this.clear();
                if (nodeFather !== null) {
                    if (xDoc.nodeHasChild(nodeFather)) {
                        nodeObj = xDoc.getNodeChild(nodeFather);
                        while (nodeObj !== null) {
                            if (!this.add(null).load(xDoc, nodeObj)) {
                                return false;
                            }
                            nodeObj = xDoc.getNextNode(nodeObj);
                        }
                    }
                }
                return true;
            }
        }
        cReportConnectsAux.RPT_CONNECTS_AUX = "RptConnectsAux";
        CSReportEngine.cReportConnectsAux = cReportConnectsAux;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportControl {
            constructor() {
                this.label = new CSReportEngine.cReportLabel();
                this.image = new CSReportEngine.cReportImage();
                this.line = new CSReportEngine.cReportLine();
                this.field = new CSReportEngine.cReportField();
                this.typeSection = null;
                this.key = "";
                this.keyPaint = "";
                this.name = "";
                this.hasFormulaHide = false;
                this.hasFormulaValue = false;
                this.controlType = null;
                this.formulaHide = new CSReportEngine.cReportFormula();
                this.formulaValue = new CSReportEngine.cReportFormula();
                this.chart = new CSReportEngine.cReportChart();
                this.tag = "";
                this.exportColIdx = 0;
                this.isFreeCtrl = false;
                this.sectionLine = null;
                this.formulaHide.setName("H");
                this.formulaValue.setName("V");
            }
            getLabel() {
                return this.label;
            }
            setLabel(rhs) {
                this.label = rhs;
            }
            getImage() {
                return this.image;
            }
            setImage(rhs) {
                this.image = rhs;
            }
            getFormulaHide() {
                return this.formulaHide;
            }
            getFormulaValue() {
                return this.formulaValue;
            }
            getHasFormulaValue() {
                return this.hasFormulaValue;
            }
            setHasFormulaValue(rhs) {
                this.hasFormulaValue = rhs;
            }
            getLine() {
                return this.line;
            }
            setLine(rhs) {
                this.line = rhs;
            }
            getField() {
                return this.field;
            }
            setField(rhs) {
                this.field = rhs;
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            getKeyPaint() {
                return this.keyPaint;
            }
            setKeyPaint(rhs) {
                this.keyPaint = rhs;
            }
            getChart() {
                return this.chart;
            }
            getTag() {
                return this.tag;
            }
            setTag(rhs) {
                this.tag = rhs;
            }
            getTypeSection() {
                return this.typeSection;
            }
            setTypeSection(rhs) {
                this.typeSection = rhs;
            }
            getSectionLine() {
                return this.sectionLine;
            }
            setSectionLine(rhs) {
                this.sectionLine = rhs;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getHasFormulaHide() {
                return this.hasFormulaHide;
            }
            setHasFormulaHide(rhs) {
                this.hasFormulaHide = rhs;
            }
            getControlType() {
                return this.controlType;
            }
            setControlType(rhs) {
                this.controlType = rhs;
            }
            setExportColIdx(rhs) {
                this.exportColIdx = rhs;
            }
            getExportColIdx() {
                return this.exportColIdx;
            }
            setIsFreeCtrl(rhs) {
                this.isFreeCtrl = rhs;
            }
            getIsFreeCtrl() {
                return this.isFreeCtrl;
            }
            copy(from) {
                this.keyPaint = from.keyPaint;
                this.name = from.name;
                this.hasFormulaHide = from.hasFormulaHide;
                this.hasFormulaValue = from.hasFormulaValue;
                this.controlType = from.controlType;
                this.tag = from.tag;
                this.exportColIdx = from.exportColIdx;
                this.isFreeCtrl = from.isFreeCtrl;
                try {
                    if (!this.field.copy(from.field)) {
                        return false;
                    }
                    if (!this.image.copy(from.image)) {
                        return false;
                    }
                    if (!this.label.copy(from.label)) {
                        return false;
                    }
                    if (!this.line.copy(from.line)) {
                        return false;
                    }
                    if (!this.formulaHide.copy(from.formulaHide)) {
                        return false;
                    }
                    if (!this.formulaValue.copy(from.formulaValue)) {
                        return false;
                    }
                    if (!this.chart.copy(from.chart)) {
                        return false;
                    }
                    if (this.label.getAspect().getFormat() === ""
                        && this.field.getFieldType() === CSReports.CSDatabase.csAdoDataType.adDBTimeStamp) {
                        this.label.getAspect().setFormat("dd/MM/yyyy");
                    }
                    return true;
                }
                catch (ignore) {
                    return false;
                }
            }
            load(xDoc, nodeObj) {
                this.keyPaint = xDoc.getNodeProperty(nodeObj, "KeyPaint").getValueString(eTypes.eText);
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                try {
                    this.hasFormulaHide = xDoc.getNodeProperty(nodeObj, "HasFormulaHide").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                try {
                    this.hasFormulaValue = xDoc.getNodeProperty(nodeObj, "HasFormulaValue").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                try {
                    this.controlType = xDoc.getNodeProperty(nodeObj, "ControlType").getValueInt(eTypes.eInteger);
                }
                catch (ex) { }
                try {
                    this.tag = xDoc.getNodeProperty(nodeObj, "Tag").getValueString(eTypes.eText);
                }
                catch (ex) { }
                try {
                    this.exportColIdx = xDoc.getNodeProperty(nodeObj, "ExportColIdx").getValueInt(eTypes.eLong);
                }
                catch (ex) { }
                try {
                    this.isFreeCtrl = xDoc.getNodeProperty(nodeObj, "IsFreeCtrl").getValueBool(eTypes.eBoolean);
                }
                catch (ex) { }
                try {
                    if (!this.field.load(xDoc, nodeObj)) {
                        return false;
                    }
                    if (!this.image.load(xDoc, nodeObj)) {
                        return false;
                    }
                    if (!this.label.load(xDoc, nodeObj)) {
                        return false;
                    }
                    if (!this.line.load(xDoc, nodeObj)) {
                        return false;
                    }
                    if (!this.formulaHide.load(xDoc, nodeObj)) {
                        return false;
                    }
                    if (!this.formulaValue.load(xDoc, nodeObj)) {
                        return false;
                    }
                    if (!this.chart.load(xDoc, nodeObj)) {
                        return false;
                    }
                    if (this.label.getAspect().getFormat() === "" && this.field.getFieldType() === CSReports.CSDatabase.csAdoDataType.adDBTimeStamp) {
                        this.label.getAspect().setFormat("dd/MM/yyyy");
                    }
                    return true;
                }
                catch (ignore) {
                    return false;
                }
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName(this.key);
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Key");
                xProperty.setValue(eTypes.eText, this.key);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("KeyPaint");
                xProperty.setValue(eTypes.eText, this.keyPaint);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("HasFormulaHide");
                xProperty.setValue(eTypes.eBoolean, this.hasFormulaHide);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("HasFormulaValue");
                xProperty.setValue(eTypes.eBoolean, this.hasFormulaValue);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ControlType");
                xProperty.setValue(eTypes.eInteger, this.controlType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Tag");
                xProperty.setValue(eTypes.eText, this.tag);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ExportColIdx");
                xProperty.setValue(eTypes.eLong, this.exportColIdx);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("IsFreeCtrl");
                xProperty.setValue(eTypes.eBoolean, this.isFreeCtrl);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                if (!this.field.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.image.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.label.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.line.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.formulaHide.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.formulaValue.save(xDoc, nodeObj)) {
                    return false;
                }
                if (!this.chart.save(xDoc, nodeObj)) {
                    return false;
                }
                return true;
            }
        }
        CSReportEngine.cReportControl = cReportControl;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cReportControls extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportControl);
                this.copyColl = null;
                this.typeSection = null;
                this.collByLeft = null;
                this.sectionLine = null;
            }
            getTypeSection() {
                return this.typeSection;
            }
            setTypeSection(rhs) {
                this.typeSection = rhs;
            }
            getCopyColl() {
                return this.copyColl;
            }
            setCopyColl(rhs) {
                this.copyColl = rhs;
            }
            getSectionLine() {
                return this.sectionLine;
            }
            setSectionLine(rhs) {
                this.sectionLine = rhs;
                let ctrl = null;
                for (let _i = 0; _i < this.count(); _i++) {
                    ctrl = this.item(_i);
                    ctrl.setSectionLine(rhs);
                }
            }
            getCollByLeft() {
                return this.collByLeft;
            }
            add(c, key) {
                try {
                    if (c === null || c === undefined) {
                        c = new CSReportEngine.cReportControl();
                    }
                    if (key === "" || key === null || key === undefined) {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    c.setTypeSection(this.typeSection);
                    c.setSectionLine(this.sectionLine);
                    if (this.copyColl !== null) {
                        this.copyColl.add2(c, key);
                    }
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
            clear() {
                try {
                    let n = this.count();
                    for (let i = 0; i < n; i++) {
                        this.remove(0);
                    }
                }
                catch (ignore) {
                }
            }
            remove(index) {
                try {
                    this.item(index).setSectionLine(null);
                    if (this.copyColl !== null) {
                        this.copyColl.remove(this.item(index).getKey());
                    }
                    this.baseRemove(index);
                }
                catch (ignore) {
                }
            }
            orderCollByLeft() {
                let j = 0;
                let i = 0;
                let tmp = 0;
                let ctl1 = null;
                let ctl2 = null;
                this.collByLeft = [];
                for (i = 0; i < this.count(); i++) {
                    this.collByLeft[i] = i;
                }
                for (i = 0; i < this.count() - 1; i++) {
                    for (j = i; j < this.count() - 1; j++) {
                        ctl1 = this.item(this.collByLeft[j]);
                        ctl2 = this.item(this.collByLeft[j + 1]);
                        if (ctl2.getLabel().getAspect().getLeft() < ctl1.getLabel().getAspect().getLeft()) {
                            tmp = this.collByLeft[j];
                            this.collByLeft[j] = this.collByLeft[j + 1];
                            this.collByLeft[j + 1] = tmp;
                        }
                    }
                }
            }
        }
        CSReportEngine.cReportControls = cReportControls;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cReportControls2 extends Map {
            add2(c, key) {
                try {
                    if (c === null) {
                        c = new CSReportEngine.cReportControl();
                    }
                    if (key === "") {
                        this.baseAdd(c, this.getDummyKey());
                    }
                    else {
                        this.add(c, ReportGlobals.getKey(key));
                    }
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
            getDummyKey() {
                return "dummy_key_" + this.count().toString();
            }
        }
        CSReportEngine.cReportControls2 = cReportControls2;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csRptErrors = CSReports.CSReportGlobals.csRptErrors;
        class cReportError {
            static errGetDescription(rptErrCode, x = null) {
                let s = "";
                switch (rptErrCode) {
                    case csRptErrors.LAUNCH_INFO_UNDEFINED:
                        s = "The cReport launch method must be called with an instance of oLaunchInfo class or the cReport init method must be called before calling launch.";
                        break;
                    case csRptErrors.SYNTAX_ERROR_MISSING_BRACKETS:
                        s = "Syntax error found in formula. An internal function was found in the code but the open parenthesis was missing.";
                        break;
                    case csRptErrors.CS_RPT_ERR_UNDEFINED_FUNCTION:
                        s = "the function $1 is not defined.";
                        break;
                    case csRptErrors.CS_RPT_ERR_MISSING_PARAM:
                        s = "The parameter $1 was missing in the function call to $2.";
                        break;
                    case csRptErrors.CONTROL_NOT_FOUND:
                        s = "The control $1 was not found.";
                        break;
                    case csRptErrors.GROUP_NOT_FOUND:
                        s = "The group '$1' refers to field '$2' but this is not between the columns of the recordset.";
                        break;
                    case csRptErrors.GROUP_NOT_FOUND_IN_MAIN_RS:
                        s = "The group '$1' refers to field '$2' but this is not between the columns of the main recordset.";
                        break;
                    case csRptErrors.FIELD_NOT_FOUND:
                        s = "The control '$1' refers to field '$2' but this is not between the columns of the recordset.";
                        break;
                    case csRptErrors.CS_RPT_ERR_VAR_NOT_DEFINED:
                        s = "The variable $1 was not found in the variables collection. The variables must be declared with DeclareVar before being used by SetVar or GetVar.";
                        break;
                    case csRptErrors.CS_RPT_ERR_PARAM_NOT_DEFINED:
                        s = "The parameter $1 was not found in the parameters collection. The parameters must be present in the main recordset.";
                        break;
                    case csRptErrors.PRINTER_NOT_DEFINED:
                        s = "The printer is not defined. This could happens if your system does not have any printer or default printer is not defined.";
                        break;
                    default:
                        s = "There is not a message associated to this error code.";
                        break;
                }
                for (let i = 0; i < x.length; i++) {
                    s = s.replaceAll("$" + i.toString(), x[i]);
                }
                s = s + "\n\nSection  : " + this.gDebugSection
                    + "\nSec. Line: " + cReportError.gDebugSectionLine
                    + "\nControl  : " + this.gDebugControl + "\n";
                return s;
            }
        }
        cReportError.gDebugControl = "";
        cReportError.gDebugSectionLine = 0;
        cReportError.gDebugSection = "";
        CSReportEngine.cReportError = cReportError;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportField {
            constructor() {
                this.name = "";
                this.index = 0;
                this.fieldType = 0;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getIndex() {
                return this.index;
            }
            setIndex(rhs) {
                this.index = rhs;
            }
            getFieldType() {
                return this.fieldType;
            }
            setFieldType(rhs) {
                this.fieldType = rhs;
            }
            copy(from) {
                this.index = from.index;
                this.name = from.name;
                this.fieldType = from.fieldType;
                return true;
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, "Field");
                this.index = xDoc.getNodeProperty(nodeObj, "Index").getValueInt(eTypes.eInteger);
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                this.fieldType = xDoc.getNodeProperty(nodeObj, "FieldType").getValueInt(eTypes.eInteger);
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Field");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Index");
                xProperty.setValue(eTypes.eInteger, this.index);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("FieldType");
                xProperty.setValue(eTypes.eInteger, this.fieldType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
            toString() {
                return "name: " + this.name + ", index: " + this.index;
            }
        }
        CSReportEngine.cReportField = cReportField;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csColors = CSReports.CSDrawing.csColors;
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportFont {
            constructor() {
                this.foreColor = csColors.BLACK;
                this.size = 14;
                this.name = "Arial";
                this.underline = false;
                this.bold = false;
                this.italic = false;
                this.strike = false;
            }
            getForeColor() {
                return this.foreColor;
            }
            setForeColor(rhs) {
                this.foreColor = rhs;
            }
            getSize() {
                return this.size;
            }
            setSize(rhs) {
                this.size = rhs;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getUnderline() {
                return this.underline;
            }
            setUnderline(rhs) {
                this.underline = rhs;
            }
            getBold() {
                return this.bold;
            }
            setBold(rhs) {
                this.bold = rhs;
            }
            getItalic() {
                return this.italic;
            }
            setItalic(rhs) {
                this.italic = rhs;
            }
            getStrike() {
                return this.strike;
            }
            setStrike(rhs) {
                this.strike = rhs;
            }
            copy(from) {
                this.bold = from.bold;
                this.foreColor = from.foreColor.toString();
                this.italic = from.italic;
                this.name = from.name;
                this.size = from.size;
                this.underline = from.underline;
                this.strike = from.strike;
                return true;
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, "Font");
                this.bold = xDoc.getNodeProperty(nodeObj, "Bold").getValueBool(eTypes.eBoolean);
                this.foreColor = xDoc.getNodeProperty(nodeObj, "ForeColor").getValueString(eTypes.eText);
                this.italic = xDoc.getNodeProperty(nodeObj, "Italic").getValueBool(eTypes.eBoolean);
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                this.size = xDoc.getNodeProperty(nodeObj, "Size").getValueInt(eTypes.eInteger);
                this.underline = xDoc.getNodeProperty(nodeObj, "UnderLine").getValueBool(eTypes.eBoolean);
                this.strike = xDoc.getNodeProperty(nodeObj, "Strike").getValueBool(eTypes.eBoolean);
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Font");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("ForeColor");
                xProperty.setValue(eTypes.eText, this.foreColor);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Bold");
                xProperty.setValue(eTypes.eBoolean, this.bold);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Italic");
                xProperty.setValue(eTypes.eBoolean, this.italic);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Size");
                xProperty.setValue(eTypes.eInteger, this.size);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("UnderLine");
                xProperty.setValue(eTypes.eBoolean, this.underline);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Strike");
                xProperty.setValue(eTypes.eBoolean, this.strike);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
        }
        CSReportEngine.cReportFont = cReportFont;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cReportFormulaInt {
            constructor() {
                this.variables = new CSReportEngine.cReportVariables();
                this.parameters = new CSReportEngine.cReportFormulaParameters();
                this.formulaType = 0;
            }
            getVariables() {
                return this.variables;
            }
            getParameters() {
                return this.parameters;
            }
            getFormulaType() {
                return this.formulaType;
            }
            setFormulaType(rhs) {
                this.formulaType = rhs;
            }
        }
        CSReportEngine.cReportFormulaInt = cReportFormulaInt;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cReportFormulaParameter {
            constructor() {
                this.value = "";
            }
            getValue() {
                return this.value;
            }
            setValue(rhs) {
                this.value = rhs;
            }
        }
        CSReportEngine.cReportFormulaParameter = cReportFormulaParameter;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportFormulaParameters extends Map {
            add2(value, key) {
                try {
                    let c = new CSReportEngine.cReportFormulaParameter();
                    c.setValue(value);
                    this.add(c, key);
                    return c;
                }
                catch (ex) {
                    return null;
                }
            }
        }
        CSReportEngine.cReportFormulaParameters = cReportFormulaParameters;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csRptFormulaType = CSReports.CSReportGlobals.csRptFormulaType;
        class cReportFormulaType {
            constructor() {
                this.name = "";
                this.nameUser = "";
                this.id = csRptFormulaType.CSRPTF_NONE;
                this.decrip = "";
                this.helpContextId = 0;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getNameUser() {
                return this.nameUser;
            }
            setNameUser(rhs) {
                this.nameUser = rhs;
            }
            getId() {
                return this.id;
            }
            setId(rhs) {
                this.id = rhs;
            }
            getDecrip() {
                return this.decrip;
            }
            setDecrip(rhs) {
                this.decrip = rhs;
            }
            getHelpContextId() {
                return this.helpContextId;
            }
            setHelpContextId(rhs) {
                this.helpContextId = rhs;
            }
        }
        CSReportEngine.cReportFormulaType = cReportFormulaType;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var csRptFormulaType = CSReports.CSReportGlobals.csRptFormulaType;
        class cReportFormulaTypes extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportFormulaType);
                this.initialize();
            }
            initialize() {
                const LANGUAGE_DESCRIPT = "language: 1 Spanish, 2 English y 3 French";
                const CONTROL_NAME_DESCRIPT = "control_name: an string which identifies the control.";
                const COMPARE_DESCRIPT = "It returns a boolean after comparing a control's value with the second argument ";
                const VALUE_TO_COMPARE_DESCRIPT = "value: a number or a text to by compared with.";
                const GROUP_FUNCTION_DESCRIPT = "It function calculates its value before processing the group."
                    + "\nWhen CSReport found this function it iterates through the "
                    + "main recordset to the last row in the group and calculates "
                    + "the $1  of the values in the column refered by the "
                    + "column_name parameter.";
                const COLUMN_NAME = "column_name: name of the column in the main recordset.\n";
                const GROUP_INDEX = "group_index: index of the group"
                    + "\nWhen group_index is equal to -1 the index of the group section in which the control is contained will be used."
                    + "\nWhen group_index is equal to 0 the $1 of the column of every row in the main recordset will be returned."
                    + "\nWhen group_index is greater than zero the $1 of the column of every row in the main recordset contained in the group which index is equal to index_group will be returned.";
                const GROUP_FUNCTION_DESCRIPT2 = "It function calculates its value before processing the group."
                    + "\nWhen CSReport found this function it iterates through the "
                    + "main recordset to the last row in the group and calculates "
                    + "the $1.";
                const COLUMN_NAME1 = "column_name1: name of the column in the main recordset to summarize.\n";
                const COLUMN_NAME2 = "column_name2: name of the column in the main recordset to compare with the total.\n";
                const GROUP_INDEX2 = "group_index: index of the group"
                    + "\nWhen group_index is equal to -1 the index of the group section in which the control is contained will be used."
                    + "\nWhen group_index is equal to 0 the $1 will be evaluated using every row in the main recordset."
                    + "\nWhen group_index is greater than zero the $1 will be evaluated using every row contained in the group which index is equal to index_group.\n";
                let fi = this.add2(null, csRptFormulaType.CSRPTF_SET_VAR);
                fi.setName("_setvar");
                fi.setNameUser("Set a variable");
                fi.setDecrip("It sets the value of a variable.\n\nSyntax: _setVar(variable_name, value)");
                fi.setId(csRptFormulaType.CSRPTF_SET_VAR);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_SET_VAR);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GET_BARCODE);
                fi.setName("_getbarcode");
                fi.setNameUser("Takes an string and returns a barcode");
                fi.setDecrip("It returns a barcode.\n\nSyntax: _getBarcode(value)");
                fi.setId(csRptFormulaType.CSRPTF_GET_BARCODE);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GET_BARCODE);
                fi = this.add2(null, csRptFormulaType.CSRPTF_CALCULATE);
                fi.setName("_calculate");
                fi.setNameUser("Calculate");
                fi.setDecrip("It returns a double after applying an aritmetical operation to ther first two arguments.\n\nSyntax: _calc(control_1, control_2, value, operator)\n1 addition, 2 substraction, 3 multiplication, 4 division, 5 power");
                fi.setId(csRptFormulaType.CSRPTF_CALCULATE);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_CALCULATE);
                fi = this.add2(null, csRptFormulaType.CSRPTF_TOTAL_PAGES);
                fi.setName("_totalPages");
                fi.setNameUser("Page count");
                fi.setDecrip("It returns an int with the amount of pages in the report.\n\nSyntax: _totalPages()");
                fi.setId(csRptFormulaType.CSRPTF_TOTAL_PAGES);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_TOTAL_PAGES);
                fi = this.add2(null, csRptFormulaType.CSRPTF_COUNT);
                fi.setName("_count");
                fi.setNameUser("Record count");
                fi.setDecrip("It returns an int with the amount of rows in the main recordset of the report.\n\nSyntax: _count()");
                fi.setId(csRptFormulaType.CSRPTF_COUNT);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_COUNT);
                fi = this.add2(null, csRptFormulaType.CSRPTF_DECLARE_VAR);
                fi.setName("_declareVar");
                fi.setNameUser("Declare a variable");
                fi.setDecrip("It declares a variable.\n\nSyntax: _declareVar(variable_name)");
                fi.setId(csRptFormulaType.CSRPTF_DECLARE_VAR);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_DECLARE_VAR);
                fi = this.add2(null, csRptFormulaType.CSRPTF_IS_EQUAL);
                fi.setName("_isEqual");
                fi.setNameUser("Equal to");
                fi.setDecrip(COMPARE_DESCRIPT + "\n\nSyntax: _isEqual(control_name, value)\n" + CONTROL_NAME_DESCRIPT + "\n" + VALUE_TO_COMPARE_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_IS_EQUAL);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_IS_EQUAL);
                fi = this.add2(null, csRptFormulaType.CSRPTF_IS_NOT_EQUAL);
                fi.setName("_isNotEqual");
                fi.setNameUser("It is not equal to");
                fi.setDecrip(COMPARE_DESCRIPT + "\n\nSyntax: _isNotEqual(control_name, value)\n" + CONTROL_NAME_DESCRIPT + "\n" + VALUE_TO_COMPARE_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_IS_NOT_EQUAL);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_IS_NOT_EQUAL);
                fi = this.add2(null, csRptFormulaType.CSRPTF_IS_GREATER_THAN);
                fi.setName("_isGreaterThan");
                fi.setNameUser("It is greater than");
                fi.setDecrip(COMPARE_DESCRIPT + "\n\nSyntax: _isGreaterThan(control_name, value)\n" + CONTROL_NAME_DESCRIPT + "\n" + VALUE_TO_COMPARE_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_IS_GREATER_THAN);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_IS_GREATER_THAN);
                fi = this.add2(null, csRptFormulaType.CSRPTF_IS_LESS_THAN);
                fi.setName("_iseLowerthan");
                fi.setNameUser("It is lower than");
                fi.setDecrip(COMPARE_DESCRIPT + "\n\nSyntax: _isLowerThan(control_name, value)\n" + CONTROL_NAME_DESCRIPT + "\n" + VALUE_TO_COMPARE_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_IS_LESS_THAN);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_IS_LESS_THAN);
                fi = this.add2(null, csRptFormulaType.CSRPTF_IS_IN_RS);
                fi.setName("_isInRS");
                fi.setNameUser("It is contained in the main recordset");
                fi.setDecrip("It returns a boolean value after searching a constant value in a column of the main recordset.\r\n\r\nSyntax: _isInRS(column_name,\"value\")\ncolumn_name: the name of a column in the main recordset\nvalue: an string to be searched (it must be surrounded by double quotes).");
                fi.setId(csRptFormulaType.CSRPTF_IS_IN_RS);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_IS_IN_RS);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GROUP_TOTAL);
                fi.setName("_groupTotal");
                fi.setNameUser("Group) Group total");
                fi.setDecrip(GROUP_FUNCTION_DESCRIPT.replaceAll("$1", "summatory")
                    + "\n\nSyntax: _groupTotal(column_name, group_index)"
                    + "\n\n" + COLUMN_NAME
                    + "\n" + GROUP_INDEX.replaceAll("$1", "summatory"));
                fi.setId(csRptFormulaType.CSRPTF_GROUP_TOTAL);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GROUP_TOTAL);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GROUP_MAX);
                fi.setName("_groupMax");
                fi.setNameUser("Group) Group maximum");
                fi.setDecrip(GROUP_FUNCTION_DESCRIPT.replaceAll("$1", "maximum value")
                    + "\n\nSyntax: _groupTotal(column_name, group_index)"
                    + "\n\n" + COLUMN_NAME
                    + "\n" + GROUP_INDEX.replaceAll("$1", "maximum value"));
                fi.setId(csRptFormulaType.CSRPTF_GROUP_MAX);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GROUP_MAX);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GROUP_MIN);
                fi.setName("_groupMin");
                fi.setNameUser("Group) Group minimum");
                fi.setDecrip(GROUP_FUNCTION_DESCRIPT.replaceAll("$1", "minimum value")
                    + "\n\nSyntax: _groupTotal(column_name, group_index)"
                    + "\n\n" + COLUMN_NAME
                    + "\n" + GROUP_INDEX.replaceAll("$1", "minimum value"));
                fi.setId(csRptFormulaType.CSRPTF_GROUP_MIN);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GROUP_MIN);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GROUP_AVERAGE);
                fi.setName("_groupAverage");
                fi.setNameUser("Group) Group average");
                fi.setDecrip(GROUP_FUNCTION_DESCRIPT.replaceAll("$1", "average value")
                    + "\n\nSyntax: _groupAverage(column_name, group_index)"
                    + "\n\n" + COLUMN_NAME
                    + "\n" + GROUP_INDEX.replaceAll("$1", "average value"));
                fi.setId(csRptFormulaType.CSRPTF_GROUP_AVERAGE);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GROUP_AVERAGE);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GROUP_PERCENT);
                fi.setName("_groupPercent");
                fi.setNameUser("Group) Group percent");
                fi.setDecrip(GROUP_FUNCTION_DESCRIPT2.replaceAll("$1", "percent value column_name2 represents in the summatory of column_name1")
                    + "\n\nSyntax: _groupTotal(column_name1, column_name2, group_index)"
                    + "\n\n" + COLUMN_NAME
                    + "\n" + COLUMN_NAME
                    + "\nNote: usually column_name1 and column_name2 have the same value because it is used to get the perecentage a value in a set represents."
                    + "\n" + GROUP_INDEX2.replaceAll("$1", "percent value"));
                fi.setId(csRptFormulaType.CSRPTF_GROUP_PERCENT);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GROUP_PERCENT);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GROUP_COUNT);
                fi.setName("_groupCount");
                fi.setNameUser("Group) Amount of lines in a group");
                fi.setDecrip(GROUP_FUNCTION_DESCRIPT2.replaceAll("$1", "amunt of lines in the group")
                    + "\n\nSyntax: _groupCount(column_name, group_index)"
                    + "\n\n" + COLUMN_NAME
                    + "\n" + GROUP_INDEX2.replaceAll("$1", "amunt of lines"));
                fi.setId(csRptFormulaType.CSRPTF_GROUP_COUNT);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GROUP_COUNT);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GROUP_LINE_NUMBER);
                fi.setName("_groupLineNumber");
                fi.setNameUser("Group) Line number in a group");
                fi.setDecrip("It returns the line number in a Group, if when Group is zero it returns the line number in the report."
                    + "\n\nSyntax: _GroupLineNumber(group_index)"
                    + "\n\ngroup_index: Group's index"
                    + "\nWhen group_index is -1 the group's index where the control is contained will be used."
                    + "\nWhen group_index is 0 the line number in the report will be returned."
                    + "\nWhen group_index is > 0 the line number in the group will be returned.");
                fi.setDecrip(GROUP_FUNCTION_DESCRIPT2.replaceAll("$1", "line number of the current line in the group.")
                    + "\n\nSyntax: _groupLineNumber(group_index)"
                    + "\n" + GROUP_INDEX2.replaceAll("$1", "line number of the current line in the group"));
                fi.setId(csRptFormulaType.CSRPTF_GROUP_LINE_NUMBER);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GROUP_LINE_NUMBER);
                fi = this.add2(null, csRptFormulaType.CSRPTF_MAX);
                fi.setName("_max");
                fi.setNameUser("Maximum value in a column");
                fi.setDecrip("It returns a double with the maximun value in a column.\n\nSyntax: _max(control_name)\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_MAX);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_MAX);
                fi = this.add2(null, csRptFormulaType.CSRPTF_MIN);
                fi.setName("_min");
                fi.setNameUser("Minimum value in a column");
                fi.setDecrip("It returns a double with the minimu valie in a column.\n\nSyntax: _min(control_name)\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_MIN);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_MIN);
                fi = this.add2(null, csRptFormulaType.CSRPTF_NUMBER_TO_STRING);
                fi.setName("_numberToString");
                fi.setNameUser("Number to String");
                fi.setDecrip("It returns the number expressed in words.\n\nSyntax: _numberToString(control_name,nLanguage)\n" + CONTROL_NAME_DESCRIPT + "\n" + LANGUAGE_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_NUMBER_TO_STRING);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_NUMBER_TO_STRING);
                fi = this.add2(null, csRptFormulaType.CSRPTF_PAGE_NUMBER);
                fi.setName("_currentPage");
                fi.setNameUser("Page number");
                fi.setDecrip("It returns an int with the number of the current page.\n\nSyntax: _currentPage()");
                fi.setId(csRptFormulaType.CSRPTF_PAGE_NUMBER);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_PAGE_NUMBER);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GET_PARAM);
                fi.setName("_getParam");
                fi.setNameUser("Get a parameter value");
                fi.setDecrip("It returns a the value of a parameter from the main connection\n\nSyntax: _getParam(parameter_name)");
                fi.setId(csRptFormulaType.CSRPTF_GET_PARAM);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GET_PARAM);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GET_DATA_FROM_RS_AD);
                fi.setName("_getDataFromRSAd");
                fi.setNameUser("Get a value form a column of a row in an additional recordset");
                fi.setDecrip("It returns a value from a column of a row in an additional recordset. "
                    + "\n\nThe rows of the additional recordset are filtered comparing the value "
                    + "of the column refered by the parameter filter of "
                    + "the current row in the main recordset with the values of the column "
                    + "refered by filter_column_name_add_ds in the additional recordset."
                    + "\n\nSyntax: (ds means Data Source): "
                    + "_getDataFromRSAd(ds_name, ds_index, column_name, filter)"
                    + "\n\nds_name: name of the additioanl connection"
                    + "\nds_index: index of the recordset in the additioanl connection"
                    + "\ncolumn_name: name of the column in the additional recordset which contains the value to return"
                    + "\nfilter: an strng containing the relation between one or more columns of the main recordset and the additional recordset"
                    + "\n\texample of filter:"
                    + "\n\t\tpr_id=pr_id (tipical primary key to foreign key relation)"
                    + "\n\t\tpr_id=pr_id|fv_id=fv_id (a two column relation is separated by pipes)"
                    + "\n\t\tas_id=as_id_factura (the names of the columns can be differents)");
                fi.setId(csRptFormulaType.CSRPTF_GET_DATA_FROM_RS_AD);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GET_DATA_FROM_RS_AD);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GET_DATA_FROM_RS);
                fi.setName("_getDataFromRS");
                fi.setNameUser("Get a value from a column of a row in the main recordset");
                fi.setDecrip("It returns a value from a column of a row in the main recordset. "
                    + "The rows are filtered comparing the value "
                    + "of the column refered by the parameter filter_column_name1 of "
                    + "the current row with the values of the column "
                    + "refered by filter_column_name2."
                    + "\n\nSyntax: getDataFromRS (column_name, filter_column_name1, filter_column_name2)"
                    + "\n\ncolumn_name: name of the column which contains the value to return"
                    + "\nfilter_column_name1: name of the column in the current record"
                    + "\nfilter_column_name2: name of the column in used to filter values");
                fi.setId(csRptFormulaType.CSRPTF_GET_DATA_FROM_RS);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GET_DATA_FROM_RS);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GET_STRING);
                fi.setName("_getString");
                fi.setNameUser("Get an string");
                fi.setDecrip("It returns the value of the control refered by the control_name parameter surrounded by double quotes"
                    + "\n\nSyntax: _getString(control_name)\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_GET_STRING);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GET_STRING);
                fi = this.add2(null, csRptFormulaType.CSRPTF_GET_VAR);
                fi.setName("_getVar");
                fi.setNameUser("Get the value of a user variable");
                fi.setDecrip("It returns the value of the variable refered by the variable_name parameter"
                    + "\n\nSyntax: _getVar(variable_name)");
                fi.setId(csRptFormulaType.CSRPTF_GET_VAR);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_GET_VAR);
                fi = this.add2(null, csRptFormulaType.CSRPTF_AVERAGE);
                fi.setName("_average");
                fi.setNameUser("Average of a Column");
                fi.setDecrip("It returns a double with the average value of a column"
                    + "\n\nSyntax: _average(control_name)\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_AVERAGE);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_AVERAGE);
                fi = this.add2(null, csRptFormulaType.CSRPTF_ADD_TO_VAR);
                fi.setName("_addToVar");
                fi.setNameUser("Add a value to a user variable");
                fi.setDecrip("It adds the value of the parameter value to a user variable refered by the parameter variable_name"
                    + "\n\nSyntax: _addToVar(variable_name, value)");
                fi.setId(csRptFormulaType.CSRPTF_ADD_TO_VAR);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_ADD_TO_VAR);
                fi = this.add2(null, csRptFormulaType.CSRPTF_SUM);
                fi.setName("_sum");
                fi.setNameUser("Totals of a column");
                fi.setDecrip("It returns the total of a column\n\nSyntax: _sum(control_name)\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_SUM);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_SUM);
                fi = this.add2(null, csRptFormulaType.CSRPTF_SUM_TIME);
                fi.setName("_sumTime");
                fi.setNameUser("Totals in time units of a column");
                fi.setDecrip("It returns the amount of hours, minutes and seconds from a column which contains hours and minutes in the format hh:nn"
                    + "\n\nSyntax: _sumTime(control_name, show_seconds)\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_SUM_TIME);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_SUM_TIME);
                fi = this.add2(null, csRptFormulaType.CSRPTF_LENGTH);
                fi.setName("_length");
                fi.setNameUser("Length of a control's value");
                fi.setDecrip("It returns an int with the length of a control's value\n\nSyntax: _length(control_name)\n\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_LENGTH);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_LENGTH);
                fi = this.add2(null, csRptFormulaType.CSRPTF_TEXT_REPLACE);
                fi.setName("_textReplace");
                fi.setNameUser("Replace a control name by its value in a string");
                fi.setDecrip("It replace every occurrence of a control name in the text property of another control. "
                    + "\n\nThis is the only function which is used in the text property of a control. "
                    + "the syntax is very weird because you don't call this function using its name "
                    + "but you put in the text property of a control the name of other control "
                    + "surrounded by two ats (@@control_name@@)\n\nSyntax: @@control_name@@\n\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_TEXT_REPLACE);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_TEXT_REPLACE);
                fi = this.add2(null, csRptFormulaType.CSRPTF_VAL);
                fi.setName("_value");
                fi.setNameUser("Value of a control");
                fi.setDecrip("It returns an string with the value of the control refered by the control_name parameter"
                    + "\n\nSyntax: _value(control_name)\n\n" + CONTROL_NAME_DESCRIPT);
                fi.setId(csRptFormulaType.CSRPTF_VAL);
                fi.setHelpContextId(csRptFormulaType.CSRPTF_VAL);
            }
            add2(o, key) {
                return this.add(o, key.toString());
            }
        }
        CSReportEngine.cReportFormulaTypes = cReportFormulaTypes;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportFormulas extends Map {
            add(name) {
                try {
                    let c = new CSReportEngine.cReportFormula();
                    c.setName(name);
                    this.baseAdd(c, name);
                    return c;
                }
                catch (_a) {
                    return null;
                }
            }
            add2(formula, name) {
                try {
                    this.baseAdd(formula, name);
                    formula.setNotSave(true);
                }
                catch (_a) {
                }
            }
        }
        CSReportEngine.cReportFormulas = cReportFormulas;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportFormulasInt extends Map {
            add(value, key) {
                if (value === null || value === undefined) {
                    value = new CSReportEngine.cReportFormulaInt();
                }
                return this.baseAdd(value, key);
            }
        }
        CSReportEngine.cReportFormulasInt = cReportFormulasInt;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportGroup {
            constructor() {
                this.HEADER = "H";
                this.FOOTER = "F";
                this.header = null;
                this.footer = null;
                this.index = 0;
                this.name = "";
                this.oderType = null;
                this.comparisonType = null;
                this.printInNewPage = null;
                this.rePrintInNewPage = null;
                this.grandTotalGroup = null;
                this.fieldName = "";
                this.key = "";
            }
            getHeader() {
                return this.header;
            }
            setHeader(rhs) {
                this.header = rhs;
            }
            getFooter() {
                return this.footer;
            }
            setFooter(rhs) {
                this.footer = rhs;
            }
            getIndex() {
                return this.index;
            }
            setIndex(rhs) {
                this.index = rhs;
            }
            getOderType() {
                return this.oderType;
            }
            setOderType(rhs) {
                this.oderType = rhs;
            }
            getComparisonType() {
                return this.comparisonType;
            }
            setComparisonType(rhs) {
                this.comparisonType = rhs;
            }
            getPrintInNewPage() {
                return this.printInNewPage;
            }
            setPrintInNewPage(rhs) {
                this.printInNewPage = rhs;
            }
            getRePrintInNewPage() {
                return this.rePrintInNewPage;
            }
            setRePrintInNewPage(rhs) {
                this.rePrintInNewPage = rhs;
            }
            getGrandTotalGroup() {
                return this.grandTotalGroup;
            }
            setGrandTotalGroup(rhs) {
                this.grandTotalGroup = rhs;
            }
            getFieldName() {
                return this.fieldName;
            }
            setFieldName(rhs) {
                this.fieldName = rhs;
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            copy(from) {
                this.name = from.name;
                this.index = from.index;
                this.comparisonType = from.comparisonType;
                this.fieldName = from.fieldName;
                this.oderType = from.oderType;
                this.printInNewPage = from.printInNewPage;
                this.rePrintInNewPage = from.rePrintInNewPage;
                this.grandTotalGroup = from.grandTotalGroup;
                this.fixName();
                if (!this.header.copy(from.header)) {
                    return false;
                }
                this.header.setName(this.name);
                if (!this.footer.copy(from.footer)) {
                    return false;
                }
                this.footer.setName(this.name);
                return true;
            }
            load(xDoc, nodeObj) {
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                this.index = xDoc.getNodeProperty(nodeObj, "Indice").getValueInt(eTypes.eInteger);
                this.comparisonType = xDoc.getNodeProperty(nodeObj, "ComparisonType").getValueInt(eTypes.eInteger);
                this.fieldName = xDoc.getNodeProperty(nodeObj, "FieldName").getValueString(eTypes.eText);
                this.oderType = xDoc.getNodeProperty(nodeObj, "OderType").getValueInt(eTypes.eInteger);
                this.printInNewPage = xDoc.getNodeProperty(nodeObj, "PrintInNewPage").getValueBool(eTypes.eBoolean);
                this.rePrintInNewPage = xDoc.getNodeProperty(nodeObj, "RePrintInNewPage").getValueBool(eTypes.eBoolean);
                this.grandTotalGroup = xDoc.getNodeProperty(nodeObj, "GrandTotalGroup").getValueBool(eTypes.eBoolean);
                this.fixName();
                let nodeObjAux = null;
                nodeObjAux = nodeObj;
                nodeObjAux = xDoc.getNodeFromNode(nodeObj, this.HEADER);
                nodeObjAux = xDoc.getNodeChild(nodeObjAux);
                if (!this.header.load(xDoc, nodeObjAux)) {
                    return false;
                }
                this.header.setName(this.name);
                nodeObjAux = nodeObj;
                nodeObjAux = xDoc.getNodeFromNode(nodeObj, this.FOOTER);
                nodeObjAux = xDoc.getNodeChild(nodeObjAux);
                if (!this.footer.load(xDoc, nodeObjAux)) {
                    return false;
                }
                this.footer.setName(this.name);
                return true;
            }
            fixName() {
                if (this.name.length === 0
                    || this.name.toLowerCase().substring(0, 5) === "group"
                    || this.name.toLowerCase().substring(0, 5) === "grupo"
                    || this.name.toLowerCase().substring(0, 3) === "gh_"
                    || this.name.toLowerCase().substring(0, 3) === "gf_"
                    || this.name.toLowerCase().substring(0, 2) === "g_") {
                    this.name = "G_" + this.index;
                }
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName(this.name);
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Key");
                xProperty.setValue(eTypes.eText, this.key);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Indice");
                xProperty.setValue(eTypes.eInteger, this.index);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("ComparisonType");
                xProperty.setValue(eTypes.eInteger, this.comparisonType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("FieldName");
                xProperty.setValue(eTypes.eText, this.fieldName);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("OderType");
                xProperty.setValue(eTypes.eInteger, this.oderType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("PrintInNewPage");
                xProperty.setValue(eTypes.eBoolean, this.printInNewPage);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("RePrintInNewPage");
                xProperty.setValue(eTypes.eBoolean, this.rePrintInNewPage);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("GrandTotalGroup");
                xProperty.setValue(eTypes.eBoolean, this.grandTotalGroup);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                let nodeObjAux = null;
                nodeObjAux = nodeObj;
                xProperty.setName(this.HEADER);
                nodeObjAux = xDoc.addNodeToNode(nodeObjAux, xProperty);
                this.header.save(xDoc, nodeObjAux);
                nodeObjAux = nodeObj;
                xProperty.setName(this.FOOTER);
                nodeObjAux = xDoc.addNodeToNode(nodeObjAux, xProperty);
                this.footer.save(xDoc, nodeObjAux);
                return true;
            }
        }
        CSReportEngine.cReportGroup = cReportGroup;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var csRptSectionType = CSReports.CSReportGlobals.csRptSectionType;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        var Map = CSReports.CSOAPI.Map;
        class cReportGroups extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportGroup);
                this.groupsHeaders = new CSReportEngine.cReportSections();
                this.groupsFooters = new CSReportEngine.cReportSections();
            }
            getGroupsHeaders() {
                return this.groupsHeaders;
            }
            setGroupsHeaders(rhs) {
                this.groupsHeaders = rhs;
            }
            getGroupsFooters() {
                return this.groupsFooters;
            }
            setGroupsFooters(rhs) {
                this.groupsFooters = rhs;
            }
            add(c, key) {
                try {
                    if (c === null) {
                        c = new CSReportEngine.cReportGroup();
                    }
                    if (key === "") {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    c.setIndex(this.count() - 1);
                    c.setHeader(this.groupsHeaders.add(null, "", -1));
                    c.setFooter(this.groupsFooters.add(null, "", 0));
                    this.setName(c, "G_" + c.getIndex().toString());
                    this.setName(c.getHeader(), c.getName());
                    this.setName(c.getFooter(), c.getName());
                    c.getHeader().setTypeSection(csRptSectionType.GROUP_HEADER);
                    c.getFooter().setTypeSection(csRptSectionType.GROUP_FOOTER);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
            add2(c, key) {
                try {
                    if (c === null) {
                        c = new CSReportEngine.cReportGroup();
                    }
                    if (key === "") {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    c.setIndex(this.count());
                    this.groupsHeaders.add(c.getHeader(), "", -1);
                    this.groupsFooters.add(c.getFooter(), "", 0);
                    this.setName(c, "G_" + c.getIndex().toString());
                    this.setName(c.getHeader(), c.getName());
                    this.setName(c.getFooter(), c.getName());
                    c.getHeader().setTypeSection(csRptSectionType.GROUP_HEADER);
                    c.getFooter().setTypeSection(csRptSectionType.GROUP_FOOTER);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
            setName(c, name) {
                c.setName(this.setName2(c.getName(), name));
            }
            setName2(section, name) {
                let sectionName = section.toLowerCase();
                if (sectionName.length === 0
                    || sectionName.substring(0, 5) === "group"
                    || sectionName.substring(0, 5) === "grupo"
                    || sectionName.substring(0, 3) === "gh_"
                    || sectionName.substring(0, 3) === "gf_"
                    || sectionName.substring(0, 2) === "g_") {
                    return name;
                }
                else {
                    return section;
                }
            }
            clear() {
                try {
                    let n = this.count();
                    for (let i = 0; i < n; i++) {
                        this.remove(0);
                    }
                    return;
                }
                catch (ignore) {
                }
            }
            remove(key) {
                try {
                    let keyH = "";
                    let keyF = "";
                    keyH = this.groupsHeaders.item(this.item(key).getHeader().getKey()).getKey();
                    keyF = this.groupsFooters.item(this.item(key).getFooter().getKey()).getKey();
                    this.groupsHeaders.remove(keyH);
                    this.groupsFooters.remove(keyF);
                    this.baseRemove(key);
                    for (let i = 0; i < this.count(); i++) {
                        this.item(i).setIndex(i);
                        this.item(i).fixName();
                    }
                }
                catch (ignore) {
                }
            }
        }
        CSReportEngine.cReportGroups = cReportGroups;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cReportImage {
            constructor() {
                this.aspect = null;
                this.image = null;
                this.aspect = new CSReportEngine.cReportAspect();
            }
            getAspect() {
                return this.aspect;
            }
            setAspect(rhs) {
                this.aspect = rhs;
            }
            getImage() {
                return this.image;
            }
            setImage(rhs) {
                this.image = rhs;
            }
            copy(from) {
                this.image = from.image;
                return this.aspect.copy(from.aspect);
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, "Image");
                const vBytes = xDoc.getBinaryNodeProperty(nodeObj, "Data").getBinaryValue();
                if (vBytes.length > 1) {
                    this.image = CSReportEngine.cImage.deSerialiseBitmap(vBytes);
                }
                return this.aspect.load(xDoc, nodeObj);
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                let nodImage = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Image");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                let vBytes = null;
                if (this.getImage() !== null) {
                    CSReportEngine.cImage.serialiseBitmap(this.getImage(), vBytes);
                }
                else {
                    vBytes = [];
                }
                xProperty.setName("Data");
                xProperty.setBinaryValue(vBytes);
                xDoc.addBinaryPropertyToNode(nodeObj, xProperty);
                vBytes = [];
                return this.aspect.save(xDoc, nodeObj);
            }
            toString() {
                return "height: " + this.getAspect().getHeight() + ", width: " + this.getAspect().getWidth();
            }
        }
        CSReportEngine.cReportImage = cReportImage;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportLabel {
            constructor() {
                this.aspect = null;
                this.text = "";
                this.canGrow = null;
                this.aspect = new CSReportEngine.cReportAspect();
            }
            getAspect() {
                return this.aspect;
            }
            setAspect(rhs) {
                this.aspect = rhs;
            }
            getText() {
                return this.text;
            }
            setText(rhs) {
                this.text = rhs;
            }
            getCanGrow() {
                return this.canGrow;
            }
            setCanGrow(rhs) {
                this.canGrow = rhs;
            }
            copy(from) {
                this.text = from.text;
                return this.aspect.copy(from.aspect);
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, "Label");
                this.text = xDoc.getNodeProperty(nodeObj, "Text").getValueString(eTypes.eText);
                return this.aspect.load(xDoc, nodeObj);
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Label");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Text");
                xProperty.setValue(eTypes.eText, this.text);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("CanGrow");
                xProperty.setValue(eTypes.eBoolean, this.canGrow);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return this.aspect.save(xDoc, nodeObj);
            }
            toString() {
                return "text: " + this.text + ", foreColor: " + this.aspect.getFont().getForeColor();
            }
        }
        CSReportEngine.cReportLabel = cReportLabel;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cReportLine {
            constructor() {
                this.aspect = new CSReportEngine.cReportAspect();
            }
            getAspect() {
                return this.aspect;
            }
            setAspect(rhs) {
                this.aspect = rhs;
            }
            copy(from) {
                return this.aspect.copy(from.aspect);
            }
            load(xDoc, nodeObj) {
                nodeObj = xDoc.getNodeFromNode(nodeObj, "Line");
                return this.aspect.load(xDoc, nodeObj);
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Line");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                return this.aspect.save(xDoc, nodeObj);
            }
            toString() {
                return "height: " + this.getAspect().getHeight() + ", width: " + this.getAspect().getWidth();
            }
        }
        CSReportEngine.cReportLine = cReportLine;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportPage {
            constructor() {
                this.NODE_RPT_HEADER = "Header";
                this.NODE_RPT_HEADER_LINE = "HeaderLine";
                this.NODE_RPT_DETAIL = "Detail";
                this.NODE_RPT_DETAIL_LINE = "DetailLine";
                this.NODE_RPT_FOOTER = "Footer";
                this.NODE_RPT_FOOTER_LINE = "FooterLine";
                this.detail = new CSReportEngine.cReportPageFields();
                this.header = new CSReportEngine.cReportPageFields();
                this.footer = new CSReportEngine.cReportPageFields();
                this.pageNumber = 0;
                this.headerBottom = 0;
                this.footerTop = 0;
            }
            getHeader() {
                return this.header;
            }
            setHeader(rhs) {
                this.header = rhs;
            }
            getDetail() {
                return this.detail;
            }
            setDetail(rhs) {
                this.detail = rhs;
            }
            getFooter() {
                return this.footer;
            }
            setFooter(rhs) {
                this.footer = rhs;
            }
            getPageNumber() {
                return this.pageNumber;
            }
            setPageNumber(rhs) {
                this.pageNumber = rhs;
            }
            getHeaderBottom() {
                return this.headerBottom;
            }
            setHeaderBottom(rhs) {
                this.headerBottom = rhs;
            }
            getFooterTop() {
                return this.footerTop;
            }
            setFooterTop(rhs) {
                this.footerTop = rhs;
            }
            copy(from) {
                this.pageNumber = from.pageNumber;
                this.headerBottom = from.headerBottom;
                this.footerTop = from.footerTop;
                this.header.clear();
                this.detail.clear();
                this.footer.clear();
                for (let i = 0; i < from.header.values.length; i++) {
                    if (!this.header.add(null).copy(from.header.values[i])) {
                        return false;
                    }
                }
                for (let i = 0; i < from.detail.values.length; i++) {
                    if (!this.detail.add(null).copy(from.detail.values[i])) {
                        return false;
                    }
                }
                for (let i = 0; i < from.footer.values.length; i++) {
                    if (!this.footer.add(null).copy(from.footer.values[i])) {
                        return false;
                    }
                }
                return true;
            }
            load(xDoc, nodeObj) {
                let nodeObjSecLn = null;
                this.pageNumber = xDoc.getNodeProperty(nodeObj, "PageNumber").getValueInt(eTypes.eInteger);
                this.headerBottom = xDoc.getNodeProperty(nodeObj, "HeaderBottom").getValueInt(eTypes.eLong);
                this.footerTop = xDoc.getNodeProperty(nodeObj, "FooterTop").getValueInt(eTypes.eLong);
                this.header.clear();
                this.detail.clear();
                this.footer.clear();
                nodeObj = xDoc.getNodeFromNode(nodeObj, this.NODE_RPT_HEADER);
                if (xDoc.nodeHasChild(nodeObj)) {
                    nodeObjSecLn = xDoc.getNodeChild(nodeObj);
                    while (nodeObjSecLn !== null) {
                        if (!this.header.add(null).load(xDoc, nodeObjSecLn)) {
                            return false;
                        }
                        nodeObjSecLn = xDoc.getNextNode(nodeObjSecLn);
                    }
                }
                nodeObj = xDoc.getNodeFromNode(nodeObj, this.NODE_RPT_DETAIL);
                if (xDoc.nodeHasChild(nodeObj)) {
                    nodeObjSecLn = xDoc.getNodeChild(nodeObj);
                    while (nodeObjSecLn !== null) {
                        if (!this.detail.add(null).load(xDoc, nodeObjSecLn)) {
                            return false;
                        }
                        nodeObjSecLn = xDoc.getNextNode(nodeObjSecLn);
                    }
                }
                nodeObj = xDoc.getNodeFromNode(nodeObj, this.NODE_RPT_FOOTER);
                if (xDoc.nodeHasChild(nodeObj)) {
                    nodeObjSecLn = xDoc.getNodeChild(nodeObj);
                    while (nodeObjSecLn !== null) {
                        if (!this.footer.add(null).load(xDoc, nodeObjSecLn)) {
                            return false;
                        }
                        nodeObjSecLn = xDoc.getNextNode(nodeObjSecLn);
                    }
                }
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Page");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xDoc.setNodeText(nodeObj, "Pgina " + this.pageNumber);
                xProperty.setName("PageNumber");
                xProperty.setValue(eTypes.eInteger, this.pageNumber);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("HeaderBottom");
                xProperty.setValue(eTypes.eLong, this.headerBottom);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("FooterTop");
                xProperty.setValue(eTypes.eLong, this.footerTop);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                let pageFld = null;
                let nodeAux = null;
                xProperty.setName(this.NODE_RPT_HEADER);
                xProperty.setValue(eTypes.eText, "");
                nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                for (let _i = 0; _i < this.header.count(); _i++) {
                    pageFld = this.header.item(_i);
                    pageFld.save(xDoc, nodeAux);
                }
                xProperty.setName(this.NODE_RPT_DETAIL);
                xProperty.setValue(eTypes.eText, "");
                nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                for (let _i = 0; _i < this.detail.count(); _i++) {
                    pageFld = this.detail.item(_i);
                    pageFld.save(xDoc, nodeAux);
                }
                xProperty.setName(this.NODE_RPT_FOOTER);
                xProperty.setValue(eTypes.eText, "");
                nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                for (let _i = 0; _i < this.footer.count(); _i++) {
                    pageFld = this.footer.item(_i);
                    pageFld.save(xDoc, nodeAux);
                }
                return true;
            }
            saveForWeb(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Page");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xDoc.setNodeText(nodeObj, "Pgina " + this.pageNumber);
                let pageFld = null;
                let nodeAux = null;
                let top = 0;
                let addLine = false;
                let nHeader = 0;
                xProperty.setName(this.NODE_RPT_HEADER);
                xProperty.setValue(eTypes.eText, "");
                nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                for (let _i = 0; _i < this.header.count(); _i++) {
                    pageFld = this.header.item(_i);
                    addLine = false;
                    if (pageFld.getTop() === 0) {
                        if (top !== pageFld.getInfo().getAspect().getTop()) {
                            top = pageFld.getInfo().getAspect().getTop();
                            addLine = true;
                            nHeader = nHeader + 1;
                        }
                    }
                    else {
                        if (top !== pageFld.getTop()) {
                            top = pageFld.getTop();
                            addLine = true;
                            nHeader = nHeader + 1;
                        }
                    }
                    if (addLine) {
                        xProperty.setName(this.NODE_RPT_HEADER_LINE + nHeader.toString());
                        xProperty.setValue(eTypes.eText, "");
                        nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                    }
                    pageFld.saveForWeb(xDoc, nodeAux);
                }
                xProperty.setName(this.NODE_RPT_DETAIL);
                xProperty.setValue(eTypes.eText, "");
                nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                for (let _i = 0; _i < this.detail.count(); _i++) {
                    pageFld = this.detail.item(_i);
                    addLine = false;
                    if (pageFld.getTop() === 0) {
                        if (top !== pageFld.getInfo().getAspect().getTop()) {
                            top = pageFld.getInfo().getAspect().getTop();
                            addLine = true;
                        }
                    }
                    else {
                        if (top !== pageFld.getTop()) {
                            top = pageFld.getTop();
                            addLine = true;
                        }
                    }
                    if (addLine) {
                        xProperty.setName(this.NODE_RPT_DETAIL_LINE);
                        xProperty.setValue(eTypes.eText, "");
                        nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                    }
                    pageFld.saveForWeb(xDoc, nodeAux);
                }
                xProperty.setName(this.NODE_RPT_FOOTER);
                xProperty.setValue(eTypes.eText, "");
                nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                for (let _i = 0; _i < this.footer.count(); _i++) {
                    pageFld = this.footer.item(_i);
                    addLine = false;
                    if (pageFld.getTop() === 0) {
                        if (top !== pageFld.getInfo().getAspect().getTop()) {
                            top = pageFld.getInfo().getAspect().getTop();
                            addLine = true;
                        }
                    }
                    else {
                        if (top !== pageFld.getTop()) {
                            top = pageFld.getTop();
                            addLine = true;
                        }
                    }
                    if (addLine) {
                        xProperty.setName(this.NODE_RPT_FOOTER_LINE);
                        xProperty.setValue(eTypes.eText, "");
                        nodeAux = xDoc.addNodeToNode(nodeObj, xProperty);
                    }
                    pageFld.saveForWeb(xDoc, nodeAux);
                }
                return true;
            }
        }
        CSReportEngine.cReportPage = cReportPage;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        var Image = CSReports.CSDrawing.ImageX;
        class cReportPageField {
            constructor() {
                this.value = "";
                this.info = null;
                this.visible = null;
                this.objectID = null;
                this.indexLine = 0;
                this.top = 0;
                this.height = 0;
                this.width = 0;
                this.image = null;
            }
            getValue() {
                return this.value;
            }
            setValue(rhs) {
                this.value = rhs;
            }
            getInfo() {
                return this.info;
            }
            setInfo(rhs) {
                this.info = rhs;
            }
            getVisible() {
                return this.visible;
            }
            setVisible(rhs) {
                this.visible = rhs;
            }
            getObjectID() {
                return this.objectID;
            }
            setObjectID(rhs) {
                this.objectID = rhs;
            }
            getTop() {
                return this.top;
            }
            setTop(rhs) {
                this.top = rhs;
            }
            getHeight() {
                return this.height;
            }
            setHeight(rhs) {
                this.height = rhs;
            }
            getWidth() {
                return this.width;
            }
            setWidth(rhs) {
                this.width = rhs;
            }
            getImage() {
                return this.image;
            }
            setImage(rhs) {
                this.image = rhs;
            }
            getIndexLine() {
                return this.indexLine;
            }
            setIndexLine(rhs) {
                this.indexLine = rhs;
            }
            copy(from) {
                this.objectID = new CSReportEngine.cReportPageID();
                this.info = new CSReportEngine.cReportPageInfo();
                this.value = from.value;
                this.visible = from.visible;
                this.top = from.top;
                this.height = from.height;
                this.width = from.width;
                if (from.image !== undefined && from.image !== null) {
                    this.image = new Image(null, from.image._key);
                }
                if (!this.objectID.copy(from.objectID)) {
                    return false;
                }
                if (!this.info.copy(from.info)) {
                    return false;
                }
                return true;
            }
            load(xDoc, nodeObj) {
                this.objectID = new CSReportEngine.cReportPageID();
                this.info = new CSReportEngine.cReportPageInfo();
                this.value = xDoc.getNodeProperty(nodeObj, "Value").getValueString(eTypes.eText);
                this.visible = xDoc.getNodeProperty(nodeObj, "Visible").getValueBool(eTypes.eBoolean);
                this.top = xDoc.getNodeProperty(nodeObj, "Top").getValueInt(eTypes.eLong);
                this.height = xDoc.getNodeProperty(nodeObj, "Height").getValueInt(eTypes.eLong);
                this.width = xDoc.getNodeProperty(nodeObj, "Width").getValueInt(eTypes.eLong);
                let nodeObjAux = null;
                nodeObjAux = nodeObj;
                if (!this.objectID.load(xDoc, nodeObjAux)) {
                    return false;
                }
                nodeObjAux = nodeObj;
                if (!this.info.load(xDoc, nodeObjAux)) {
                    return false;
                }
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Field");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Value");
                xProperty.setValue(eTypes.eText, this.value);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Visible");
                xProperty.setValue(eTypes.eBoolean, this.visible);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Top");
                xProperty.setValue(eTypes.eLong, this.top);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Height");
                xProperty.setValue(eTypes.eLong, this.height);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Width");
                xProperty.setValue(eTypes.eLong, this.width);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                if (this.objectID !== null) {
                    if (!this.objectID.save(xDoc, nodeObj)) {
                        return false;
                    }
                }
                if (!this.info.save(xDoc, nodeObj)) {
                    return false;
                }
                return true;
            }
            saveForWeb(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("Field");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Value");
                xProperty.setValue(eTypes.eText, this.value);
                nodeObj = xDoc.addNodeToNode(nodeObj, xProperty);
                xDoc.setNodeText(nodeObj, this.value);
                return true;
            }
        }
        CSReportEngine.cReportPageField = cReportPageField;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportPageFields extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportPageField);
            }
        }
        CSReportEngine.cReportPageFields = cReportPageFields;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportPageID {
            constructor() {
                this.value = "";
            }
            getValue() {
                return this.value;
            }
            setValue(rhs) {
                this.value = rhs;
            }
            copy(from) {
                this.value = (from === null || from === void 0 ? void 0 : from.value) || null;
                return true;
            }
            load(xDoc, nodeObj) {
                this.value = xDoc.getNodeProperty(nodeObj, "Value").getValueString(eTypes.eText);
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("PageID");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Value");
                xProperty.setValue(eTypes.eText, this.value);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
        }
        CSReportEngine.cReportPageID = cReportPageID;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportPageInfo {
            constructor() {
                this.aspect = null;
                this.sectionLine = null;
                this.name = "";
                this.tag = "";
                this.fieldType = 0;
                this.aspect = new CSReportEngine.cReportAspect();
            }
            getName() {
                return this.name;
            }
            setName(rhs) {
                this.name = rhs;
            }
            getTag() {
                return this.tag;
            }
            setTag(rhs) {
                this.tag = rhs;
            }
            getAspect() {
                return this.aspect;
            }
            setAspect(rhs) {
                this.aspect = rhs;
            }
            getSectionLine() {
                return this.sectionLine;
            }
            setSectionLine(rhs) {
                this.sectionLine = rhs;
            }
            getFieldType() {
                return this.fieldType;
            }
            setFieldType(rhs) {
                this.fieldType = rhs;
            }
            copy(from) {
                this.name = from.name;
                this.tag = from.tag;
                this.fieldType = from.fieldType;
                if (!this.aspect.copy(from.aspect)) {
                    return false;
                }
                return true;
            }
            load(xDoc, nodeObj) {
                let nodeObjAspect = null;
                this.name = xDoc.getNodeProperty(nodeObj, "Name").getValueString(eTypes.eText);
                this.fieldType = xDoc.getNodeProperty(nodeObj, "FieldType").getValueInt(eTypes.eInteger);
                nodeObjAspect = nodeObj;
                if (!this.aspect.load(xDoc, nodeObjAspect)) {
                    return false;
                }
                else {
                    return true;
                }
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                xProperty.setName("PageInfo");
                nodeObj = xDoc.addNodeToNode(nodeFather, xProperty);
                xProperty.setName("Name");
                xProperty.setValue(eTypes.eText, this.name);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("FieldType");
                xProperty.setValue(eTypes.eInteger, this.fieldType);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return this.aspect.save(xDoc, nodeObj);
            }
        }
        CSReportEngine.cReportPageInfo = cReportPageInfo;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cReportPageSettings extends Map {
            constructor() {
                super(...arguments);
                this.height = 0;
            }
            getHeight() {
                return this.height;
            }
            setHeight(rhs) {
                this.height = rhs;
            }
            add2(sectionLine, c, key) {
                try {
                    if (c === null) {
                        c = new CSReportEngine.cReportPageInfo();
                    }
                    if (key === "") {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    key = ReportGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setSectionLine(sectionLine);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
        }
        CSReportEngine.cReportPageSettings = cReportPageSettings;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var eTypes = CSReports.CSKernelClient.eTypes;
        class cReportPaperInfo {
            constructor() {
                this.width = 0;
                this.height = 0;
                this.paperSize = null;
                this.orientation = 0;
                this.customHeight = 0;
                this.customWidth = 0;
                this.pagesToPrint = "";
                this.paperBin = 0;
            }
            getWidth() {
                return this.width;
            }
            setWidth(rhs) {
                this.width = rhs;
            }
            getHeight() {
                return this.height;
            }
            setHeight(rhs) {
                this.height = rhs;
            }
            getPaperSize() {
                return this.paperSize;
            }
            setPaperSize(rhs) {
                this.paperSize = rhs;
            }
            getOrientation() {
                return this.orientation;
            }
            setOrientation(rhs) {
                this.orientation = rhs;
            }
            getCustomHeight() {
                return this.customHeight;
            }
            setCustomHeight(rhs) {
                this.customHeight = rhs;
            }
            getCustomWidth() {
                return this.customWidth;
            }
            setCustomWidth(rhs) {
                this.customWidth = rhs;
            }
            getPaperBin() {
                return this.paperBin;
            }
            setPaperBin(rhs) {
                this.paperBin = rhs;
            }
            getPagesToPrint() {
                return this.pagesToPrint;
            }
            setPagesToPrint(rhs) {
                this.pagesToPrint = rhs;
            }
            copy(from) {
                if (from !== null) {
                    this.height = from.height;
                    this.paperSize = from.paperSize;
                    this.width = from.width;
                    this.orientation = from.orientation;
                    this.customWidth = from.customWidth;
                    this.customHeight = from.customHeight;
                }
                return true;
            }
            load(xDoc, nodeObj) {
                if (nodeObj !== null) {
                    this.height = xDoc.getNodeProperty(nodeObj, "Height").getValueInt(eTypes.eLong);
                    this.paperSize = xDoc.getNodeProperty(nodeObj, "PaperSize").getValueInt(eTypes.eInteger);
                    this.width = xDoc.getNodeProperty(nodeObj, "Width").getValueInt(eTypes.eLong);
                    this.orientation = xDoc.getNodeProperty(nodeObj, "Orientation").getValueInt(eTypes.eInteger);
                    this.customWidth = xDoc.getNodeProperty(nodeObj, "CustomWidth").getValueInt(eTypes.eLong);
                    this.customHeight = xDoc.getNodeProperty(nodeObj, "CustomHeight").getValueInt(eTypes.eLong);
                }
                return true;
            }
            save(xDoc, nodeFather) {
                let xProperty = null;
                let nodeObj = null;
                xProperty = new CSReports.CSXml.cXmlProperty();
                nodeObj = nodeFather;
                xProperty.setName("Height");
                xProperty.setValue(eTypes.eLong, this.height);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("PaperSize");
                xProperty.setValue(eTypes.eInteger, this.paperSize);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Width");
                xProperty.setValue(eTypes.eLong, this.width);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("Orientation");
                xProperty.setValue(eTypes.eInteger, this.orientation);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("CustomWidth");
                xProperty.setValue(eTypes.eLong, this.customWidth);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                xProperty.setName("CustomHeight");
                xProperty.setValue(eTypes.eLong, this.customHeight);
                xDoc.addPropertyToNode(nodeObj, xProperty);
                return true;
            }
        }
        CSReportEngine.cReportPaperInfo = cReportPaperInfo;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cReportScriptEngine {
            static getFunctionCall(code, formula) {
                let n = code.indexOf("(");
                let functionName = code.substring(8, n);
                let parameters = "";
                for (let _i = 0; _i < formula.getFormulasInt().count(); _i++) {
                    parameters += "globals.getVar(\"p__" + _i + "__\").getValue(),";
                }
                if (parameters.length > 0) {
                    parameters = parameters.substring(0, parameters.length - 1);
                }
                return functionName + "(" + parameters + ")";
            }
            static putCodeInClass(code, formula) {
                return "(()=> {"
                    + "\n\n"
                    + "//////////////////////////////////////"
                    + "\n\n"
                    + code
                    + "\n\n"
                    + "//////////////////////////////////////"
                    + "\n\n"
                    + "    const runScript = (globals) => {"
                    + "\n\n"
                    + "        return " + this.getFunctionCall(code, formula)
                    + "\n\n"
                    + "    };"
                    + "\n\n"
                    + "    return {runScript};"
                    + "\n\n"
                    + "})()";
            }
            static compileCode(code, formula) {
                const codeInClass = this.putCodeInClass(code, formula);
                return eval === null || eval === void 0 ? void 0 : eval(`"use string";(${codeInClass})`);
            }
            static eval(script, globals) {
                return script.runScript(globals);
            }
        }
        CSReportEngine.cReportScriptEngine = cReportScriptEngine;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cReportSectionLines extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportSectionLine);
                this.copyColl = null;
                this.typeSection = null;
                this._keys = [];
            }
            getTypeSection() {
                return this.typeSection;
            }
            setTypeSection(rhs) {
                this.typeSection = rhs;
            }
            setCopyColl(rhs) {
                let sectionLn = null;
                this.copyColl = rhs;
                for (let _i = 0; _i < this.count(); _i++) {
                    sectionLn = this.item(_i);
                    sectionLn.setCopyColl(rhs);
                }
            }
            getCopyColl() {
                return this.copyColl;
            }
            add(c = null, key = "", index = -1) {
                try {
                    if (c === null || c === undefined) {
                        c = new CSReportEngine.cReportSectionLine();
                    }
                    if (key === "" || key === undefined) {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    if (index !== -1 && this.count() > 0) {
                        this._keys.splice(index, 0, key);
                    }
                    else {
                        this._keys.push(key);
                    }
                    this.baseAdd(c, key);
                    c.setCopyColl(this.copyColl);
                    c.setTypeSection(this.typeSection);
                    this.refreshIndex();
                    c.setIndex(this.count() - 1);
                    c.setKey(key);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
            clear() {
                try {
                    let n = this.count();
                    for (let i = 0; i < n; i++) {
                        this.remove(0);
                    }
                    return;
                }
                catch (ignore) {
                }
            }
            remove(indexOrKey) {
                try {
                    let w_item = this.item(indexOrKey);
                    if (w_item !== null) {
                        if (w_item.getControls() !== null) {
                            w_item.getControls().clear();
                            w_item.getControls().setSectionLine(null);
                            w_item.getControls().setCopyColl(null);
                        }
                        if (typeof indexOrKey !== "string") {
                            this.baseRemove(this._keys[indexOrKey]);
                        }
                        else {
                            this.baseRemove(indexOrKey);
                        }
                        this.keyRemove(indexOrKey);
                    }
                }
                catch (ignore) {
                }
            }
            keyRemove(indexOrKey) {
                if (typeof indexOrKey === "string")
                    this.keyRemoveByKey(indexOrKey);
                else
                    this.keyRemoveByIndex(indexOrKey);
            }
            keyRemoveByKey(key) {
                this.keyRemoveByIndex(this._keys.indexOf(key));
            }
            keyRemoveByIndex(index) {
                if (index > -1) {
                    this._keys.splice(index, 1);
                }
            }
            refreshIndex() {
                for (let i = 0; i < this.count(); i++) {
                    this.item(i).setRealIndex(i);
                }
            }
            item(indexOrKey) {
                try {
                    if (typeof indexOrKey !== "string") {
                        return this.baseItem(this._keys[indexOrKey]);
                    }
                    else {
                        return this.baseItem(indexOrKey);
                    }
                }
                catch (_a) {
                    return null;
                }
            }
            toString() {
                return "lines count: " + this.count();
            }
        }
        CSReportEngine.cReportSectionLines = cReportSectionLines;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        var ReportGlobals = CSReports.CSReportGlobals.ReportGlobals;
        class cReportSections extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportSection);
                this.copyColl = null;
                this.typeSection = null;
                this.mainTypeSection = null;
                this._keys = [];
            }
            getTypeSection() {
                return this.typeSection;
            }
            setTypeSection(rhs) {
                this.typeSection = rhs;
            }
            setMainTypeSection(rhs) {
                this.mainTypeSection = rhs;
            }
            setCopyColl(rhs) {
                this.copyColl = rhs;
                if (this.count() > 0) {
                    for (let _i = 0; _i < this.count(); _i++) {
                        this.item(_i).setCopyColl(rhs);
                    }
                }
            }
            add(c = null, key = "", index = -1) {
                try {
                    if (c === null || undefined) {
                        c = new CSReportEngine.cReportSection();
                    }
                    if (key === "" || key === null || key === undefined) {
                        key = ReportGlobals.getNextKey().toString();
                    }
                    else {
                        ReportGlobals.refreshNextKey(key);
                    }
                    key = ReportGlobals.getKey(key);
                    if (index !== -1 && this.count() > 0) {
                        this._keys.splice(index, 0, key);
                    }
                    else {
                        this._keys.push(key);
                    }
                    this.baseAdd(c, key);
                    c.setCopyColl(this.copyColl);
                    if (this.count() === 1) {
                        c.setTypeSection(this.mainTypeSection);
                    }
                    else {
                        c.setTypeSection(this.typeSection);
                    }
                    this.refreshIndex();
                    c.setIndex(this.count() - 1);
                    c.setKey(key);
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
            clear() {
                try {
                    let n = this.count();
                    for (let i = 0; i < n; i++) {
                        this.remove(0);
                    }
                    return;
                }
                catch (ignore) {
                }
            }
            remove(indexOrKey) {
                try {
                    this.item(indexOrKey).getSectionLines().clear();
                    if (typeof indexOrKey !== "string") {
                        this.baseRemove(this._keys[indexOrKey]);
                    }
                    else {
                        this.baseRemove(indexOrKey);
                    }
                    this.keyRemove(indexOrKey);
                    for (let i = 0; i < this.count(); i++) {
                        let sec = this.item[this._keys[i]];
                        sec.setIndex(i);
                        sec.setName(sec.getName().substring(0, 2).replaceAll("_", "")
                            + "_" + i.toString());
                    }
                    this.refreshIndex();
                }
                catch (ignore) {
                }
            }
            keyRemove(indexOrKey) {
                if (typeof indexOrKey === "string")
                    this.keyRemoveByKey(indexOrKey);
                else
                    this.keyRemoveByIndex(indexOrKey);
            }
            keyRemoveByKey(key) {
                this.keyRemoveByIndex(this._keys.indexOf(key));
            }
            keyRemoveByIndex(index) {
                if (index > -1) {
                    this._keys.splice(index, 1);
                }
            }
            refreshIndex() {
                for (let i = 0; i < this.count(); i++) {
                    this.item(i).setRealIndex(i);
                }
            }
            item(indexOrKey) {
                try {
                    if (typeof indexOrKey !== "string") {
                        return this.baseItem(this._keys[indexOrKey]);
                    }
                    else {
                        return this.baseItem(indexOrKey);
                    }
                }
                catch (_a) {
                    return null;
                }
            }
        }
        CSReportEngine.cReportSections = cReportSections;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cReportVariable {
            constructor() {
                this.value = null;
            }
            getValue() {
                return this.value;
            }
            setValue(rhs) {
                this.value = rhs;
            }
        }
        CSReportEngine.cReportVariable = cReportVariable;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        var Map = CSReports.CSOAPI.Map;
        class cReportVariables extends Map {
            constructor() {
                super(null, false, CSReportEngine.cReportVariable);
            }
        }
        CSReportEngine.cReportVariables = cReportVariables;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportEngine;
    (function (CSReportEngine) {
        class cStructTime {
            constructor() {
                this.hour = 0;
                this.minute = 0;
                this.second = 0;
            }
            getHour() {
                return this.hour;
            }
            setHour(rhs) {
                this.hour = rhs;
            }
            getMinute() {
                return this.minute;
            }
            setMinute(rhs) {
                this.minute = rhs;
            }
            getSecond() {
                return this.second;
            }
            setSecond(rhs) {
                this.second = rhs;
            }
        }
        CSReportEngine.cStructTime = cStructTime;
    })(CSReportEngine = CSReports.CSReportEngine || (CSReports.CSReportEngine = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        var Exception = CSReports.CSOAPI.Exception;
        class ReportPaintException extends Exception {
        }
        CSReportPaint.ReportPaintException = ReportPaintException;
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        class cReportPaintError {
            static errGetDescription(rptErrCode) {
                switch (rptErrCode) {
                    case csRptPaintErrors.CSRPT_PAINT_ERR_OBJ_CLIENT:
                        return "The ObjectClient property of the object cReportPaint is not defined when calling to DrawObject method.";
                    case csRptPaintErrors.CSRPT_PAINT_ERR_OBJ_CLIENT_INVALID:
                        return "The ObjectClient property of the object cReportPaint is invalid (it references an object which is neither a Printer nor a PictureBox) when calling DrawObject method.";
                    default:
                        return "There is not information for this error";
                }
            }
        }
        CSReportPaint.cReportPaintError = cReportPaintError;
        let csRptPaintErrors;
        (function (csRptPaintErrors) {
            csRptPaintErrors[csRptPaintErrors["CSRPT_PAINT_ERR_OBJ_CLIENT"] = 2001] = "CSRPT_PAINT_ERR_OBJ_CLIENT";
            csRptPaintErrors[csRptPaintErrors["CSRPT_PAINT_ERR_OBJ_CLIENT_INVALID"] = 2002] = "CSRPT_PAINT_ERR_OBJ_CLIENT_INVALID";
            csRptPaintErrors[csRptPaintErrors["CSRPT_PAINT_ERR_PRINTING"] = 2003] = "CSRPT_PAINT_ERR_PRINTING";
        })(csRptPaintErrors = CSReportPaint.csRptPaintErrors || (CSReportPaint.csRptPaintErrors = {}));
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        var cReportAspect = CSReports.CSReportEngine.cReportAspect;
        class cReportPaintObject {
            constructor() {
                this.aspect = new cReportAspect();
                this.key = "";
                this.text = "";
                this.paintType = CSReportPaint.csRptPaintObjType.PAINT_OBJ_BOX;
                this.tag = "";
                this.rptType = null;
                this.rptKeySec = "";
                this.image = null;
                this.indexField = 0;
                this.isSection = null;
                this.isSectionLine = null;
                this.heightSec = 0;
                this.heightSecLine = 0;
                this.textLine = "";
            }
            getImage() {
                return this.image;
            }
            setImage(rhs) {
                this.image = rhs;
            }
            getAspect() {
                return this.aspect;
            }
            setAspect(rhs) {
                this.aspect = rhs;
            }
            getKey() {
                return this.key;
            }
            setKey(rhs) {
                this.key = rhs;
            }
            getText() {
                return this.text;
            }
            setText(rhs) {
                this.text = rhs;
            }
            getPaintType() {
                return this.paintType;
            }
            setPaintType(rhs) {
                this.paintType = rhs;
            }
            getRptType() {
                return this.rptType;
            }
            setRptType(rhs) {
                this.rptType = rhs;
            }
            getTag() {
                return this.tag;
            }
            setTag(rhs) {
                this.tag = rhs;
            }
            getRptKeySec() {
                return this.rptKeySec;
            }
            setRptKeySec(rhs) {
                this.rptKeySec = rhs;
            }
            getIndexField() {
                return this.indexField;
            }
            setIndexField(rhs) {
                this.indexField = rhs;
            }
            getHeightSec() {
                return this.heightSec;
            }
            setHeightSec(rhs) {
                this.heightSec = rhs;
            }
            getHeightSecLine() {
                return this.heightSecLine;
            }
            setHeightSecLine(rhs) {
                this.heightSecLine = rhs;
            }
            getTextLine() {
                return this.textLine;
            }
            setTextLine(rhs) {
                this.textLine = rhs;
            }
            getIsSection() {
                return this.isSection;
            }
            setIsSection(rhs) {
                this.isSection = rhs;
            }
            getIsSectionLine() {
                return this.isSectionLine;
            }
            setIsSectionLine(rhs) {
                this.isSectionLine = rhs;
            }
        }
        CSReportPaint.cReportPaintObject = cReportPaintObject;
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        var Map = CSReports.CSOAPI.Map;
        class cReportPaintObjects extends Map {
            constructor() {
                super(null, false, CSReportPaint.cReportPaintObject);
                this.zorder = [];
            }
            remove(indexOrKey) {
                this.baseRemove(indexOrKey);
                let key = (typeof indexOrKey === "string") ? indexOrKey : this.keyByIndex(indexOrKey);
                this.removeZOrder(key);
            }
            clear() {
                this.baseClear();
                this.zorder = [];
            }
            add(c, key) {
                try {
                    if (c === null) {
                        c = new CSReportPaint.cReportPaintObject();
                    }
                    if (key === "") {
                        key = CSReportPaint.cGlobals.getNextKey().toString();
                    }
                    key = CSReportPaint.cGlobals.getKey(key);
                    this.baseAdd(c, key);
                    c.setKey(key);
                    this.zorder[this.count() - 1] = key;
                    return c;
                }
                catch (ignore) {
                    return null;
                }
            }
            bringToFront(key) {
                this.setZorder(key, true);
            }
            sendToBack(key) {
                this.setZorder(key, false);
            }
            setZorder(key, top) {
                let i;
                for (i = 0; i < this.zorder.length; i++) {
                    if (this.zorder[i] === key) {
                        break;
                    }
                }
                if (i >= this.zorder.length - 1 && top) {
                    return;
                }
                if (i === 0 && !top) {
                    return;
                }
                if (top) {
                    for (; i < this.zorder.length - 1; i++) {
                        this.zorder[i] = this.zorder[i + 1];
                        this.item(this.zorder[i]).getAspect().setNZOrder(i);
                    }
                    this.zorder[this.zorder.length - 1] = key;
                    this.item(key).getAspect().setNZOrder(this.zorder.length - 1);
                }
                else {
                    for (; i > 0; i--) {
                        this.zorder[i] = this.zorder[i - 1];
                        this.item(this.zorder[i]).getAspect().setNZOrder(i);
                    }
                    this.zorder[0] = key;
                    this.item(key).getAspect().setNZOrder(0);
                }
            }
            getZOrderForKey(key) {
                for (let i = 0; i < this.zorder.length; i++) {
                    if (this.zorder[i] === key) {
                        return i;
                    }
                }
                return -1;
            }
            getNextKeyForZOrder(index) {
                return this.zorder[index];
            }
            getNextPaintObjForZOrder(index) {
                return this.item(this.getNextKeyForZOrder(index));
            }
            removeZOrder(sKey) {
                for (let i = 0; i < this.zorder.length; i++) {
                    if (this.zorder[i] === sKey) {
                        this.zorder.splice(i, 1);
                        return;
                    }
                }
            }
        }
        CSReportPaint.cReportPaintObjects = cReportPaintObjects;
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportPaint;
    (function (CSReportPaint) {
        var U = CSReports.CSOAPI.Utils;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var ReportPreview = CSReports.CSForms.ReportPreview;
        class fPreview extends Form {
            constructor() {
                super();
                this.el = U.el('preview-dlg-template').cloneNode(true);
                this.el.id = null;
                this.title = U.labelElc('preview-dlg-title', this.el);
                this.title.textContent = 'Preview report';
                this.reportPreview = new ReportPreview("reportPreview", U.elc('preview-dlg-report-preview', this.el));
                this.dialog = new Dialog(this.el, 'preview-dlg-okay');
                super.setDialog(this.dialog);
            }
            getRpwReport() {
                return this.reportPreview;
            }
            show(owner = null) {
                return this.showDialog();
            }
            showDialog() {
                return this.showModal();
            }
            showModal() {
                return this.dialog.show({ title: this.title.textContent, height: 1024, width: 800, overlay: true });
            }
        }
        CSReportPaint.fPreview = fPreview;
    })(CSReportPaint = CSReports.CSReportPaint || (CSReports.CSReportPaint = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSReportScript;
    (function (CSReportScript) {
        class cReportCompilerVar {
            constructor() {
                this.value = null;
            }
            getValue() {
                return this.value;
            }
            setValue(rhs) {
                this.value = rhs;
            }
        }
        CSReportScript.cReportCompilerVar = cReportCompilerVar;
    })(CSReportScript = CSReports.CSReportScript || (CSReports.CSReportScript = {}));
})(CSReports || (CSReports = {}));
const reportWorker = (() => {
    let pages = null;
    let images = null;
    const init = () => {
        String.prototype.contains = function (value) {
            let d = String(this);
            return (d.indexOf(value) > -1);
        };
        String.prototype.format = function (format) {
            console.log('in String Prototype 2 : ' + format);
            return String(this);
        };
    };
    const reportProgress = (report, eventArgs) => {
        postMessage({ action: 'report-progress', eventArgs: eventArgs });
    };
    const reportDone = (report) => {
        postMessage({ action: 'report-generation-done' });
    };
    const registerDataSource = (database, request) => {
        const dataSources = request["content"]["data"]["data"];
        for (let i = 0; i < dataSources.length; i++) {
            const dataSource = dataSources[i];
            const ds = new CSReports.CSDatabase.JSONDataSource(dataSource["name"].toString(), dataSource["data"]);
            CSReports.CSDatabase.JSONServer.registerDataSource(ds, database + "." + ds.getName());
        }
    };
    const launch = (data) => {
        const report = new CSReports.CSReportEngine.cReport();
        const reportFrom = JSON.parse(data.report);
        report.copy(reportFrom);
        const launchInfo = new CSReports.CSReportEngine.cReportLaunchInfo();
        const launchInfoFrom = JSON.parse(data.launchInfo);
        launchInfo.copy(launchInfoFrom);
        const reportPrint = new CSReports.CSReportPaint.cReportPrint();
        reportPrint.setHidePreviewWindow(true);
        launchInfo.setReportPrint(reportPrint);
        report.onProgress(reportWorker.reportProgress);
        report.onReportDone(reportWorker.reportDone);
        report.setRunningInWebWorker(true);
        report.launch(launchInfo).then(() => {
            pages = report.getPages();
            images = report.getImages();
            postMessage({ action: 'worker-launch-complete-successfully', message: 'report launch completes successfully' });
        })
            .catch((reason) => {
            postMessage({ action: 'worker-launch-failed', message: 'report launch failed', reason: reason });
        });
    };
    const sendReportPagesToMainTread = () => {
        const eventArgs = new CSReports.CSReportEngine.ProgressEventArgs("Formating pages", 0, 0, 0);
        postMessage({ action: 'get-report-start', eventArgs: eventArgs });
        const base64Images = images.filter((i) => {
            return !(i.bitmap.getImageData() instanceof ImageData);
        });
        postMessage({ action: 'get-report-images', images: JSON.stringify(base64Images), eventArgs: eventArgs });
        images.forEach((key, image) => {
            const imageData = image.bitmap.getImageData();
            if (imageData instanceof ImageData) {
                image.bitmap;
                postMessage({ action: 'get-report-uint-images', key: key, imageData: imageData, eventArgs: eventArgs });
            }
        });
        pages.getValues().forEach((page) => {
            const fields = [...page.getHeader().getValues(), ...page.getDetail().getValues(), ...page.getFooter().getValues()];
            fields.forEach((field) => {
                field.getInfo().getSectionLine().getControls().forEach((k, c) => c.setSectionLine(null));
                field.getInfo().getSectionLine().getControls().setSectionLine(null);
                field.getInfo().getSectionLine().getControls().setCopyColl(null);
                field.getInfo().getSectionLine().setCopyColl(null);
                if (field.getImage() !== null && field.getImage() !== undefined) {
                    field.getImage().removeImageBitmap();
                }
            });
        });
        let start = 0;
        const CHUNK_SIZE = 10;
        while (true) {
            const chunk = pages.getChunk(start, CHUNK_SIZE);
            if (chunk.count() === 0)
                break;
            start += CHUNK_SIZE;
            const eventArgs = new CSReports.CSReportEngine.ProgressEventArgs("Formating pages", start, start, pages.size());
            postMessage({ action: 'get-report-pages', pages: JSON.stringify(chunk), eventArgs: eventArgs });
        }
        postMessage({ action: 'get-report-done' });
    };
    return {
        init,
        reportProgress,
        reportDone,
        registerDataSource,
        launch,
        sendReportPagesToMainTread
    };
})();
onmessage = function (e) {
    switch (e.data.action) {
        case 'init':
            reportWorker.init();
            break;
        case 'register-datasource':
            reportWorker.registerDataSource(e.data.database, e.data.request);
            break;
        case 'launch':
            reportWorker.launch(e.data);
            break;
        case 'get-report':
            reportWorker.sendReportPagesToMainTread();
            break;
        default:
            postMessage({ message: 'unknown action: ' + e.data.action });
    }
};
var CSReports;
(function (CSReports) {
    var CSReportWebServer;
    (function (CSReportWebServer) {
        var U = CSReports.CSOAPI.Utils;
        var Form = CSReports.CSForms.Form;
        var Dialog = CSReports.CSForms.Dialog;
        var Label = CSReports.CSForms.Label;
        var ProgressBar = CSReports.CSForms.ProgressBar;
        class FProgress extends Form {
            constructor() {
                super();
                this.el = U.el('csreports-progress-dlg-template').cloneNode(true);
                this.el.id = null;
                this.currPage = new Label(U.labelElc('csreports-progress-dlg-curr-page', this.el));
                this.task = new Label(U.labelElc('csreports-progress-dlg-task', this.el));
                this.rowCount = new Label(U.labelElc('csreports-progress-dlg-row-count', this.el));
                this.currRow = new Label(U.labelElc('csreports-progress-dlg-curr-row', this.el));
                this.progressBar = new ProgressBar(U.divElc('csreports-progress-dlg-progress-bar-status', this.el));
                this.progressBar.setWidth(600);
                this.progressBar.setHeight(10);
                this.progressBar.setValue(0);
                this.progressBar.setBackColor("green");
                this.title = U.labelElc('csreports-progress-dlg-title', this.el);
                this.title.textContent = 'Executing report';
                this.dialog = new Dialog(this.el, 'csreports-progress-dlg-cancel');
                super.setDialog(this.dialog);
            }
            getLbCurrPage() {
                return this.currPage;
            }
            getLbTask() {
                return this.task;
            }
            getLbCurrRecord() {
                return this.currRow;
            }
            getLbRecordCount() {
                return this.rowCount;
            }
            getPrgBar() {
                return this.progressBar;
            }
            show(owner = null) {
                return this.showDialog();
            }
            showDialog() {
                return this.showModal();
            }
            showModal() {
                return this.dialog.show({ title: this.title.textContent, height: 500, width: 800, overlay: true });
            }
        }
        CSReportWebServer.FProgress = FProgress;
    })(CSReportWebServer = CSReports.CSReportWebServer || (CSReports.CSReportWebServer = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSXml;
    (function (CSXml) {
        class XmlAttribute {
            constructor(name) {
                this.name = name;
            }
        }
        CSXml.XmlAttribute = XmlAttribute;
    })(CSXml = CSReports.CSXml || (CSReports.CSXml = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSXml;
    (function (CSXml) {
        var NotImplementedException = CSReports.CSOAPI.NotImplementedException;
        class XmlDocument {
            constructor() {
                this.xmlDoc = new Document();
            }
            appendChild(node) {
                this.xmlDoc.appendChild(node.getDomNode());
            }
            createNode(name, value) {
                let node = this.xmlDoc.createElement(name);
                node.nodeValue = value;
                return new CSXml.XmlNode(node);
            }
            save(filename) {
                throw new NotImplementedException();
            }
            getElementsByTagName(nodeTag) {
                return Array.from(this.xmlDoc.getElementsByTagName(nodeTag))
                    .map(node => new CSXml.XmlNode(node));
            }
            createAttribute(name) {
                return new CSXml.XmlAttribute(name);
            }
            load(xmlText) {
                const parser = new DOMParser();
                this.xmlDoc = parser.parseFromString(xmlText, "application/xml");
            }
        }
        CSXml.XmlDocument = XmlDocument;
    })(CSXml = CSReports.CSXml || (CSReports.CSXml = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var CSXml;
    (function (CSXml) {
        class XmlNode {
            constructor(node) {
                this.childrenLoaded = false;
                this.node = node;
            }
            getDomNode() {
                return this.node;
            }
            getChildNodes() {
                if (!this.childrenLoaded) {
                    this.childNodes = Array.from(this.node.children).map(n => new XmlNode(n));
                    this.childrenLoaded = true;
                }
                return this.childNodes;
            }
            getNextSibling() {
                let nextNode = this.node.nextSibling;
                while (true) {
                    if (nextNode === null)
                        return null;
                    if (nextNode.nodeName !== "#text")
                        return new XmlNode(nextNode);
                    nextNode = nextNode.nextSibling;
                }
            }
            addAttribute(attr) {
                this.node.setAttribute(attr.name, attr.value);
            }
            appendChild(node) {
                this.node.appendChild(node.getDomNode());
            }
            selectSingleNode(nodeTag) {
                const node = this.node.getElementsByTagName(nodeTag)[0];
                if (node) {
                    return new XmlNode(node);
                }
                else {
                    return null;
                }
            }
            attributeByName(propertyName) {
                let value = this.node.getAttribute(propertyName);
                if (value) {
                    let xmlAtt = new CSXml.XmlAttribute(propertyName);
                    xmlAtt.value = value;
                    return xmlAtt;
                }
                else {
                    return null;
                }
            }
        }
        CSXml.XmlNode = XmlNode;
    })(CSXml = CSReports.CSXml || (CSReports.CSXml = {}));
})(CSReports || (CSReports = {}));
var CSReports;
(function (CSReports) {
    var JSPDFLibrary;
    (function (JSPDFLibrary) {
        class AcroFormField {
        }
        JSPDFLibrary.AcroFormField = AcroFormField;
    })(JSPDFLibrary = CSReports.JSPDFLibrary || (CSReports.JSPDFLibrary = {}));
})(CSReports || (CSReports = {}));
//# sourceMappingURL=csreports.js.map